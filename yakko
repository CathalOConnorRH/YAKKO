#!/bin/bash

YAKKOVERSION=2.05 
YAKKODATE=20210819.0952

###########################################################################
# YAKKO - Yet another KVM Konfigurator for OpenShift
# AUTHOR: Daniel Cifuentes
# ------------------------------------------------------------------------ 
# A COVID Pandemic Confinement project - Circa 09/2020 
# ------------------------------------------------------------------------ 
# Inspirational documentation for this:
# https://github.com/eitchugo/openshift-libvirt/blob/master/OpenShift_4_libvirt_install_1_master.md
###########################################################################

##########################################################################
# BACKLOG:
# - use chrony? 
#   20/05/2021 verified that in OCP 4.7, master nodes already have /etc/chrony.conf
#   configured as indicated in 
#   https://docs.openshift.com/container-platform/4.7/installing/install_config/installing-customizing.html
# - (COMPLEX) Work on non-virtual network. That may be a project for the next pandemic
##########################################################################

######## THESE CAN BE USER CONFIGURABLE FOR FURTHER TESTING.At your own risk.
MASTERNODECOUNT=3  # Unless instructed otherwise, OCP 4.8+
MASTERVCPUS=4      # Recommended 4
WORKERVCPUS=2      # Recommended 2
MASTERDISKSIZE=30  # Disk image size for master, GB
WORKERDISKSIZE=30  # Disk image size for worker, GB
MAXNODEVCPUS=4     # Max number of allowable CPUs for a worker node
MAXWORKERNODES=5   # Max number of worker nodes allowed at cluster BUILD time, after that, no limit 
REDUCEPROMETHEUS=Y # Prometheus pod RAM can be reduced, which makes sense, change to N if not desired. 
                   # You can change this with MANUAL build too.
 
######### THESE CAN BE CHANGED INTERACTIVELY #############################
RECMASTERRAMSIZE=16000 # Recommended 8192. 6000 not enough
WORKERRAMSIZE=3500 # Recommended ... 2048!? Worked well with 5Gi. Use as 8 to do some real work
MINWORKERRAMSIZE=3500 # This boundary has been changing as OCP revs up!
##########################################################################

# The BASEMACADDRESS is missing the last two entries/hexes. The second to last is calculated on
# the last number of the BASEMACNETWORK, in case two clusters run on the same box, to prevent 
# virtual network confusion, even if perhaps... it may work without conflict. Original code had
# this number as 52:54:00:4a:66 but now the last hex number will be the 3 network digit i.e. 140 which is "8c"
COREMACADDRESS="52:54:00:4a"
PROXYADDRESS=1  # So that the overall "proxy" to the cluster is BASENETWORK.PROXY e.g. 192.168.140.1
BASENETWORK="192.168.140"
WEBSERVERPORT=8080 # This may have to change

# File and directory variables used throughout
YAKKONAME=yakko   # In case we want to change the name of the script
OCPWGETTMP=/tmp/ocpsetupwget.tmp
OCPVMDISKDIR=/var/lib/libvirt/images
CLUSTERDOMAIN=localdomain  
DHCPXMLTMPFILE=/tmp/yakkodhcpxmlline.tmp
HTPASSWDFILE=/tmp/ocp-htpasswd

# Cluster build progression variables
YAKKOSTAGE=0
STAGEPROGRESS=0
YAKKOREBUILD=0 
AUTOSETUP=0 # 1 is Auto, 0 is manual
YAKKOTEXTCOLOR=brightblue
DELETECLUSTERMODE=1  # This goes to 0 when we delete the entire cluster with deletecluster
DELETECLUSTERFORCE=1
ADDNODETIMEOUT=600 # If I cannot add a node within 10 minutes, timeout (this multiplied by number of nodes)
KUBEADMIN=kubeadmin # once deleted this is stored as "" in CLUSTERCONFIGFILE

# Some parameter options
YAKKOINFRAOPTIONS=" startcluster / stopcluster / addnode / deletenode / nodelogs / sshtonode / changeaccess / restartservices / deletecluster "
YAKKOCLUSTEROPTIONS=" htpasswd / useradd / userdelete / mastersched / nodelabel / localregistry / ingresscert / approvecsrs / yakkotest "

# Decorations
SEPARATIONLINE="__________________________________________________________________________"


################ A FEW INITIALISATION FUNCTIONS ################################################

populate-clusterconfigfile() {
	# CLUSTERCONFIGFILE CREATION
	# Populate the config file with some references for future calls
	{
		echo "CLUSTERNAME=${CLUSTERNAME}" 
		echo "CLUSTERFQDN=${CLUSTERFQDN}"
		echo "CLUSTERWEBURL=${CLUSTERWEBURL}"
		echo "CLUSTERAPIURL=${CLUSTERAPIURL}"
		echo "YAKKOSTAGE=0"
		echo "CLUSTERSETUPDIR=${CLUSTERSETUPDIR}" 
		echo "NETWORKNAME=${NETWORKNAME}" 
		echo "OCPGETCLIENTVERSION=${OCPGETCLIENTVERSION}"
		echo "OCPDOWNLOADCLIENT=${OCPDOWNLOADCLIENT}"
		echo "OCPDOWNLOADIMAGE=${OCPDOWNLOADIMAGE}"
		echo "NETWORKXML=$CLUSTERSETUPDIR/${NETWORKNAME}.xml"
		echo "NETWORKADDRESSSLOT=20"
		echo "NODECOUNT=0"
		echo "OCPSSHKEY=${OCPSSHKEY}"
		echo "HAPROXYCONFIGFILE=${HAPROXYCONFIGFILE}"
		echo "BUILTWITHYAKKOVERSION=${YAKKOVERSION}"
		
	} > ${CLUSTERCONFIGFILE}

	source ${CLUSTERCONFIGFILE}
}

populate-yakkodefaults() {
  
	{
		echo "CLUSTERNAME=${CLUSTERNAME}"
		echo "CLUSTERDOMAIN=${CLUSTERDOMAIN}"
		echo "OCPVMDISKDIR=${OCPVMDISKDIR}"
		echo "MASTERNODECOUNT=${MASTERNODECOUNT}"
		echo "WORKERNODECOUNT=${WORKERNODECOUNT}"
		echo "CLUSTERPROXY=${CLUSTERPROXY}"
		echo "WEBSERVERIP=${WEBSERVERIP}"
		echo "MASTERRAMSIZE=${MASTERRAMSIZE}"
		echo "WORKERRAMSIZE=${WORKERRAMSIZE}"
		echo "PAUSEFORCONFIGEDIT=${PAUSEFORCONFIGEDIT}"
	
		# NETWORK CONFIGURATION
		echo "BASEMACADDRESS=${BASEMACADDRESS}"
		echo "BASENETWORK=${BASENETWORK}"
		echo "DNSMASQCONFIGFILE=${DNSMASQCONFIGFILE}"
		echo "YAKKOHOSTIP=${YAKKOHOSTIP}"
		echo "HAPROXYACCESS=${HAPROXYACCESS}"
		echo "ENABLEDNSMASQ=${ENABLEDNSMASQ}"

		# This will be used for creating nodes later on so that any new nodes start at $NETWORKADDRESSSLOT
		# Note that bootstrap and masters have fixed numbers for IP and MAC
		# 52:54:00 is KVM/QEMU default    4A:66:00 is a transliteration of YAKKO ;)
		# All worker nodes will begin with MAC and IP $NETWORKADDRESSSLOT
		echo "NETWORKADDRESSSLOT=20"
		echo "BOOTSTRAPMAC=${BASEMACADDRESS}:09"
		echo "MASTER0MAC=${BASEMACADDRESS}:10"
		echo "MASTER1MAC=${BASEMACADDRESS}:11"
		echo "MASTER2MAC=${BASEMACADDRESS}:12"
		echo "BOOTSTRAPIP=${BASENETWORK}.9"
		echo "MASTER0IP=${BASENETWORK}.10"
		echo "MASTER1IP=${BASENETWORK}.11"
		echo "MASTER2IP=${BASENETWORK}.12"

	} > ${YAKKODEFAULTS}

	source ${YAKKODEFAULTS}

}

################ A FEW REUSABLE FUNCTIONS ################################################


print-in-colour() {

	# $1 is the color:
	case "$1" in
		"red") TEXTCOLOR=1;;
		"green") TEXTCOLOR=2;;
		"lightblue") TEXTCOLOR=6;;
		"brightblue") TEXTCOLOR=14;;
		"orange") TEXTCOLOR=9;;
	esac
	
        tput setaf ${TEXTCOLOR};tput bold
	shift
	echo "$*"
        tput sgr0
}


print-time-elapsed() {

	TIMEELAPSEDSECS=$(( $SECONDS - $TIMESTART))
	TIMEELAPSEDMINS=$(( $TIMEELAPSEDSECS / 60 ))

	print-in-colour ${YAKKOTEXTCOLOR} "Time elapsed: " ${TIMEELAPSEDMINS} mins $(( ${TIMEELAPSEDSECS} - (${TIMEELAPSEDMINS} * 60 ) )) secs

}

print-question-separator() {
	echo
	tput bold
	echo ----
	tput sgr0
}


ask-user() {

        # $1 is the string to display
	# $2 is the default if user presses <ENTER>
        # $3 as "noauto" ignores the AUTOSETUP flag
	# Returns 0 for YES and 1 for NO
        DIALOGUETEXT=$1
	DEFAULTRESPONSE=$2
        NOAUTO=$3

	# We are within a stage, so we need to setup a trap to rollback
	[ ! -z "${CURRENTSTAGE}" ] && trap "echo; echo 'Input interrupted. Aborting.'; ${CURRENTSTAGE} rollback; echo; cleanup-and-exit" SIGINT

	if [ $AUTOSETUP -eq 1 -a "$NOAUTO" == ""  ]
	then 
		# if in AUTO mode return DEFAULTRESPONSE
                if [ "$DEFAULTRESPONSE" == "y" -o "$DEFAULTRESPONSE" == "Y" ]
                then
                        return 0
                elif [ "$DEFAULTRESPONSE" == "n" -o "$DEFAULTRESPONSE" == "N" ]
                then
                        return 1 # 1 = false!
		fi
	fi

	# We use AURESPONSE as "Ask User Response" - because RESPONSE is global :(
 	while [ 1 ]
        do
                echo -n "$DIALOGUETEXT (Y/N) [$DEFAULTRESPONSE]? "
                read AURESPONSE

		[ -z "${AURESPONSE}" ] && AURESPONSE=${DEFAULTRESPONSE} 

                if [ "$AURESPONSE" == "y" -o "$AURESPONSE" == "Y" ]
                then
                        return 0
                elif [ "$AURESPONSE" == "n" -o "$AURESPONSE" == "N" ]
                then
                        return 1 # 1 = false!
                else
                        echo "Invalid reponse [$AURESPONSE]."
                fi
        done
}


cleanup-and-exit() {

	exit

}


check-for-error-and-exit() {
	# Something bad got caught somewhere - write this out and abort
	# $1 is the error code passed (0 is good)
	# $2 is a string to report

	# If we are already in a rollback don't repeat!
	if [ "${ROLLBACKACTIVE}" == "Y"  ] 
	then
		return
	fi

	# There is no error found
	[ "$1" -eq 0 ] && return

	# Else... Doom!
	echo
	print-in-colour red  "ERROR: $2. Exiting."
	echo

	if [ ! -z "${CURRENTSTAGE}" ]
	then
		#We are within a stage so we rollback
		ask-user "Rollback steps of this stage (y) or leave for debugging (n)" "Y" noauto

		[ $? -eq 0 ] && ${CURRENTSTAGE} rollback 
	fi
	echo
	cleanup-and-exit
}


install-package-if-missing() {
	
	# $1 is the package to check for
	PACKAGE=$1

	dnf list installed | grep $PACKAGE > /dev/null 2>&1
	[ $? -ne 0 ] && {
		echo Installing package [$PACKAGE]
		dnf -y install $PACKAGE
		check-for-error-and-exit $? "Failed to install package [$PACKAGE]"
	}
}


get-node-fqdn()
{
	# This is a safety measure...
	# This function should be called as
	# $(get-node-fqdn $NODENAME)
	# it returns a nodename with the FQDN attached

	FQDNNODENAME=$1
	echo ${FQDNNODENAME} | grep ${CLUSTERFQDN} > /dev/null 2>&1
	[ $? -ne 0 ] && FQDNNODENAME=${FQDNNODENAME}.${CLUSTERFQDN}

	echo ${FQDNNODENAME}
}


check-haproxy-access()
{
	# Returns 0 if external access is ENABLED
	#         1 if external access is DISABLED

	cat ${HAPROXYCONFIGFILE} | grep "bind :6443" >/dev/null 2>&1
	if [ $? -eq 0 ]
	then
		return 0
	else
		return 1
	fi
}


check-node-name()
{
	# Quick function to check that user is passing valid yakk nodename
	# check-node-name CHECKNODENAME [exit]

	# Return 0 if the VM name belongs to the cluster
	# Return 1 if the VM name does not belong to the cluster
	# Return 2 if the VM name does not exist!

	CHECKNODENAME=$1
	EXITONINVALID=$2

	virsh list --all | grep ${CHECKNODENAME}  > /dev/null 2>&1
	if [ $? -eq 1 ]
	then
		# There is no such nodename
		return 2
	fi

	# If something skips the below check, buy the lotto with the nodename ASCIIs...
	virsh list --all | awk '{print $2}' | grep ${CHECKNODENAME} | grep -E '^master-|^node-|^bootstrap' | grep "${CLUSTERFQDN}"  > /dev/null 2>&1
	if [ $? -eq 0 ]
	then
		# Node name belongs to YAKKO setup
		return 0
	else
		[ "${EXITONINVALID}" == "exit" ] && {
			echo
			echo "Invalid node name [$CHECKNODENAME]. Exiting..."
			echo
			cleanup-and-exit
		}
		return 1
	fi
}


delete-kvm-machine()
{
	# This is a safety measure...
	NODETODELETEFQDN=$(get-node-fqdn $1)

	check-node-name $NODETODELETEFQDN
	RESULT=$?

	if [ $RESULT -eq 0 ]
	then
		virsh destroy ${NODETODELETEFQDN} 2>/dev/null #Errors when machine is not running... so what.
		virsh undefine --domain ${NODETODELETEFQDN} --remove-all-storage
	fi

	if [ $RESULT -eq 1 ]
	then
		echo "ERROR: Tried to delete non-cluster KVM machine: [${NODETODELETEFQDN}]"
		#exit
	fi
}


advance-stage-progression() {

	# We skip all stages until we get to the one we were in...
	((++STAGEPROGRESS))

	#We'll get a timestamp of the first stage for a final run report
	[ -z "${TIMESTART}" ] && TIMESTART=$SECONDS

	if [ ${STAGEPROGRESS} -lt ${YAKKOSTAGE} ]
	then
		return 0
	else
		echo
		print-in-colour ${YAKKOTEXTCOLOR} ${SEPARATIONLINE}
		echo
		print-in-colour ${YAKKOTEXTCOLOR} "STAGE ${STAGEPROGRESS}: $1 (Time start: $(date +%H:%M%p))"
		echo
	
		# We write the stage we are at so that we can return if desired
		sed -i "/YAKKOSTAGE.*/c\YAKKOSTAGE=${STAGEPROGRESS}" ${CLUSTERCONFIGFILE} 2>/dev/null

		# Since this stage will progress, we capture CTRL-C to rollback 
		# we set it to 0 so that the running advance-stage can call itself back
		trap 'echo; ${FUNCNAME[0]} rollback; echo; exit' SIGINT

		# And we set the CURRENTSTAGE in case we have to rollback from a deeper function, to ease lookup
		# This works because advance-stage-progression CAN ONLY be called within a stage, and at the begining!
		CURRENTSTAGE=${FUNCNAME[1]}

		return 1
	fi
}


rollback-stage-progression() {
	echo
	# We set this variable so that YAKKO knows that we are in aborting mode
	# Particularly useful in check-for-error-and-exit as is may well call rollback
	# again, and end up in a loop
	ROLLBACKACTIVE=Y
	print-in-colour orange "ROLLBACK STAGE: $*"
}


get-node-list() {

	# call: get-node-list <all|active> [print]

	if [ $1 == "all" ]
	then
		NODELIST=" $(virsh list --all --name | grep -e "master-" -e "node-" -e "bootstrap") "
	fi

	if [ $1 == "active" ]
	then
		NODELIST=" $(virsh list --name | grep -e "master-" -e "node-" -e "bootstrap") "
	fi

	if [ "$2" == "print" ]
	then
		#we also print the list in columns
		for NODE in ${NODELIST}
		do
			echo ${NODE}
		done
	fi
}

pick-a-node() {

	# Call: pick-a-node <string-to-display-for-chooser-query>
	while [ 1 ]
	do
		echo "Available nodes for this action are:"
		get-node-list active print
		echo
		echo -n "$1: "
		read NODENAME
		[ $? -eq 0 ] && break
	done
}
	

compose-html-cluster-report() {

	# This here builds a landing page for the info of the last cluster built
	# the web server left a file index.html sitting there

	# To be honest, this just makes the whole thing look more professional ;)

	lsof -i -P -n | grep LISTEN | grep "${YAKKOHOSTIP}:${WEBSERVERPORT} " > /dev/null 2>&1
	if [ $? -eq 1 ]
	then
		# Nothing is listening on port ${WEBSERVERPORT} on the host side so we spruce it up 

		{

			echo "# WEBSERVER PAGE on host port"
			echo "Listen ${YAKKOHOSTIP}:${WEBSERVERPORT}"
			echo "<VirtualHost ${YAKKOHOSTIP}:${WEBSERVERPORT}>"
			echo "	DocumentRoot ${IMAGEREPO}"
	    		echo "	<Directory ${IMAGEREPO}>"
	       		echo "		Options Indexes FollowSymLinks"
	       		echo "		Require all granted"
	       		echo "		AllowOverride None"
	    		echo "	</Directory>"
			echo "</VirtualHost>"
	
		} >> ${HTTPDCONFIGFILE}

		systemctl restart httpd > /dev/null 2>&1
		if [ $? -ne 0 ]
		then
			# OK, that didn't work for some reasong, so we revert, no biggie
			sed -i "/WEBSERVER PAGE/,$ d" ${HTTPDCONFIGFILE}
			systemctl restart httpd > /dev/null 2>&1
			HTMLREPORTHOST=${CLUSTERPROXY}
		else
			HTMLREPORTHOST=${YAKKOHOSTIP}
		fi
	fi

	cat <<HTMLCONTENT > $IMAGEREPO/index.html

<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<LINK REL="stylesheet" HREF="https://fonts.googleapis.com/css?family=Saira+Condensed">
<STYLE>
                H2 {
                        font-family: 'Saira Condensed', sans-serif;
                                font-size: 34px;
                }
                P {
                        font-family: 'Saira Condensed', sans-serif;
                        font-size: 24px;
                }
</STYLE>
</HEAD>

<BODY>

<A HREF=https://ozchamo.github.io/YAKKO/> <IMG SRC="https://ozchamo.github.io/YAKKO/yakkologo.png" height=400 ALIGN="Left" style="margin-right: 30;"> </A>
<BR>
<H2>OpenShift Cluster [$CLUSTERNAME] is available on this server:</H2>

<P>
<B>Console URL:</B> &nbsp;<A HREF="${CLUSTERWEBURL}" TARGET="_blank">${CLUSTERWEBURL}</A>
<BR>
<B>API server:</B> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${CLUSTERAPIURL}</P>

<P>Administrator: kubeadmin
<BR>
Password: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(cat ${CLUSTERSETUPDIR}/auth/kubeadmin-password)<BR>
<BR>
(Version: ${OCPINSTALLVERSION} &nbsp;&nbsp;Build date: $(echo ${CLUSTERCOMPLETE} | awk '{print $4}'))
</P>
</BODY>
</HTML>

HTMLCONTENT

}


check-cluster-state() {
	# Call: check-cluster-state <0|1> ["api"]
	# if $1 ==  0 don't print state
	# if $1 ==  1 print state AND EXIT
	# if $2 == power just check for the power status of the cluster
	# if $2 is the string "api" then we don't bail if the API server is up as some calls 
	# are looking for this to function, for example if I need a worker node for some
	# operators to come up.
	# Valid calls are:
	# check-cluster-state 1
	# check-cluster-state 0
	# check-cluster-state 0 api

	# Return values are
	# 0 -> All good
	# 1 -> API not good
	# 2 -> Web Console not good
	# 3 -> API and Web Console not good
	# 4 -> Cluster is shutdown!

	PRINTSTATE=$1
	SPECIALQUERY=$2

	# This is only executed at the end of the process or on subsequent calls

	source ${CLUSTERCONFIGFILE}

	MASTERUPCOUNT=$(virsh list --all | grep "master-" | grep "running" | wc -l)

	if [ "${SPECIALQUERY}" == "power"  ]
	then
		if [ ${MASTERUPCOUNT} -eq 0 ]
		then
			return 4 # Special case - the cluster is SHUTDOWN!
		else
			return 0 # The cluster is powered up
		fi
	fi

	# VERSION 1.1 - Check virtual network status
	virsh net-list --all | grep ${NETWORKNAME} | grep " active" >/dev/null 2>&1
	if [ $? -ne 0 ]
	then
		echo -e $(tput blink)" ALERT: The virtual network (${NETWORKNAME}) does not appear to be operational. Check status with 'virsh net-list --all'" $(tput sgr0)
		echo
		cleanup-and-exit
	fi

	# VERSION 1.1 - Check HAproxy status
	systemctl status haproxy >/dev/null 2>&1
	if [ $? -ne 0 ]
	then
		echo -e $(tput blink)" ALERT: HAproxy seems to be off-line. Check status with 'systemctl status haproxy'" $(tput sgr0)
		echo
		cleanup-and-exit
	fi

	# If the web console is available, offer info for it regardless of the output above
	RESULTCONSOLE=1
	wget -O $OCPWGETTMP ${CLUSTERWEBURL} --no-check-certificate > /dev/null 2>&1
	RESULTCONSOLE=$?

	RESULTSERVER=1
	wget -O $OCPWGETTMP ${CLUSTERAPIURL} > /dev/null 2>&1
	RESULTSERVER=$?
	[ $RESULTSERVER -eq 5 ] && RESULTSERVER=0 # SSL errors doesn't mean it's not up

	[ $RESULTCONSOLE -eq 0 -a $RESULTSERVER -eq 0 ] && OCPACCESSSTATUS=0 # All good
	[ $RESULTCONSOLE -eq 0 -a $RESULTSERVER -ne 0 ] && OCPACCESSSTATUS=1 # API not good
	[ $RESULTCONSOLE -ne 0 -a $RESULTSERVER -eq 0 ] && OCPACCESSSTATUS=2 # Web Console not good
	[ $RESULTCONSOLE -ne 0 -a $RESULTSERVER -ne 0 ] && OCPACCESSSTATUS=3 # API and Web Console not good
		
	if [ ${PRINTSTATE} -ne 0 ] 
	then 
		# we are asked to print state
		echo " CLUSTER: ${CLUSTERFQDN}  (Ver: $(${OCCOMMAND} get clusterversion | sed -e "1 d" | awk '{print $2}')  Built: $(echo ${CLUSTERCOMPLETE} | awk '{print $4}'))"   
		echo

		if [ $OCPACCESSSTATUS -eq 3 ]
		then 
			if [ ${MASTERUPCOUNT} -eq 0 ]
			then
				echo "All nodes of the cluster are currently powered off."
			else
				echo "ERROR: The cluster does not appear to be accessible or there is no console active yet."
				echo
				echo "You can check the status of the masters by issuing, for example: "
				echo "ssh -i $OCPSSHKEY core@master-0.${CLUSTERFQDN}  journalctl -b -f -u crio.service"
				echo
				echo "or simply: ${YAKKONAME} infra sshtonode master-0"
			fi	
			echo
		else
			ACTIVEMASTERS=$(${OCCOMMAND} get nodes | grep "master-" | grep " Ready" | wc -l)
			TOTALMASTERS=$(${OCCOMMAND} get nodes | grep "master-" | wc -l)

			ACTIVENODES=$(${OCCOMMAND} get nodes | grep "node-" | grep " Ready" | wc -l)
			TOTALNODES=$(${OCCOMMAND} get nodes | grep "node-" | wc -l)

			ACTIVEOPERATORS=$(${OCCOMMAND} get co | grep -v AVAILABLE | awk '{print $3}' | grep True | wc -l)
			TOTALOPERATORS=$(${OCCOMMAND} get co | grep -v AVAILABLE | wc -l)

			echo " Active Masters:   ${ACTIVEMASTERS}/${TOTALMASTERS}"
			echo " Active Nodes:     ${TOTALNODES}/${TOTALNODES} (workers/infra)"
			echo " Active Operators: ${ACTIVEOPERATORS}/${TOTALOPERATORS}"

			echo
			echo "              state      "
			if [ $OCPACCESSSTATUS -eq 0 ] 
			then
				#echo "The console and API server appear to be operational:"
				echo " Web Console: [ ✔ ]  ${CLUSTERWEBURL}"
                                echo " API Server:  [ ✔ ]  ${CLUSTERAPIURL}"
			elif [ $OCPACCESSSTATUS -eq 1 ]
			then
				#echo "The console appears to be operational, the API server does not:"
				echo " Web Console: [ ✔ ]  ${CLUSTERWEBURL}"
                                echo " API Server:  [ ✘ ]" 
			elif [ $OCPACCESSSTATUS -eq 2 ]
			then
				#echo "The API server appears to be operational, the console does not:"
				echo " Web Console: [ ✘ ]"
                                echo " API Server:  [ ✔ ]  ${CLUSTERAPIURL}"
			fi
			echo

			# VERSION 1.1 - Check for pending CSRs
			PENDINGCSRS=$(${OCCOMMAND} get csr 2>/dev/null | grep Pending | awk '{ print $1 }')
			if [ ! -z "${PENDINGCSRS}" ]
			then
				set $PENDINGCSRS
				echo -e $(tput blink)" ALERT: There are [$#] Pending Certificate Signing Requests (CSRs) that need approval!" $(tput sgr0)
				echo
			fi

			if [ ! -z "${YAKKOADMIN}" ]
			then
				echo " Administrator: ${YAKKOADMIN}  (Password not available for display)"
			else
				echo " Administrator: kubeadmin"
				echo " Password:      $(cat ${CLUSTERSETUPDIR}/auth/kubeadmin-password)"
			fi
			echo

			# VERSION 1.1 - report cluster access
			check-haproxy-access
			if [ $? -eq 0 ]
			then
				echo " External access: ENABLED (to change: yakko infra changeaccess)"
			else
				echo " External access: DISABLED (to change: yakko infra changeaccess)"
			fi
			echo

			echo " - To use OpenShift's 'oc' command --> source ocp-setup-env  (in this shell)"
			echo " - To make infrastructure changes ---> ${YAKKONAME} infra <options>"
			echo " - To make operational changes ------> ${YAKKONAME} ops <options>"
			echo
		fi

		# AND WE EXIT after printing STATUS of the cluster
		# We exit if we are not still building the cluster ;)
		cleanup-and-exit
	else
		# We are not being asked to print anything
		# We manipulate the return value if we are just being asked about the API server
		if [ ${SPECIALQUERY} == "api" -a ${OCPACCESSSTATUS} == 2 ]
		then
			OCPACCESSSTATUS=0
		fi
	fi

	return ${OCPACCESSSTATUS}
}


build-ocp-node() {

	trap 'echo; ${FUNCNAME[1]} rollback; cleanup-and-exit' SIGINT

	#master example is  build-ocp-node master-X 52:00:84:12:34:56 $MASTERVCPUS $MASTERRAMSIZE $MASTERDISKSIZE master.ign

	NODEHOSTNAME=$1 

	# Check if httpd is up - I've hit this before
	systemctl is-active httpd > /dev/null 2>&1
	[ $? -ne 0 ] && {
		systemctl restart httpd
		check-for-error-and-exit $? "Provisioning HTTPD server seems to be inactive - cannot continue building node"
	}

	if [ "$2" == "auto" ]
	then
		# If $1 is not 'auto' it's because the MAC has been passed - for MASTER nodes only
		# If not, we're creating a new WORKER node, this calls for an auto mac and ip address
		NODEMACADDRESS=${BASEMACADDRESS}:${NETWORKADDRESSSLOT}

		# Update the networking tables for KVM
		# This function adds a dhcp entry in the virtual network table by inserting 
		# it in the DHCP scope XML definition and then restarting the network!
 		# <host mac='${NODEMAC}' name='nodename.${CLUSTERFQDN}' ip='${NODEIP}'/>"

		HOSTDHCPENTRY="<host mac=\"${NODEMACADDRESS}\" name=\"${NODEHOSTNAME}.${CLUSTERFQDN}\" ip=\"${BASENETWORK}.${NETWORKADDRESSSLOT}\"/>"
		sed -i "/<\/dhcp>/i\			${HOSTDHCPENTRY}" ${NETWORKXML}
		echo "${HOSTDHCPENTRY}" > ${DHCPXMLTMPFILE} #It's way too hard to pass this as an argument below!
		restart-virtual-network add-last ip-dhcp-host

		# This was the old way
		#echo "<host mac=\"${NODEMACADDRESS}\" name=\"${NODEHOSTNAME}.${CLUSTERFQDN}\" ip=\"${BASENETWORK}.${NETWORKADDRESSSLOT}\"/>"  > ${DHCPXMLTMPFILE} #It's way too hard to pass this as an argument below!
		#virsh net-update ${NETWORKNAME} add-last ip-dhcp-host "${HOSTDHCPENTRY}" --live --config 
                #check-for-error-and-exit $? "Could not restart the virtual network"

		# Update the HAproxy and restart it
		echo "Updating and restarting HAproxy"
		sed -i "/addingressrouternode80/a\    server ${NODEHOSTNAME} ${BASENETWORK}.${NETWORKADDRESSSLOT}:80 check inter 1s"  ${HAPROXYCONFIGFILE}
		sed -i "/addingressrouternode443/a\    server ${NODEHOSTNAME} ${BASENETWORK}.${NETWORKADDRESSSLOT}:443 check inter 1s" ${HAPROXYCONFIGFILE}
                systemctl restart haproxy
                check-for-error-and-exit $? "Could not start HA Proxy, the cluster cannot function without this."

		# Update the last mac address used in the CLUSTERCONFIGFILE 
		((NETWORKADDRESSSLOT++))
		sed -i "/NETWORKADDRESSSLOT=/c\NETWORKADDRESSSLOT=${NETWORKADDRESSSLOT}" ${CLUSTERCONFIGFILE}
	else
		NODEMACADDRESS=$2
	fi

	NODEVCPUS=$3
	NODERAMSIZE=$4
	NODEDISKSIZE=$5
	IGNITIONFILE=$6

	echo
	print-in-colour lightblue "Building OCP node: ${NODEHOSTNAME}.${CLUSTERFQDN}"
	echo
	echo "Configuration:"
       	echo "- vCPUs:  ${NODEVCPUS}"
	echo "- Memory: ${NODERAMSIZE} MiB"
       	echo "- MAC Addr: ${NODEMACADDRESS}"

	if [ $(echo ${OCPINSTALLVERSION} | cut -c3 ) -gt 5 ]  # We are on OCP 4.6 or higher
	then
		virt-install \
			--memory ${NODERAMSIZE} \
			--vcpus ${NODEVCPUS} \
			--cpu host \
			--disk path=${OCPVMDISKDIR}/${NODEHOSTNAME}.${CLUSTERFQDN}.qcow2,size=${NODEDISKSIZE},bus=virtio,format=qcow2 \
			--install kernel=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-live-kernel-x86_64,initrd=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-live-initramfs.x86_64.img,kernel_args_overwrite=yes,kernel_args="coreos.inst=yes coreos.inst.install_dev=vda coreos.live.rootfs_url=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-live-rootfs.x86_64.img coreos.inst.image_url=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-metal.x86_64.raw.gz coreos.inst.ignition_url=${WEBSERVERURL}/${IGNITIONFILE} coreos.inst.insecure ip=dhcp rd.neednet=1" \
			--os-type=linux \
			--os-variant=rhel8-unknown \
			--graphics vnc \
			--network network=${NETWORKNAME},mac=${NODEMACADDRESS}  \
			--noautoconsole --wait -1 \
			--name ${NODEHOSTNAME}.${CLUSTERFQDN}
		BUILDOCPNODERESULT=$?
	else
      		virt-install \
	                --memory ${NODERAMSIZE} \
	       	         --vcpus ${NODEVCPUS} \
       		         --cpu host \
       		         --disk path=${OCPVMDISKDIR}/${NODEHOSTNAME}.${CLUSTERFQDN}.qcow2,size=${NODEDISKSIZE},bus=virtio,format=qcow2 \
       		         --install kernel=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-installer-kernel-x86_64,initrd=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-installer-initramfs.x86_64.img,kernel_args_overwrite=yes,kernel_args="coreos.inst=yes coreos.inst.install_dev=vda coreos.inst.image_url=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-metal.x86_64.raw.gz coreos.inst.ignition_url=${WEBSERVERURL}/${IGNITIONFILE} ip=dhcp rd.neednet=1" \
       		         --os-type=linux \
       		         --os-variant=rhel8-unknown \
       		         --graphics vnc \
       		         --network network=${NETWORKNAME},mac=${NODEMACADDRESS}  \
       		         --noautoconsole --wait -1 \
       		         --name ${NODEHOSTNAME}.${CLUSTERFQDN}
		BUILDOCPNODERESULT=$?
	fi

	# We clear any old entries in known hosts so that user sees no nasty security business
	sed -i "/${NODEHOSTNAME}.${CLUSTERFQDN}/d" /root/.ssh/known_hosts > /dev/null 2>&1

	echo

	return $BUILDOCPNODERESULT
}


approve-csrs-normal() {

	# $1 is umber of nodes we are waiting for
	# this changes depending on wheter we are building an entire cluster or just adding nodes

	TIMEOUTANDEXIT=$(($1 * ${ADDNODETIMEOUT}))

	# running oc here is a little trickier as this gets forked off, so we test for it before
	[ -x ${OCCOMMAND} ] 
	check-for-error-and-exit $? "Cannot process CSRs as this stage cannot execute command ${OCPINSTALLSOURCE}/oc"

	# This runs in the backgound approving certificates as they come...
	{
		trap "echo 'Certificate Approval (oc get csr) stopped.'; echo;  exit" SIGTERM

		while [ 1 ] 
		do
			${OCCOMMAND} get csr 2>/dev/null | grep Pending | awk '{ print $1 }' | xargs ${OCCOMMAND} adm certificate approve > /dev/null 2>&1

			sleep 10

			# Insurance policy should parent die...
			TIMEOUTANDEXIT=$((${TIMEOUTANDEXIT} - 15))
			[ ${TIMEOUTANDEXIT} -le 0 ] && exit
		done
	} &
	
	# The callers should reference $! to get the PID for the above, so this should be followed by
	# CSRAPPROVALPID=$!
}


yakko-backup() {

	# NOTE: THIS CALL UPDATES THIS FILE WITH sed -i for VERSION
	# Tread carefully

	# A small developer backdoor...
	# Too lazy to push to git all the time
	# $2 creates a message that accompanies the backup... Like commit -m ;)

	shift # get rid of backup parameter

	BACKUPDATE=$(date +%Y%m%d.%H%M)
	BACKUPFILE=${YAKKONAME}.$BACKUPDATE
	BACKUPMSG="$*"

	# This is the first thing that can be called so don't have much info
	cd $(dirname $0)
	
	if [ -r .yakkohome -a -r .yakkobackups ]
	then
		echo
		print-in-colour green "Backing up yakko code"
		echo

		# If there is a message attached, construe this as an updated version!
		if [ ! -z "$BACKUPMSG" ]
		then
			echo "Yakko version is $YAKKOVERSION."
			cp $0 /tmp/yakko.tmp.$BACKUPDATE

			MINORRELEASE="$(echo $YAKKOVERSION | cut -f2 -d.)"
			NEWMINOR=$(expr $MINORRELEASE + 1)
			NEWVERSION="$(echo $YAKKOVERSION | cut -f1 -d.)".$NEWMINOR

			echo
			ask-user "Update NEW RELEASE version to [$NEWVERSION]" Y
			if [ $? -ne 0 ]
			then
				echo -n "Enter version number to stamp to this release [${YAKKOVERSION}]: "
				read RESPONSE
				if [ ! -z ${RESPONSE} ]
				then
					NEWVERSION=${RESPONSE}
				else
					NEWVERSION=${YAKKOVERSION}
				fi
			fi

			if [ "${NEWVERSION}" != ${YAKKOVERSION} ]
			then
				sed -i "s/YAKKOVERSION=${YAKKOVERSION}/YAKKOVERSION=${NEWVERSION}/" $0
				echo "Version: VERSION stamp updated to [${NEWVERSION}]"
			fi

			sed -i "s/YAKKODATE=${YAKKODATE}/YAKKODATE=${BACKUPDATE}/" $0
			echo "Version: DATE stamp updated to [${BACKUPDATE}]"
			echo
		fi

		for YBD in $(cat .yakkobackups)
		do
			if [ ! -d "$YBD" ]
			then
				mkdir /YAKKO-BACKUPS >/dev/null 2>&1
				cp $0 /YAKKO-BACKUPS/${BACKUPFILE}
				echo
				echo "ERROR: [$YBD] cannot be written to for backup."
				echo "NOTE: A backup has been made in root directory (/YAKKO-BACKUPS)"
				echo
				break
			fi
				
			cp $0 $YBD/${BACKUPFILE}
			cp $0 $YBD/${YAKKONAME} # This will always be the latest. ln does not work on VFAT ;)

			if [ ! -z "$BACKUPMSG" ]
			then
				echo $BACKUPMSG > $YBD/${BACKUPFILE}.txt
			fi
	
			echo "Backed up current ${YAKKONAME} as ${YBD}/${BACKUPFILE}"
		done
	else
		echo "Cannot backup because .yakkobackups is not defined"
		echo "Just drop a directory in that filename and yakko will back itself up in there!"
	fi

	echo
	cleanup-and-exit

}


print-option-header() {

	# $1 reads 'infra' or 'ops'
	# Maybe we redecorate on this later but placeholder in place
	if [ "$1" == "infra" ]
	then
		HEADERCATEGORY="INFRA:"
	elif [ "$1" == "ops" ]
	then
		HEADERCATEGORY="OPS:"
	else
		HEADERCATEGORY=""
	fi

	shift

	echo
	print-in-colour lightblue "$HEADERCATEGORY $*"
	echo
}


restart-virtual-network() {

	# call simply with restart params
	# this is an attempt to avoid
	# error: Failed to update network net-yakko-testcluster
	# error: internal error: Failed to apply firewall rules /usr/sbin/iptables -w --table filter 
	# --insert LIBVIRT_INP --in-interface virbrocp --protocol tcp --destination-port 67 --jump ACCEPT: iptables: No chain/target/match by that name.

	echo "Restarting virtual network"

	virsh net-update ${NETWORKNAME} $* ${DHCPXMLTMPFILE} --live --config #> /dev/null 2>&1
	if [ $? -ne 0 ]
	then
		systemctl restart libvirtd
		sleep 2
		virsh net-update ${NETWORKNAME} $* ${DHCPXMLTMPFILE} --live --config #> /dev/null 2>&1
        	check-for-error-and-exit $? "Could not restart the virtual network - with libvirt restart attempted!"
	fi
	rm ${DHCPXMLTMPFILE}
}


check-oc-credentials() {
	# We now make sure that the user can 'oc' into the cluster 
	OCPUSER=$(${OCCOMMAND} whoami 2>/dev/null)
	echo " system:admin kube:admin ${YAKKOADMIN} " | grep  "${OCPUSER}" >/dev/null 2>&1
	check-for-error-and-exit $? "You must be logged in to OpenShift as an administrator to run ${YAKKONAME}"
}


check-if-yakko-running() {

	# If YAKKO is already running, we block this run. Don't want to clobber an install...
	# except for the stray timeouts with addnode...
	MAINYAKKOPID=$BASHPID
	OTHERYAKKOPID=$(THISYAKKOPID=$BASHPID;ps -C yakko | grep -v "PID\|$MAINYAKKOPID\|$THISYAKKOPID" | awk '{ print $1 }')
	if [ ! -z "$OTHERYAKKOPID" ]
	then
		check-for-error-and-exit 1 "It appears that 'yakko' is already running - see PID [$OTHERYAKKOPID]"
	fi

}


yakko-infra-operations() {

	# We're here bacause 'yakko infra' was invoked

	# $1 is an op listed in $YAKKOINFRAOPTIONS
	# YAKKOINFRAOPTIONS is defined at the top with the list of valid ops on an existing cluster	

	OPTION=$1
	shift

	echo "${YAKKOINFRAOPTIONS}" | grep " ${OPTION} " > /dev/null

	if [ $? -ne 0 -o -z "${OPTION}" ]
	then
		# Catchall for any other passed parameted at this point
		echo "USAGE: ${YAKKONAME} infra <OPTION> [parameters]" 
		echo
		echo "OPTION is one of:"
		echo "    - startcluster    ->  Start up an existing cluster"
		echo "    - stopcluster     ->  Shutdown an existing cluster"
		echo "    - addnode         ->  Grow the cluster compute capacity by adding a new compute/infra node"
		echo "    - deletenode      ->  Remove a running node from the cluster"
		echo "    - nodelogs        ->  Display the logs of a particular node"
		echo "    - sshtonode       ->  Provide terminal access to an individual cluster node"
		echo "    - changeaccess    ->  Enable/disable OpenShift access by other clients in your network"
		echo "    - restartservices ->  Restart supporting services for cluster (virt network/HAproxy/libvirtd)"
		echo "    - deletecluster   ->  Delete entire cluster and all infrastructure"
		echo
		cleanup-and-exit
	fi

	if [ ${OPTION} == "startcluster" ]
	then
		#infrastartcluster

		print-option-header infra "Start-up (Start) cluster [${CLUSTERNAME}]"

		# Sometimes, HA Proxy may not be running...
		echo "(Re)starting HA Proxy..."
		echo
		systemctl restart haproxy
		check-for-error-and-exit $? "Could not start HA Proxy, the cluster cannot function without this."
		
		if [ ! -z "$1" ]
		then
			# Surely the user knows what he's doing...
			NODENAME=$1
       	 		echo "Starting up: ${NODENAME}"
       	 		virsh start ${NODENAME}.${CLUSTERFQDN}
		else
			get-node-list all
			for NODENAME in ${NODELIST}
			do
       	 			echo "Starting up: ${NODENAME}"
       	 			virsh start ${NODENAME}
				sleep 1
			done
		fi
		echo "Check:"
		echo "- virsh list --all | grep ${CLUSTERFQDN}  to see if all nodes are running"
		echo "- oc get nodes  to see if all nodes become Ready"
		echo "- oc get clusterversion  to check cluster status"
		echo
	fi

	if [ ${OPTION} == "stopcluster" ]
	then
		#infrastopcluster

		print-option-header infra "Shutdown (stop)  cluster [${CLUSTERNAME}]"

		get-node-list active
		for NODENAME in ${NODELIST}
		do
			echo "Shutting down: ${NODENAME}"
			ssh -i ${OCPSSHKEY} -o "StrictHostKeyChecking no" core@${NODENAME} sudo shutdown -h 1
			echo
		done
		echo "Check  virsh list --all | grep ${CLUSTERFQDN}  to see if all nodes are shutdown"
		echo
	fi

	if [ "${OPTION}" == "addnode" ]
	then
		#infraaddnode
		
		print-option-header infra "Add a new worker node to the cluster"

		# We don't want to have two addnodes running
		check-if-yakko-running
		
		check-cluster-state 0 api
		check-for-error-and-exit $? "Cluster is not fully operational for this operation"

		# We check that we have the right credentials to perform some OC commands
		check-oc-credentials	

		echo "NOTE 1: YAKKO will NOT TEST for capacity to handle this request, proceed with caution"
		echo
		echo "NOTE 2: You can also call addnode with parameters for automatic node addition:"
		echo "        - spec: yakko infra addnode <# workers> <# cpuspernode> <RAM in MiB>"
		echo "        - e.g.: yakko infra addnode 3 2 6000"
		echo

		WORKERNODECOUNT=1
		if [ ! -z "$1" -a ! -z "$2" -a ! -z "$3" ]
		then
			# Automation: 
			AUTOSETUP=1

			# We use alternative variables to perform checks. RAM only for now
			PARAMWORKERNODECOUNT=$1
			PARAMWORKERVCPUS=$2
			PARAMWORKERRAMSIZE=$3

			if [ $PARAMWORKERRAMSIZE -lt $MINWORKERRAMSIZE ]
			then
				echo
				echo "ERROR: RAM size needs to be at least $MINWORKERRAMSIZE"
				echo
				cleanup-and-exit
			fi
			WORKERNODECOUNT=$PARAMWORKERNODECOUNT
			WORKERVCPUS=$PARAMWORKERVCPUS
		else

			# For now we will use the stock configuration, add query for RAM and CPU?
			while [ 1 ]
       	         	do
       	         		echo -n "How many cores should be allocated to this node [${WORKERVCPUS}]: "
				read VALUE
				if [ ! -z "$VALUE" ]
				then
					NUMBERRE='^[0-9]+$'
					if ! [[ $VALUE =~ $NUMBERRE ]] ; then
						echo "Error: Not a number. Try again..."
						continue
					elif [ $VALUE -gt ${MAXNODEVCPUS} ]
					then
						echo "Error: Cannot assign more than ${MAXNODEVCPUS}"
						continue
					elif [ $VALUE -eq 0 ]
					then
						echo "Error: Cannot assign ZERO CPUs"
						continue
					else
						WORKERVCPUS=$VALUE
					fi
				fi
				break
			done
			echo
	
			while [ 1 ]
			do
				echo -n "How much RAM (MiB) should be allocated to this node (min: ${MINWORKERRAMSIZE}) [${WORKERRAMSIZE}]: "
				read VALUE
				if [ ! -z "$VALUE" ]
				then
					NUMBERRE='^[0-9]+$'
					if ! [[ $VALUE =~ $NUMBERRE ]] ; then
						echo "Error: Not a number. Try again..."
						continue
					else
						AVAILRAM=$(free -m | grep Mem:|awk '{ print $7 }')
						echo "Your system has $AVAILRAM MiB RAM currently available"
						if [ $VALUE -lt ${MINWORKERRAMSIZE} -o $VALUE -gt $((2*$AVAILRAM)) ]
						then
							echo "RAM size needs to be between ${MINWORKERRAMSIZE} and ideally no more than available RAM"
							echo
							continue
						else
							WORKERRAMSIZE=$VALUE
						fi
					fi
				fi
				break
			done
		fi

		YAKKOSTAGE=0 # This is to artificially use the process-stage framework
		process-stage-build-ocp-workernodes progress

		# This sets CSRAPPROVALPID for later use below
		approve-csrs-normal ${WORKERNODECOUNT}
		CSRAPPROVALPID=$!

		trap "echo;echo \"Node [${NEWNODENAME}]  has not joined the cluster - deleting...\"; delete-kvm-machine ${NEWNODENAME}; cleanup-and-exit" SIGINT

		echo "Node(s) ready to begin integration into the cluster. This will take a few minutes..."
		echo "This process will timeout in ${ADDNODETIMEOUT} seconds." 
		echo
		echo "To observe node progress you can run, on another terminal:"
		echo "- oc get nodes "
		echo "- ${YAKKONAME} infra nodelogs"
		echo

		# We'll start the timeout in case this fails - using ADDNODETIMEOUT
		# NEWNODELIST was populated during process-stage-build-ocp-workernodes

		CHECKINTERVAL=15
		ADDNODETIMEOUT=$((${ADDNODETIMEOUT} * ${WORKERNODECOUNT}))

		print-in-colour lightblue  "Waiting up to $(($ADDNODETIMEOUT /60)) minutes to complete the node addition(s)"
		echo

		while [ ! -z "${NEWNODELIST}" ]
		do 
			for EACHNODE in ${NEWNODELIST}
			do
				${OCCOMMAND} get node ${EACHNODE} 2>/dev/null  | grep -v NAME | grep -v "NotReady" | grep Ready  >/dev/null 2>&1
				if [ $? -eq 0 ]
				then 
					echo "Node (${EACHNODE}) has been added to the cluster and is in READY state "
					echo
					NEWNODELIST=$(echo ${NEWNODELIST} | sed -e "s/\ *${EACHNODE}//")
				fi
				sleep ${CHECKINTERVAL}

				# We will timedown the success of this stage - hit 0 and bail out
				ADDNODETIMEOUT=$((${ADDNODETIMEOUT} - ${CHECKINTERVAL}))

				if [ ${ADDNODETIMEOUT} -le 0 ]
				then
					# process-stage-build-ocp-workernodes uses NEWNODELIST to know what to roll-back
					print-in-colour red  "ERROR: timed out trying to complete node addition to cluster [${CLUSTERNAME}]"
					process-stage-build-ocp-workernodes rollback
					NEWNODELIST=""
					echo
				fi
			done
		done 

		echo "Stopping background certificate approval..."
		kill -s SIGTERM $CSRAPPROVALPID
		sleep 1 ${CHECKINTERVAL} # we wait a cycle for the sleep to let go + 1 second

		if [ ${ADDNODETIMEOUT} -le 0 ]
		then
			print-in-colour red "- Check  'oc get node'  to understand your current cluster configuration"
			print-in-colour red "- Have you assigned enough RAM to the nodes? You requested ${WORKERRAMSIZE} MiB"
			print-in-colour red "- If your system is slow, perhaps you may want to increase ADDNODETIMEOUT in yakko" 
		else
			print-time-elapsed
		fi
		echo
	fi

	if [ "${OPTION}" == "deletenode" ]
	then
		#infradeletenode
		
		print-option-header infra "Delete an existing worker node from the cluster"

		check-cluster-state 0 api
		check-for-error-and-exit $? "Cluster is not fully operational for this operation"

		# We check that we have the right credentials to perform some OC commands
		check-oc-credentials	

		echo "Deleting a node may cause unintended consequences and prevent some workloads from"
		echo "restarting, depending on their dependencies and the resources left in the cluster"
		echo "Use at your own risk!"
		echo

		if [ ! -z "$1" ]
		then
			# Here's hoping the user knows what he's doing
			NODENAME=$1

			echo "Deleting node [${NODENAME}]"
			echo

			${OCCOMMAND} get nodes | awk '{print $1}' | grep "^${NODENAME}$"
                        [ $? -ne 0 ] && {
				echo
                        	echo "Invalid node name [${NODENAME}]. Exiting..."
				echo
				cleanup-and-exit
			}
		else

			CURRENTNODES=$(${OCCOMMAND} get nodes | awk '{print $1}' | grep "^node-")
		
			if [ -z "${CURRENTNODES}" ]
			then
				echo "There are no worker/infra nodes defined, nothing to delete!"
				echo
				cleanup-and-exit
			fi

			if [ -z "${CURRENTNODES}" ]
			then
				echo "There are no nodes available for deletion!"
				echo
				exit
			fi

			while [ 1 ]
			do
				echo "The following nodes are available for deletion: "
				for EACHNODE in ${CURRENTNODES}
				do
					echo ${EACHNODE}
				done
				echo
	
				echo -n "Enter the name of the node you want to delete from the cluster: "
				read NODENAME
	
				${OCCOMMAND} get nodes | awk '{print $1}' | grep "^${NODENAME}$"
				[ $? -eq 0 ] && break
	
				echo "Invalid node name."
			done
		fi

		# Drain the node...
		${OCCOMMAND} adm drain ${NODENAME} --force=true --ignore-daemonsets
		${OCCOMMAND} delete node ${NODENAME}

		# Delete the VM
		delete-kvm-machine ${NODENAME}

		# Update the virtual network
		echo "Restarting virtual network"

		cat ${NETWORKXML} | grep ${NODENAME} > ${DHCPXMLTMPFILE} #It's way too hard to pass this as an argument below!
		sed -i "/${NODENAME}/d" ${NETWORKXML}
		restart-virtual-network delete ip-dhcp-host # this knows of ${DHCPXMLTMPFILE}

		#and we update the haproxy
		echo
		echo "Updating and restarting HAproxy"
		sed -i "/${NODENAME}/ d" ${HAPROXYCONFIGFILE}
                systemctl restart haproxy
                check-for-error-and-exit $? "Could not start HA Proxy, the cluster cannot function without this."
		echo
	fi

	if [ "${OPTION}" == "nodelogs" ]
	then
		#infranodelogs

		print-option-header infra "Display logs for a cluster node"

		if [ ! -z "$1" ]
		then
			# Surely the user knows what he's doing...
			NODENAME=$(get-node-fqdn $1)
			check-node-name $NODENAME exit
		else
			pick-a-node "Select the node name whose logs you want to follow"
		fi

		echo
		echo "Displaying logs for node ["${NODENAME}"] - (CTRL-C to disconnect when done)"
		echo
		ssh -i ${OCPSSHKEY} core@${NODENAME}  journalctl -b -f -u crio.service
	fi

	if [ "${OPTION}" == "sshtonode" ]
	then
		#infrasshtonode

		print-option-header infra "SSH into a cluster node"

		if [ ! -z "$1" ]
		then
			# Surely the user knows what he's doing...
			NODENAME=$(get-node-fqdn $1)
			check-node-name $NODENAME exit
		else
			pick-a-node "Select the node you want to ssh into"
		fi
		echo
		echo "Establishing SSH session to node ["${NODENAME}"] - (CTRL-D to disconnect when done)"
		echo
		ssh -i ${OCPSSHKEY} -o "StrictHostKeyChecking no" core@${NODENAME}
	fi


	if [ "${OPTION}" == "changeaccess" ]
	then
		#infrachangeaccess

		print-option-header infra "Change external access to cluster with FQDN [${FQDNCLUSTERNAME}]"

		check-haproxy-access
		if [ $? -eq 0 ]
		then
			PROXYACCESSSTATUS=ENABLED
			PROXYCHANGESTATUS=DISABLED
		else
			PROXYACCESSSTATUS=DISABLED
			PROXYCHANGESTATUS=ENABLED
		fi			

		echo -n "ACCESS STATUS: "
		if [ ${PROXYACCESSSTATUS} == "ENABLED"  ]
		then
			print-in-colour green "External access is ENABLED"
		else
			print-in-colour orange "External access is DISABLED" 

			echo
			echo "Enabling \"${OPTION}\" will permit access to your cluster from external clients in "
		        echo "your network. Disabling restricts access to ONLY the server running the cluster."
			echo "Open access is achieved by changing the haproxy configuration in ${HAPROXYCONFIGFILE} "
			echo "and by enabling wildcard DNS in your network configuration to provide access to all "
			echo "sub-domains created by OpenShift/Kubernetes for projects/namespaces."
			echo 
			echo "HOW \"${OPTION}\" WORKS ON YOUR LAN:"
			echo
			echo "   - After installation, YAKKO permits access to OpenShift to all clients in your network."
			echo "     This is achieved by allowing HAproxy to listen on all networks, via ports 80/443/6443/22623."
			echo
			echo "   - For other clients to know of your server, you need to extend a DNS wildcard:"
			echo
			echo "     1) You can use a DNS wildcard lookup facility served from this host *if needed*."
			echo "        For home/lab purposes, DNSMASQ is a great tool with this capability. "
			echo "        YAKKO can deploy a DNS workaround on this server. OR..."
			echo 
			echo "     2) If you choose to use your own DNS facility, you need to add a wildcard pointing"
			echo "        to this host's OCP entrypoint. If you already use DNSmasq, just add this line "
			echo "        to your DNSmasq configuration (be sure to replace the IP address if not correct):"
			echo
			echo "             address=/${CLUSTERFQDN}/${YAKKOHOSTIP}"
			echo
		fi
		echo

		ANSWER="N"
		if [ "$1" == "" ]
		then
			ask-user "Set OpenShift Cluster external access to [${PROXYCHANGESTATUS}]"  "Y" noauto
			ANSWER=$?
		else
			ANSWER=$1
		fi

		if [ "$ANSWER" == "1" -o "$ANSWER" == "n" -o "$ANSWER" == "N" ] 
		then
			echo
			echo "No changes were made. You can only access OpenShift from this server."
			echo
			cleanup-and-exit
		fi

		echo
		echo "Changing port access at ${HAPROXYCONFIGFILE}"

		PORTLIST="80 443 6443 22623"
		if [ ${PROXYCHANGESTATUS} == "ENABLED" ]
		then
			# We are going from disabled to enabled
			for PORT in $PORTLIST
			do 
				echo "Enabling access for port $PORT"
				sed -i "/    bind ${CLUSTERPROXY}:${PORT}$/c\    bind :${PORT}" ${HAPROXYCONFIGFILE}
				sleep 1
			done

			echo
			echo "Changing \"/address\"  entries in ${DNSMASQCONFIGFILE}"
			#and we change the NetworkManager DNSmasq entry
			sed -i "/address=\/api.${CLUSTERFQDN}/c\address=\/api.${CLUSTERFQDN}\/${YAKKOHOSTIP}" ${DNSMASQCONFIGFILE}
			sed -i "/address=\/apps.${CLUSTERFQDN}/c\address=\/apps.${CLUSTERFQDN}\/${YAKKOHOSTIP}" ${DNSMASQCONFIGFILE}
		else
			# We are going from enabled to disabled 
			for PORT in $PORTLIST
			do 
				echo "Disabling access for port $PORT"
				sed -i "/    bind :${PORT}$/c\    bind ${CLUSTERPROXY}:${PORT}" ${HAPROXYCONFIGFILE}
				sleep 1
			done
			echo
			echo "Changing \"/address\"  entries in ${DNSMASQCONFIGFILE}"
			sed -i "/address=\/api.${CLUSTERFQDN}/c\address=\/api.${CLUSTERFQDN}\/${CLUSTERPROXY}" ${DNSMASQCONFIGFILE}
			sed -i "/address=\/apps.${CLUSTERFQDN}/c\address=\/apps.${CLUSTERFQDN}\/${CLUSTERPROXY}" ${DNSMASQCONFIGFILE}
		fi

		echo
		echo "Restarting HAproxy and NetworkManager (with DNSmasq plugin)"

		systemctl restart haproxy
		check-for-error-and-exit $? "Could not restart HA Proxy, the cluster cannot function without this - please check!"
		systemctl restart NetworkManager
		check-for-error-and-exit $? "Could not restart NetworkManager, the cluster cannot function without this - please check!"
		echo
		if [ ${PROXYCHANGESTATUS} == "ENABLED" ]
		then
			print-in-colour green "External access is now ENABLED"
		else
			print-in-colour orange "External access is now DISABLED"
		fi
		echo

	fi


	if [ ${OPTION} == "restartservices" ]
	then

		print-option-header infra "Restart Services: Virtual Network/HAproxy/libvirtd"

		#infrarestartservices
		echo "Restarting services can be useful when you are having issues that cascade from"
		echo "manually manipulating virtual networking, HAproxy and libvirtd services. "
		echo "These components can also become 'stale' when making changes in SElinux and "
		echo "firewalld. 'restartservices' refreshes these components in the best order"
		echo "to suit a coordinated refresh."
		echo

		ask-user "Restart all supporting services" Y
		if [ $? -eq 1 ]
		then
			echo
			echo "Restart services aborted."
			echo
			cleanup-and-exit
		fi

		echo "Stopping virtual Network..."
		virsh net-destroy ${NETWORKNAME}
		sleep 1

		echo "Stopping HAproxy service..."
		systemctl stop haproxy
		echo
		sleep 1

		echo "Restarting libvirtd service..."
		systemctl restart libvirtd
		echo
		sleep 1

		echo "Starting virtual Network..."
		virsh net-start ${NETWORKNAME}
		check-for-error-and-exit $? "Could not start virtual network ${NETWORKNAME}"
		sleep 1

		echo "Restarting libvirtd service after virtual network restart"
		systemctl restart libvirtd
		echo
		sleep 1


		echo "Starting HAproxy service..."
		systemctl start haproxy
		check-for-error-and-exit $? "Could not start HAproxy service"
		echo
		sleep 1
	fi

	if [ ${OPTION} == "deletecluster" ]
	then

		#infradeletecluster

		# Danger Will Robinson!
		echo
		print-in-colour red "ALERT: DELETE CLUSTER REQUEST"
		echo

		if  [ "$1" == "force" ]
		then
			# Someone's feeling lucky
			print-in-colour red "FORCE REQUESTED - NO QUESTIONS ASKED!"
			DELETECLUSTERMODE=0
			DELETECLUSTERFORCE=0
			DELETECLUSTERNAME=${CLUSTERNAME}
			yakko-process-stages rollback
		fi

		if  [ "$1" == "${CLUSTERNAME}" ]
		then
			echo "You have requested to DELETE the current cluster: [${CLUSTERNAME}]"
			echo
			echo -n "Please confirm by entering the cluster name again: "
			read DELETECLUSTERNAME
			if [ ${DELETECLUSTERNAME} == ${CLUSTERNAME} ]
			then
				# We signal that this is happening in case it's needed to know in rollbacks
				DELETECLUSTERMODE=0
				DELETECLUSTERFORCE=1
				yakko-process-stages rollback
			else
				echo
				echo "ERROR: incorrect cluster name, delete not confirmed."
			fi
		else
			echo "ALERT: To delete cluster [${CLUSTERNAME}] and all associated ${YAKKONAME} configuration, you also need to pass the clustername" 
			echo "RUN:   $0 infra deletecluster ${CLUSTERNAME}"
			echo
		fi
	fi

	cleanup-and-exit

}


yakko-ops-operations() {

	# This is just nice stuff to have after the install is done
	# we're here because the user called "yakko ops"

	OPTION=$1
	shift 

	echo "${YAKKOCLUSTEROPTIONS}" | grep " ${OPTION} " > /dev/null
	if [ -z "${OPTION}" -o $? -ne 0 ]
	then
		# Catchall for any other passed parameted at this point
		echo "USAGE: ${YAKKONAME} ops <OPTION> [parameters]" 
		echo
		echo "OPTION is one of:"
		echo "    - htpasswd      ->  Deploy local password access and a new administrator"
		echo "    - useradd       ->  Add a new user to local htpasswd DB"
		echo "    - userdelete    ->  Delete an existing user from the local htpasswd DB"
		echo "    - mastersched   ->  Enable/disable master scheduling"
		echo "    - nodelabel     ->  Change the label of a node between worker <-> infra"
		echo "    - localregistry ->  Enable a local registry so you can actually use the cluster"
		echo "    - ingresscert   ->  Install an existing wildcard certificate"
		echo "    - approvecsrs   ->  Approve any outstanding CSRs (Certificate Signing Requests)"
		echo "    - yakkotest     ->  Deploy the 'yakkotest' app on your cluster, to test the lot!!"
		echo
		cleanup-and-exit
	fi


	if [ ${OPTION} == "htpasswd" ]
	then
		#opshtpasswd

		print-option-header ops "Enable ADMIN and local passwords"

		# We check that you can still go on after cred check
		check-oc-credentials

		# Need htpasswd from httpd-tools
		install-package-if-missing httpd-tools 

		if [ -z "${YAKKOHTPASSWD}" ]
		then
			if [ -z "$1" ]
			then
				NEWUSER=administrator
				echo "You must enter a new administrator who will be granted cluster-admin role."
				echo -n "Enter a new admin username to add to the HTPasswd provider [administrator]: "
				read NEWUSER
			        [ -z "${NEWUSER}" ] && NEWUSER="administrator"	
			else
				NEWUSER="$1"
			fi

			if [ -z "$2" ]
			then
				echo
				echo -n "Enter password for user [$NEWUSER]: "
				read -s NEWPASSWORD
				echo
				echo -n "Retype password for confirmation: "
				read -s CONFIRMPASSWORD
				echo
				if [ "$NEWPASSWORD" != "$CONFIRMPASSWORD" ]
				then
					echo "Passwords didn't match! Exiting..."
					echo
					cleanup-and-exit
				fi
			else
				NEWPASSWORD="$2"
			fi

			{
				echo "apiVersion: config.openshift.io/v1"
				echo "kind: OAuth"
				echo "metadata:"
				echo "  name: cluster"
				echo "spec:"
				echo "  identityProviders:"
				echo "  - name: Local Password"
				echo "    mappingMethod: claim"
				echo "    type: HTPasswd"
				echo "    htpasswd:"
				echo "      fileData:"
				echo "        name: htpass-secret"
			} > /tmp/oauth-config.yaml

			${OCCOMMAND} apply -f /tmp/oauth-config.yaml
			check-for-error-and-exit $? 'Could not apply OAuth Custom Resource for HTaccess (see /tmp/oauth-config.yaml)' 

			htpasswd -c -B -b ${HTPASSWDFILE} $NEWUSER $NEWPASSWORD
			${OCCOMMAND} create secret generic htpass-secret --from-file=htpasswd=${HTPASSWDFILE} -n openshift-config
			echo "YAKKOHTPASSWD=1" >> ${CLUSTERCONFIGFILE}
			sleep 3

			${OCCOMMAND} adm policy add-cluster-role-to-user cluster-admin $NEWUSER
			check-for-error-and-exit $? "Could not enable $NEWUSER as a user." 
			echo
			echo "Added [$NEWUSER] admin user with cluster-admin role successfuly"
			echo
			YAKKOADMIN=${NEWUSER}
			echo "YAKKOADMIN=${NEWUSER}" >> ${CLUSTERCONFIGFILE}

			if [ -z "$3" ]
			then
				ask-user "Disable 'kubeadmin' account" Y 
				ANSWER=$?
			else
				ANSWER=$3
			fi

			if [ "$ANSWER" == "0" -o "$ANSWER" == "Y" -o "$ANSWER" == "y" ]
			then
				echo "Deleting secret for 'kubeadmin' account" 
				${OCCOMMAND} --user=admin delete secret kubeadmin -n kube-system
				[ $? -eq 0 ] && echo "KUBEADMIN=''" >> ${CLUSTERCONFIGFILE}
				echo "Note that the system:admin account is still available"

				# and ... the webpage
				sed -i "s/kubeadmin/${YAKKOADMIN}/" $IMAGEREPO/index.html
				sed -i "/Password:/d" $IMAGEREPO/index.html
				echo

			fi
	
		else
			echo "Local passwords have already been enabled."
			echo
		fi
	fi

	if [ ${OPTION} == "useradd" ]
	then
		#opsuseradd

		print-option-header ops "Add a local htpasswd user"

		# We check that you can still go on after cred check
		check-oc-credentials

		[ "${YAKKOHTPASSWD}" -eq 1 ] 
		check-for-error-and-exit $? "You need to first configure Local Passwords via \"YAKKONAME enable htpasswd\"" 

		if [ -z "$1" ]
		then
			echo -n "Enter the name for a new user to add to the HTPasswd provider: "
			read NEWUSER
		else
			NEWUSER="$1"
		fi
		
		if [ -z "$2" ]
		then
			echo -n "Enter password for user [$NEWUSER]: "
			read -s NEWPASSWORD
			echo
			echo -n "Retype password for confirmation: "
			read -s CONFIRMPASSWORD
			echo
			if [ "$NEWPASSWORD" != "$CONFIRMPASSWORD" ]
			then
				echo "Passwords didn't match! Exiting..."
				echo
				cleanup-and-exit
			fi
		else
			NEWPASSWORD=$2
		fi

		${OCCOMMAND} get secret htpass-secret -n openshift-config -o jsonpath={.data.htpasswd} | base64 -d > ${HTPASSWDFILE}
		htpasswd -Bb ${HTPASSWDFILE} ${NEWUSER} "${NEWPASSWORD}"
		${OCCOMMAND} patch secret htpass-secret -n openshift-config -p "{\"data\":{\"htpasswd\":\"$(base64 -w0 ${HTPASSWDFILE})\"}}"
		check-for-error-and-exit $? "Could not retrieve existing htpasswd file from the cluster" 

		${OCCOMMAND} adm policy add-cluster-role-to-user self-provisioner $NEWUSER
		check-for-error-and-exit $? "Could not assign self-provisioner role to $NEWUSER" 

		rm ${HTPASSWDFILE} >/dev/null 2>&1

		echo
		echo "Success: added user $1 and assigned self-provisioner role."
		echo "It may take a few moments before you can login."
		echo
	fi

	if [ "${OPTION}" == "userdelete" ]
	then
		#opsuserdelete

		print-option-header ops "Delete a local htpasswd user"

		# We check that you can still go on after cred check
		check-oc-credentials

		[ "${YAKKOHTPASSWD}" -eq 1 ]
                check-for-error-and-exit $? "There is no local HTPasswd configured, cannot delete anyone yet!"

                ! [ -z "$1" ]
                check-for-error-and-exit $? "You need to pass a USERNAME for the username to delete - yakko ops userdelete <username>"

		DELUSER=$1
		${OCCOMMAND} get secret htpass-secret -n openshift-config -o jsonpath={.data.htpasswd} | base64 -d > ${HTPASSWDFILE}

		cat ${HTPASSWDFILE} | grep $DELUSER > /dev/null
		if [ $? -eq 0 ]
		then
			htpasswd -D ${HTPASSWDFILE} $DELUSER
			${OCCOMMAND} patch secret htpass-secret -n openshift-config -p "{\"data\":{\"htpasswd\":\"$(base64 -w0 ${HTPASSWDFILE})\"}}"
			check-for-error-and-exit $? "Could not update password file in OCP, user not deleted"
		else
			echo "User [$DELUSER] not found in OCP, could not delete."	
		fi
		echo
	fi
		
	if [ "${OPTION}" == "localregistry" ]
	then
		#opslocalregistry

		print-option-header ops "Enable local registry"

		# We check that you can still go on after cred check
		check-oc-credentials

		ANSWER=N
		if [ "$1" == "" ]
		then
			ask-user "Enable local registry (images will be lost on registry restart)" "Y" noauto
			ANSWER=$?
		else
			ANSWER=$1
		fi

		if [ "$ANSWER" == 0 -o "$ANSWER" == "Y" -o "$ANSWER" == "y" ]
		then
			${OCCOMMAND} patch configs.imageregistry.operator.openshift.io cluster --type merge --patch '{"spec":{"storage":{"emptyDir":{}}}}'
			${OCCOMMAND} patch configs.imageregistry.operator.openshift.io cluster --type merge --patch '{"spec":{"managementState":"Managed"}}'
			echo

			LOCALREGISTRY=1
			echo "LOCALREGISTRY=1" >> ${CLUSTERCONFIGFILE}
		else
			echo "Local registry not enabled."
			echo
		fi
		
	fi

	if [ "${OPTION}" == "mastersched" ]
	then
		#opsmastersched

		print-option-header ops "Change MASTER node(s) scheduling state"

		# We check that you can still go on after cred check
		check-oc-credentials

		check-cluster-state 0 api

		echo "This is an important change that may affect the behaviour of your workloads"
		echo "and is simply being provided by YAKKO as a mechanism to change new nodes quickly."
		echo "Use at your own risk!"
		echo

		${OCCOMMAND} get nodes | grep master-0 | grep worker > /dev/null 2>&1
		if [ $? -eq 0 ] #Masters are schedulable because they read 'worker'
		then
			MASTERSCHEDSTATE=true
			echo -n "Masters are currently "
			print-in-colour green "SCHEDULABLE"
			echo
			if [ $(${OCCOMMAND} get nodes | grep "node-" | grep -v NotReady | grep Ready | wc -l) -eq 0 ] 
			then
				echo 
				echo "ATTENTION: There are no worker nodes available! Proceed with caution."
				echo
			fi
			ask-user "Change masters to [NOT SCHEDULABLE]" Y noauto
			[ $? -eq 0 ] && NEWMASTERSCHEDSTATE=false
		else
			MASTERSCHEDSTATE=false
			echo -n "Masters are currently " 
			print-in-colour orange "NOT SCHEDULABLE"
			echo
			ask-user "Change masters to [SCHEDULABLE]" Y noauto
			[ $? -eq 0 ] && NEWMASTERSCHEDSTATE=true
		fi

		if [ ! -z "${NEWMASTERSCHEDSTATE}" ]
		then
			# Little hack...
			export KUBE_EDITOR="sed -i s+mastersSchedulable:\ ${MASTERSCHEDSTATE}+mastersSchedulable:\ ${NEWMASTERSCHEDSTATE}+"

			${OCCOMMAND} edit schedulers.config.openshift.io cluster
			[ $? -ne 0 ] && echo "This operation was not succssful"
			echo
		fi
	fi

	if [ "${OPTION}" == "nodelabel" ]
	then
		#opsnodelabel
		# This one is for fun, has a cute little hack

		# We check that you can still go on after cred check
		check-oc-credentials

		print-option-header ops "Change node label: WORKER ←→ INFRA"

                check-cluster-state 0 api
                check-for-error-and-exit $? "Cluster is not fully operational for this operation"

                CURRENTNODES=" $(${OCCOMMAND} get nodes | grep "^node-" | awk '{print $1}') "

                if [ -z "${CURRENTNODES}" ]
                then
                        echo "There are no worker/infra nodes defined, nothing to change!"
                        echo
                        cleanup-and-exit
                fi


		if [ -z "$(${OCCOMMAND} get nodes | grep "^node-" | awk '{print $1, $3}')" ]
		then
			echo "There are no nodes available for relabeling!"
			echo
			exit
		fi

		echo "This is an important change that may affeect the behaviour of your workloads"
		echo "and is simply being provided by YAKKO as a mechanism to change new nodes quickly."
		echo "Use at your own risk!"
		echo

                echo "The following nodes are available for relabeling: "
		${OCCOMMAND} get nodes | grep "^node-" | awk '{print $1, $3}'

                while [ 1 ]
                do

                        echo -n "Enter the name of the node you want to relabel: "
                        read NODENAME
			
			echo ${CURRENTNODES} | grep ${NODENAME} > /dev/null 2>&1
			[ $? -ne 0 ] && {
				echo "Invalid node name"
				echo
				continue
			}
		break
		done

		NODELABEL=$(${OCCOMMAND} get nodes | grep ${NODENAME}" "| awk '{print $3}')

		if [ ${NODELABEL} == "worker" ]
		then
			NEWNODELABEL="infra"
		else
			NEWNODELABEL="worker"
		fi
		
		# Little hack...
		export KUBE_EDITOR="sed -i s+node-role.kubernetes.io/${NODELABEL}+node-role.kubernetes.io/${NEWNODELABEL}+"

		echo
		ask-user "Change [${NODENAME}] label from [${NODELABEL}] to [${NEWNODELABEL}]" Y noauto
		if [ $? -eq 0 ]
		then
			${OCCOMMAND} edit node ${NODENAME}
			[ $? -ne 0 ] &&
				echo "This operation was not succssful"
		else
			echo "No changes were made./"
		fi
		echo
	
	fi

	if [ "${OPTION}" == "ingresscert" ]
	then
		#opsingresscert

		# We check that you can still go on after cred check
		check-oc-credentials

		print-option-header ops "Install an ingress wildcard certificate"

		if [ ! -z "$1" ]
		then
			AUTOSETUP=1
			CERTBUNDLEFILE=$1
			CERTBUNDLEPATH=$(dirname $1)

			if [ ! -r ${CERTBUNDLEFILE} ]
			then
				echo "$1 is not a valid certificate bundle - check file and permissions!"
				echo
				cleanup-and-exit
			fi
		else
			echo "To proceed you must:" 
			echo "- own your own domain [${CLUSTERDOMAIN}]!"
			echo "- have admin access to the domain's control panel"
			echo "- provide a wildcard certificate for apps.${CLUSTERFQDN} as a certificate bundle in your filesystem"

			echo
			print-in-colour green "GUIDELINES FOR USING letsencrypt.com AS A CERTIFICATE SOURCE"
			echo
			echo "  1) Obtain a certificate from this server using the free 'letsencrypt.com' service"
			echo "     you will need to install  certbot, e.g.  dnf install certbot"
			echo 
			echo "     For RHEL you may require adding EPEL repos: "
			echo "     dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm"
			echo
			echo "  2) Issue a request like:  certbot -d '*.apps.${CLUSTERFQDN}' --manual --preferred-challenges dns certonly"
			echo
			echo "  3) Follow the instructions above and use the following to test if the DNS challenge is resolving"
			echo "     before certbot checks the challenge!"
			echo "     https://dnschecker.org/#TXT/_acme-challenge.apps.test.pichus.net"
			echo
			echo "  NOTE: Visit for help: https://stephennimmo.com/securing-openshift-ingress-with-lets-encrypt/"
			echo

			ask-user "Are you ready to proceed?" Y auto
			echo

			CERTBUNDLEPATH=/etc/letsencrypt/live/apps.${CLUSTERFQDN}
			CERTBUNDLEFILE=${CERTBUNDLEPATH}/fullchain.pem

			# WE check in advance if the cert is where certbot puts it...
			if [ ! -r ${CERTBUNDLEFILE} ]
			then
				CERTBUNDLEFILE=""
			fi

			while [ 1 ]
			do
				if [ -z "${CERTBUNDLEFILE}" ]
				then
					echo -n "Enter path to certificate bundle: "
				else
					echo -n "Enter path to certificate bundle [$CERTBUNDLEFILE]: "
				fi
				read CERTBUNDLEALTFILE
	
		       		if [ -z "${CERTBUNDLEALTFILE}" -a ! -z ${CERTBUNDLEFILE} ]
				then 
					# The user accepted the default which has been verified already
					break
				fi

		       		if [ ! -z "${CERTBUNDLEALTFILE}" ]
				then
					if [ -r ${CERTBUNDLEALTFILE} ]
					then
						CERTBUNDLEFILE=${CERTBUNDLEALTFILE}
						break
					else
						echo "Invalid certificate bundle."
						echo
						continue
					fi
				fi

			done
		fi

		if [ -r ${CERTBUNDLEPATH}/privkey.pem ]
		then
			echo "Private key [privkey.pem] found at ${CERTBUNDLEPATH} - continuing..."
		else
			echo "Private key [privkey.pem] was expected at ${CERTBUNDLEPATH} but not found there. Exiting!"
			cleanup-and-exit
		fi

		echo

		${OCCOMMAND} create configmap custom-ca --from-file=ca-bundle.cert=${CERTBUNDLEFILE} -n openshift-config
		${OCCOMMAND} patch proxy/cluster --type=merge  --patch='{"spec":{"trustedCA":{"name":"custom-ca"}}}'
		check-for-error-and-exit $? "Unable to apply patched config map in / custom-ca!"

		${OCCOMMAND} create secret tls custom-ca-secret --cert=${CERTBUNDLEFILE} --key=${CERTBUNDLEPATH}/privkey.pem -n openshift-ingress
		${OCCOMMAND} patch ingresscontroller.operator default \
		       	--type=merge -p '{"spec":{"defaultCertificate": {"name": "custom-ca-secret"}}}' -n openshift-ingress-operator
		check-for-error-and-exit $? "Unable to apply patched private key in / custom ca!"

		echo
		echo "NOTE: If the 'network' and/or 'machine-config' operator goes into degraded mode, run 'oc edit proxy.config.openshift.io cluster'  and:"
		echo "      - clear field trustedCA: "
		echo "      - change 'name:' field to \"\" "
		echo "      - save changes"
		echo "      - oc describe co/network should show an error message that describes the issue"
		echo

	fi

	# VERSION 1.1 - Approve outstanding CSRs
	if [ "${OPTION}" == "approvecsrs" ]
	then
		#opsapprovecsrs

		print-option-header ops "Pending Certificate Signing Request (CSR) approval" 

		PENDINGCSRS=$(${OCCOMMAND} get csr 2>/dev/null | grep Pending | awk '{ print $1 }')

		set ${PENDINGCSRS} > /dev/null

		if [ $# -gt 0 ]
		then
			ask-user "There are [$#] CSRs in PENDING state. Approve" Y

			if [ $? -eq 0 ]
			then
				CURRENTCSRNUM=0

				for CSRNAME in ${PENDINGCSRS}
				do
					((CURRENTCSRNUM+=1))
					echo -n "${CURRENTCSRNUM}: "
					${OCCOMMAND} adm certificate approve ${CSRNAME}
				done
			fi
		else
			echo "There are no pending CSRs to approve"
		fi
		echo
	fi

	if [ "${OPTION}" == "yakkotest" ]
	then
		#opsyakkotest

		print-option-header ops "Deploy the YAKKO test application"

		if [ -z "${LOCALREGISTRY}" ]
		then
			echo "Cannot deploy YAKKO test app as there is no registry defined."
			echo 'First, run "yakko ops localregistry"'
			echo
			cleanup-and-exit
		fi

		${OCCOMMAND} new-project yakkotest
		check-for-error-and-exit $? "Could not create project 'yakkotest' in OpenShift"
		${OCCOMMAND} new-app httpd:latest~https://github.com/ozchamo/yakko-test.git --name=yakko
		check-for-error-and-exit $? "could not create new application 'yakko' in OpenShift"
		# Long form: oc new-app --image-stream httpd:latest https://github.com/ozchamo/yakko-test.git --name=yakko
		# Except this does not work because Language Detection is enabled and... it doesn't detect!
		${OCCOMMAND} expose service yakko --hostname=yakkotest.apps.${CLUSTERFQDN}
		check-for-error-and-exit $? "Could not expose route for 'yakkotest.apps.${CLUSTERFQDN}'"

		echo ${SEPARATIONLINE}
		echo
		echo
		echo "OpenShift will begin building the project"
		echo "Inspect progress by issuing 'oc get pods -n yakkotest'"
		echo
		echo "Once yakkotest is up, point your browser to: http://$(${OCCOMMAND} get routes | grep yakkotest | awk '{print $2}')"
		echo
	fi
		
	cleanup-and-exit
}


###### STAGE PROCESSORS FOLLOW ################################################
# progress is move forwarwd, configure, install
# rollback is move back, undo, delete
###############################################################################


process-stage-libvirt() {

	[ $1 == "progress" ] && {
	
		advance-stage-progression "Libvirt package install/start" 
		# This one is mandatory so there is no && return at the end of the call
		# The thing is, if there is no KVM, there is no hope!

		#VIRTUALISATION IS MANDATORY THE FIRST TIME WE RUN THIS
		systemctl status libvirtd --no-pager > /dev/null 2>&1
		[ $? -ne 0 ] && {
			cat /proc/cpuinfo | egrep "vmx|svm" >/dev/null 2>&1
			check-for-error-and-exit $? "Virtualisation extensions are not enabled in this system!"			

			install-package-if-missing libvirt 
			#install-package-if-missing bridge-utils 
			install-package-if-missing virt-install
			install-package-if-missing qemu-kvm
			install-package-if-missing virt-top
		}
		systemctl enable libvirtd --now > /dev/null 2>&1
		systemctl status libvirtd --no-pager > /dev/null 2>&1
		check-for-error-and-exit $? "Failed to enable [libvirtd]" 

		echo "Libvirt is installed and active"

		# and just in case...
		lsmod | grep kvm >/dev/null
		check-for-error-and-exit $?  "KVM kernel modules are not loaded!"
	}

	# Nothing to rollback
	[ $1 == "rollback" ] && {
		rollback-stage-progression "Libvirt will remain installed"
	}
}


process-stage-pullsecret() {

	[ $1 == "progress" ] && {

		advance-stage-progression "Load pull secret" && return

		[ -r ${PULLSECRETFILE} ] && PULLSECRET=$(cat ${PULLSECRETFILE})

		ask-user "Add a new pull secret" N
		WANTPULLSECRET=$?

		# There is no pull secret on file or user wants a new one now
		if [ -z "${PULLSECRET}" -o ${WANTPULLSECRET} -eq 0 ]
		then
			echo "A new pull secret is required."
		        echo "Please copy/paste pull secret from [ https://cloud.redhat.com/openshift/install/metal/user-provisioned ]:"
		        read PULLSECRET
		        echo $PULLSECRET > ${PULLSECRETFILE}
		else
			echo "Using saved pull secret"
		fi
	}

	# Nothing to rollback - we don't want to delete the existing pull secret
	[ $1 == "rollback" ] && {
		rollback-stage-progression "Existing Pull Secret will remain in place"
	}
}


process-stage-sshclient() {

	[ $1 == "progress" ] && {

	        advance-stage-progression "SSH key configuration" && return

		ask-user "Create new SSH key for node access" "Y"  && {
			
			#We clear a potential clash for ssh logins in .known_hosts
			sed -i "/bootstrap.${CLUSTERFQDN}/d" /root/.ssh/known_hosts > /dev/null 2>&1
			ssh-keygen -t rsa -b 4096 -N '' -f ${OCPSSHKEY}
		 	check-for-error-and-exit $?  "Failed to create SSH key"
			eval "$(ssh-agent -s)"
			ssh-add ${OCPSSHKEY}
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting ssh key and removing cluster hosts from ssh known hosts"
		rm -r ${OCPSSHKEY} > /dev/null 2>&1
		rm -r ${OCPSSHKEY}.pub > /dev/null 2>&1

		get-node-list all
		for NODENAME in ${NODELIST}
		do
			sed -i "/${NODENAME}/d" /root/.ssh/known_hosts
		done
	}
}


process-stage-virtualnetwork() {

	[ $1 == "progress" ] && {
	
        	advance-stage-progression "Virtual Network Configuration" && return

		ask-user "Configure Virtual Network" "Y" && {

			NETWORKXML=$CLUSTERSETUPDIR/${NETWORKNAME}.xml
		
			echo Cleaning up network...
			virsh net-destroy ${NETWORKNAME} > /dev/null 2>&1
			virsh net-undefine ${NETWORKNAME} > /dev/null 2>&1
			
			NETWORKTYPE=1 # Query when BRIDGE is supported. Not yet ;)
			echo Only NAT is supported for now
			#if [ $NETWORKTYPE != 1 -a $NETWORKTYPE != 2 ]
			#then
			#	echo -n 'Should this network be 1.NAT or 2.BRIDGE (1 or 2)? '
			#	read NETWORKTYPE
			#fi
		
			if [ $NETWORKTYPE == 1 ] # NAT
			then
				echo "YAKKO will create all infrastructure in the ${BASENETWORK}/24 subnet with preallocated IP addresses:"
				echo Bootstrap: ${BOOTSTRAPIP}	
				echo Masters: ${MASTER0IP} ${MASTER1IP} and ${MASTER2IP}
				echo
		
				{
					echo "<network>" 
					echo "	<name>${NETWORKNAME}</name>"
		
	 				echo "	<forward mode='nat'>"
					echo "		<nat>"
					echo "			<port start='1024' end='65535'/>"
					echo "		</nat>"
					echo "	</forward>"
		
					echo "	<bridge name='virbrocp' stp='on' delay='0'/>"
		
					echo "	<domain name='${CLUSTERFQDN}' localOnly='yes'/>"
					echo "	<dns>"
					echo "		<forwarder domain='apps.${CLUSTERFQDN}' addr='127.0.0.1'/>"
					echo "		<host ip='${CLUSTERPROXY}'>"
					echo "			<hostname>api</hostname>"
					echo "			<hostname>api-int</hostname>"
					echo "		</host>"
					echo "		<host ip='${MASTER0IP}'>"
					echo " 	         	<hostname>etcd-0</hostname>"
					echo " 	         	<hostname>master-0</hostname>"
					echo "		</host>"
					echo "		<host ip='${MASTER1IP}'>"
					echo " 	         	<hostname>etcd-1</hostname>"
					echo " 	         	<hostname>master-1</hostname>"
					echo "		</host>"
					echo "		<host ip='${MASTER2IP}'>"
					echo " 	         	<hostname>etcd-2</hostname>"
					echo " 	         	<hostname>master-2</hostname>"
					echo "		</host>"
		
					# SRV Records are not required from OCP 4.4 onwards... But never mind
		
					echo " 	 	<srv service='etcd-server-ssl' protocol='tcp' domain='${CLUSTERFQDN}' target='etcd-0.${CLUSTERFQDN}' port='2380' priority='0' weight='10'/>"
					echo " 	 	<srv service='etcd-server-ssl' protocol='tcp' domain='${CLUSTERFQDN}' target='etcd-1.${CLUSTERFQDN}' port='2380' priority='0' weight='10'/>"
					echo " 	 	<srv service='etcd-server-ssl' protocol='tcp' domain='${CLUSTERFQDN}' target='etcd-2.${CLUSTERFQDN}' port='2380' priority='0' weight='10'/>"
					echo "	</dns>"
					echo "	<ip address='${CLUSTERPROXY}' netmask='255.255.255.0'>"
	   	 			echo "		<dhcp>"
					echo "			<range start='${BASENETWORK}.5' end='${BASENETWORK}.254'/>"
					echo "			<host mac='${BOOTSTRAPMAC}' name='bootstrap.${CLUSTERFQDN}' ip='${BOOTSTRAPIP}'/>"
					echo " 			<host mac='${MASTER0MAC}' name='master-0.${CLUSTERFQDN}' ip='${MASTER0IP}'/>"
					echo " 			<host mac='${MASTER1MAC}' name='master-1.${CLUSTERFQDN}' ip='${MASTER1IP}'/>"
					echo " 			<host mac='${MASTER2MAC}' name='master-2.${CLUSTERFQDN}' ip='${MASTER2IP}'/>"
					echo "		</dhcp>"
					echo "	</ip>"
					echo "</network>"
		
				} > $NETWORKXML
			fi

			if [ ${NETWORKTYPE} == 2 ] # BRIDGED
			then
				# All virtual machines will have LAN IP Addresses
				echo ONE DAY...
			fi
			
			echo Defining network at $NETWORKXML
			virsh net-define --file $NETWORKXML
			check-for-error-and-exit $? "Error defining virtual network at $NETWORKXML. Check 'virsh net-list --all'"
			
			echo Setting network to start on boot...
			virsh net-autostart ${NETWORKNAME}
			check-for-error-and-exit $? "Could not configure virtual network for auto-start"
		}
		echo "Re/starting network to ensure it is operational..."
		virsh net-destroy ${NETWORKNAME} 2>/dev/null

		# This blows up here sometimes
		systemctl restart libvirtd

		virsh net-start ${NETWORKNAME}
		check-for-error-and-exit $? "Could not start virtual network"
		echo "Virtual network is up"
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting virtual network configuration"
		virsh net-destroy ${NETWORKNAME} > /dev/null 2>&1
		virsh net-undefine ${NETWORKNAME} > /dev/null 2>&1

		# We didn't remove libvirtd but we will give it a kick as this has 
		# caused trouble before with the virtual network
		systemctl restart libvirtd

	}
}


process-stage-dns() {


	[ $1 == "progress" ] && {
	
        	advance-stage-progression "DNS Configuration" && return

		ask-user "Configure DNS for KVM network (dnsmasq/NetworkManager)" "Y" && {

			# Courtesy of Sebastiaan Stoffels - installed from minimal F34 and found this helps
			install-package-if-missing bind-utils

			systemctl status dnsmasq >/dev/null 2>&1
			if [ $? -eq 0 ]
			then
				# DNSMASQ is enabled on this host, we should use this instead of NetworkManager plugin
				# But, this is dangerous, so we have to leave this one to the ADMIN

				echo "YAKKO has detected that you are not using the dnsmasq plugin for NetworkManager"
				echo "and instead you are using standard DNSMASQ."
				echo
				echo "You will need to add these two addresses to your DNSMASQ configuration before continuing"
				echo "upon which ${YAKKONAME} will test the DNS of your system before continuing"
				echo
				# Version 1.2 changed the CLUSTERPROXY references below to YAKKOHOSTIP
				echo "  server=/${CLUSTERFQDN}/${CLUSTERPROXY}"
				echo "	address=/apps.${CLUSTERFQDN}/${YAKKOHOSTIP}"
				echo "	address=/api.${CLUSTERFQDN}/${YAKKOHOSTIP}"
				echo
				ask-user "Confirm that DNSMASQ has been configured and restarted" "Y" noauto
				echo
			else
				echo Configuring dnsmask plugin in NetworkManager and
				echo adding DNSmasq configuration as ${DNSMASQCONFIGFILE}
				# CHANGE TO END USER SYSTEM HERE
				cat /etc/NetworkManager/NetworkManager.conf | grep "\[main\]" > /dev/null 2>&1
				[ $? -ne 0 ] && echo '\[main\]' >> /etc/NetworkManager/NetworkManager.conf
	
				cat /etc/NetworkManager/NetworkManager.conf | grep "dns = dnsmasq" > /dev/null 2>&1
				[ $? -ne 0 ] && sed -i.bak '/\[main\]/ a dns = dnsmasq' /etc/NetworkManager/NetworkManager.conf
	
				# Version 1.2 changed the CLUSTERPROXY references below to YAKKOHOSTIP
				{
                                        # Version 1.2 changed the use of CLUSTERPROXY below
					echo "listen-address=127.0.0.1,${YAKKOHOSTIP}"
					echo "server=/${CLUSTERFQDN}/${CLUSTERPROXY}"
					echo "address=/apps.${CLUSTERFQDN}/${YAKKOHOSTIP}"
                                        echo "address=/api.${CLUSTERFQDN}/${YAKKOHOSTIP}"
				} > ${DNSMASQCONFIGFILE}
		
				systemctl restart NetworkManager
				check-for-error-and-exit $? "Could not restart NetworkManager"

				# Trying to see if we can address the systemd-resolved changes in Fedora 33
				cat /etc/resolv.conf | grep "nameserver 127.0.0.53"
				if [ $? -eq 0 ]
				then	
					# CHANGE TO END USER SYSTEM HERE

					# We need to add after [Resolve]
					# DNS=127.0.0.1
					# Domains=~${CLUSTERDOMAIN}
					#to /etc/systemd/resolved.conf
					echo
					echo "ATTENTION: This system is using systemd-resolved. YAKKO needs to add a DNS stub in /etc/systemd/resolved.conf"

					#sed -i.EXT is used to edit file in place while creating a backup with extension EXT - we use yakko here
					cat /etc/systemd/resolved.conf | grep "Domains=~${CLUSTERDOMAIN}" > /dev/null 2>&1
					[ $? -ne 0 ] && sed -i.${YAKKONAME} "/\[Resolve\]/ a Domains=~${CLUSTERDOMAIN}" /etc/systemd/resolved.conf

					cat /etc/systemd/resolved.conf | grep "DNS=127.0.0.1" > /dev/null 2>&1
					[ $? -ne 0 ] && sed -i.${YAKKONAME} "/\[Resolve\]/ a DNS=127.0.0.1" /etc/systemd/resolved.conf

					sleep 1 # This sometimes takes a bit to revive
					systemctl restart systemd-resolved.service
					sleep 1
					systemctl restart NetworkManager
				fi
			fi

			sleep 2
			# systemctl restart libvirtd
			# sleep 5

			echo
			echo "DNS test - from Virtual Network ${BASENETWORK}.0:"

			host api-int.${CLUSTERFQDN} ${CLUSTERPROXY} | grep "has address"
			check-for-error-and-exit $? "Could not resolve api-int.${CLUSTERFQDN} on ${BASENETWORK}"

			host etcd-0.${CLUSTERFQDN} ${CLUSTERPROXY} | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-0.${CLUSTERFQDN} on ${BASENETWORK}"

			host etcd-1.${CLUSTERFQDN} ${CLUSTERPROXY} | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-1.${CLUSTERFQDN} on ${BASENETWORK}"

			host etcd-2.${CLUSTERFQDN} ${CLUSTERPROXY} | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-2.${CLUSTERFQDN} on ${BASENETWORK}"

			host -t srv _etcd-server-ssl._tcp.${CLUSTERFQDN} ${CLUSTERPROXY}
			check-for-error-and-exit $? "Could not resolve etcd-server-ssl.${CLUSTERFQDN} on ${BASENETWORK}"
				
			echo
			echo "DNS test - from the host:"

			# Note - before Fedora 33 these tests were run with 127.0.0.1
			# Then came systemd.resolved.conf and things needed to be "updated"
			# So now, we need to add to /etc/systemd/resolvd.conf the following
			#	DNS=127.0.0.1
			#	Domains=~${CLUSTERDOMAIN}
			# and... still trying to fix it
 
			host api.${CLUSTERFQDN} 127.0.0.1 | grep "has address"
			check-for-error-and-exit $? "Could not resolve api-int.${CLUSTERFQDN} on 127.0.0.1"

			host etcd-0.${CLUSTERFQDN} 127.0.0.1 | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-0.${CLUSTERFQDN} on 127.0.0.1"

			host etcd-1.${CLUSTERFQDN} 127.0.0.1 | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-1.${CLUSTERFQDN} on 127.0.0.1"

			host etcd-2.${CLUSTERFQDN} 127.0.0.1 | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-2.${CLUSTERFQDN} on 127.0.0.1"

			host testing.apps.${CLUSTERFQDN} 127.0.0.1
			check-for-error-and-exit $? "Could not resolve testing.apps on 127.0.0.1"
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting DNS configuration and restarting"
		rm ${DNSMASQCONFIGFILE} > /dev/null 2>&1
		# mv /etc/systemd/resolved.conf.${YAKKONAME} /etc/systemd/resolved.conf >/dev/null 2>&1
		echo "Not rolling back resolved.conf changes. Inspect /etc/systemd/resolved.conf if you want to revert."
	}
}

	
process-stage-haproxy() {

	[ $1 == "progress" ] && {

        	advance-stage-progression "Configure Load Balancer "  && return

		ask-user "Configure Load Balancer (HA Proxy) for cluster bootstrap and operation" "Y" && {

			install-package-if-missing haproxy
	
			cat /etc/httpd/conf/httpd.conf | grep "^Listen 80" >/dev/null 2>&1
			[ $? -eq 0 ] && {
				echo "ATTENTION: HAPROXY needs to run on port 80. Currently, port 80 is marked for listening by httpd."
				ask-user "Disable port 80 on httpd" "Y" noauto
				if [ $? -eq 0 ]
				then		
					# CHANGE TO END USER SYSTEM HERE
					sed -i "/^Listen 80/c\# Listen 80" /etc/httpd/conf/httpd.conf  2>/dev/null
				else
					echo
					echo "ERROR: Cannot continue until PORT 80 is freed up for HAPROXY. Fix and come back! Exiting..."
					echo
					cleanup-and-exit
				fi
			}
	
			#We'll put config files for HAPROXY in here
			mkdir /etc/haproxy/${YAKKONAME} > /dev/null 2>&1

			#HAPROXY still wants to find a config file in the default place
			touch /etc/haproxy/haproxy.cfg

			#but, we can add others, and we do! As a directory, this will make haproxy load any configs in there...
			echo "OPTIONS=\"-f /etc/haproxy/${YAKKONAME}\"" > /etc/sysconfig/haproxy

			# VERSION 1.1 adds opening by default so here we go
			# This value came from QUESTIONS and is later stored in yakkodefaults
			if [ ${HAPROXYACCESS} -eq 0 ]	
			then
				# 0 is yes and yes is open, so no value!
				echo "Setting up HAproxy with OPEN access"
				HAPROXYVALUE=""
			else
				echo "Setting up HAproxy with HOST-ONLY access"
				HAPROXYVALUE=${CLUSTERPROXY}
			fi
			echo "You can change this later with 'yakko infra changeaccess'"

			echo Creating the HA Proxy Config...
			echo
			
			{
				# SET UP THE PROXY ON THE VIRTUAL NETWORK - FOR THE HOST

				echo "listen ${CLUSTERNAME}-api-server-6443"
				echo "    bind ${HAPROXYVALUE}:6443"
				echo "    mode tcp"
				echo "    balance source"
				echo "    server master-0.${CLUSTERFQDN} ${MASTER0IP}:6443 check inter 1s"
				[ ${MASTERNODECOUNT} -gt 1 ] && {
					echo "    server master-1.${CLUSTERFQDN} ${MASTER1IP}:6443 check inter 1s"
					echo "    server master-2.${CLUSTERFQDN} ${MASTER2IP}:6443 check inter 1s"
				}
				echo "    server bootstrap.${CLUSTERFQDN} ${BOOTSTRAPIP}:6443 check inter 1s"

				echo 
				echo "listen ${CLUSTERNAME}-machine-config-server-22623"
				echo "    bind ${HAPROXYVALUE}:22623"
				echo "    mode tcp"
				echo "    balance source"
				echo "    server master-0.${CLUSTERFQDN} ${MASTER0IP}:22623 check inter 1s"
				[ ${MASTERNODECOUNT} -gt 1 ] && {
					echo "    server master-1.${CLUSTERFQDN} ${MASTER1IP}:22623 check inter 1s"
					echo "    server master-2.${CLUSTERFQDN} ${MASTER2IP}:22623 check inter 1s"
				}
				echo "    server bootstrap.${CLUSTERFQDN} ${BOOTSTRAPIP}:22623 check inter 1s"
				echo 

				echo "listen ${CLUSTERNAME}-ingress-router-80"
				echo "    bind ${HAPROXYVALUE}:80"
				echo "    mode tcp"
				echo "    balance source"
				echo "    server master-0.${CLUSTERFQDN} ${MASTER0IP}:80 check inter 1s"
				[ ${MASTERNODECOUNT} -gt 1 ] && {
					echo "    server master-1.${CLUSTERFQDN} ${MASTER1IP}:80 check inter 1s"
					echo "    server master-2.${CLUSTERFQDN} ${MASTER2IP}:80 check inter 1s"
				}
				echo "    # addingressrouternode80"

				echo 
				echo "listen ${CLUSTERNAME}-ingress-router-443"
				echo "    bind ${HAPROXYVALUE}:443"
				echo "    mode tcp"
				echo "    balance source"
				echo "    server master-0.${CLUSTERFQDN} ${MASTER0IP}:443 check inter 1s"
				[ ${MASTERNODECOUNT} -gt 1 ] && {
					echo "    server master-1.${CLUSTERFQDN} ${MASTER1IP}:443 check inter 1s"
					echo "    server master-2.${CLUSTERFQDN} ${MASTER2IP}:443 check inter 1s"
				}
				echo "    # addingressrouternode443"
			} > ${HAPROXYCONFIGFILE}

			setsebool -P haproxy_connect_any 1
			systemctl --now enable haproxy
			check-for-error-and-exit $? "Could not restart haproxy/loadbalancer"
			systemctl status haproxy --no-pager
		
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting and stopping Load Balancer service"
		systemctl stop haproxy
		# We don't want to do this any more - should there be more than one cluster
		# but we are leaving behind the /etc/haproxy/yakko dir...
		# instead, we delete the individual haproxy config for the cluster at hand
		# rm /etc/haproxy/haproxy.cfg > /dev/null 2>&1
		rm ${HAPROXYCONFIGFILE} 2>/dev/null
	}
}


process-stage-downloadocpbinaries() {

	# Too bad. You are running multiple clusters? Download multiple times...


	[ $1 == "progress" ] && {

        	advance-stage-progression "Obtain OCP binaries (Installer and RHCOS)"  && return

		install-package-if-missing wget

		# This is the directory that the web server will run from
		[ ! -d $IMAGEREPO ] && mkdir -p $IMAGEREPO > /dev/null 2>&1
		cd $IMAGEREPO

		if [ ! -d "$OCPGETCLIENTVERSION"  ]
		then
			# Note that this script bundles your client and RHCOS dependencies under the client version number
			# we treat bad errors here differently to try to avoid repeating entire downloads

			mkdir $OCPGETCLIENTVERSION > /dev/null 2>&1
			cd $OCPGETCLIENTVERSION 
			echo "Getting the OCP installer (for version $OCPGETCLIENTVERSION) --> $PWD"

			# DOWNLOAD CLIENT STUFF FIRST (as of 4.6 it is common to all versions)
			wget $OCPDOWNLOADCLIENT/openshift-install-linux.tar.gz -O - | tar xz
			[ $? -ne 0 ] && { "echo Error downloading *openshift-installer*, exiting..."; cd ..; rm -rf ${OCPGETCLIENTVERSION}; cleanup-and-exit; } 

			echo "Getting the OCP client -> $PWD"
			wget $OCPDOWNLOADCLIENT/openshift-client-linux.tar.gz -O - | tar xz 
			[ $? -ne 0 ] && { "echo Error downloading *openshift-client*, exiting..."; cd ..; rm -rf ${OCPGETCLIENTVERSION}; cleanup-and-exit; } 
		
			echo "Getting RHCOS installer files... -> $PWD"

			if [ $(echo ${OCPGETCLIENTVERSION} | cut -c3) -ge 6 ]
			then
		
				##### KERNEL
				wget $OCPDOWNLOADIMAGE/rhcos-live-kernel-x86_64
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-initramfs*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; cleanup-and-exit; } 
			
				##### INITRAMFS
				wget $OCPDOWNLOADIMAGE/rhcos-live-initramfs.x86_64.img
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-initramfs*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; cleanup-and-exit; } 
		
				##### ROOTFS
				wget $OCPDOWNLOADIMAGE/rhcos-live-rootfs.x86_64.img
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-initramfs*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; cleanup-and-exit; } 
		
				##### METAL
				wget $OCPDOWNLOADIMAGE/rhcos-metal.x86_64.raw.gz
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-metal*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; cleanup-and-exit; } 
				
			else # Version 4.5 or earlier
		
				##### KERNEL
				wget $OCPDOWNLOADIMAGE/rhcos-installer-kernel-x86_64
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-kernel*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; cleanup-and-exit; } 
			
				### INITRAMFS
				wget $OCPDOWNLOADIMAGE/rhcos-installer-initramfs.x86_64.img
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-initramfs*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; cleanup-and-exit; } 
		
				##### METAL
				wget $OCPDOWNLOADIMAGE/rhcos-metal.x86_64.raw.gz
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-metal*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; cleanup-and-exit; } 
			fi

			# if we get this far it means that all the files were downloaded successfully
			# although cksum would be ideal. For now, leave a marker in the directory
			touch .downloadcomplete
		else
			echo "Using OCP Version $OCPGETCLIENTVERSION already downloaded..."
		fi
	
		cd ${YAKKOSETUPDIR}

		# We remove the CLIENT word to make it less confusing if someone reads the ${CLUSTERCONFIGFILE} file
		OCPINSTALLVERSION=$OCPGETCLIENTVERSION
		echo OCPINSTALLVERSION=${OCPGETCLIENTVERSION} >> ${CLUSTERCONFIGFILE}
	}

	[ $1 == "rollback" ] && {
		if [ -e "${IMAGEREPO}/${OCPGETCLIENTVERSION}/.downloadcomplete" ]
		then 
			rollback-stage-progression "Downloaded binaries will remain in place"
		else
			rollback-stage-progression "Deleting OCP files for version ${OCPGETCLIENTVERSION} (Download not completed)"
			rm -rf ${IMAGEREPO}/${OCPGETCLIENTVERSION}
		fi
	}
}


process-stage-httpserver() {

	HTTPDCONFIGFILE=/etc/httpd/conf.d/httpd-${YAKKONAME}-build-${CLUSTERNAME}.conf

	[ $1 == "progress" ] && {

        	advance-stage-progression "Configure HTTP server for installation of all cluster components"  && return

		ask-user "Configure and enable HTTP Server in virtual network for iPXE RHCOS VM installs on this host" "Y" && {

			# First, make sure that nothing is listening already on port ${WEBSERVERPORT}

			CANDIDATEPORT=${WEBSERVERPORT}
			while [ 1 ] 
			do
				lsof -i -P -n | grep LISTEN | grep ":${CANDIDATEPORT} " >/dev/null
				RESULT1=$?
				semanage port -l | grep ${CANDIDATEPORT} | grep http >/dev/null 2>&1
				RESULT2=$?

				if [ $RESULT1 -eq 1 -a $RESULT2 -eq 0 ]
				then
					WEBSERVERPORT=$CANDIDATEPORT 
					semanage port -a -t http_port_t -p tcp ${WEBSERVERPORT} 2>/dev/null
					WEBSERVERURL=http://${WEBSERVERIP}:${WEBSERVERPORT}
					echo "WEBSERVERPORT=${WEBSERVERPORT}" >> ${YAKKODEFAULTS}
					echo "WEBSERVERURL=http://${WEBSERVERIP}:${WEBSERVERPORT}" >> ${YAKKODEFAULTS}
					break
				else
					echo "ERROR: Port ${CANDIDATEPORT} is not available for serving RHCOS images."
					echo "       If this is not something you can change, enter an alternative port"
					echo "       now, or press <CTRL-C> to address."
					echo
					echo -n "Enter alternative (4-digit) port for RHCOS image webserver: "
					read RESPONSE
					if [[ ${RESPONSE} =~ ^[0-9]+[0-9]+[0-9]+[0-9]+$ ]]  
					then
						echo "Testing port ${RESPONSE} for availability"
						echo
						CANDIDATEPORT=$RESPONSE
						sleep 1
					else
						echo "That's not a port number, try again!"
					fi
				fi
			done 
			echo "Using port [${WEBSERVERPORT}] for RHCOS image delivery"

			# Now that we know what we are running up, we can set the directory to provide the sources
			# From the below dir, things will get cookin'
			OCPINSTALLSOURCE=$IMAGEREPO/$OCPINSTALLVERSION
			OCCOMMAND=${OCPINSTALLSOURCE}/oc
			echo "OCP will be made available by HTTP server from directory $OCPINSTALLSOURCE"
			echo
	
			install-package-if-missing httpd

			echo "<BR><BR><H1>The YAKKO web server is working!</H1>" > $IMAGEREPO/index.html # to have a test file there...
		
			{
				echo "Listen ${WEBSERVERIP}:${WEBSERVERPORT}"
				echo "<VirtualHost ${WEBSERVERIP}:${WEBSERVERPORT}>"
				echo "	DocumentRoot ${IMAGEREPO}"
	   	 		echo "	<Directory ${IMAGEREPO}>"
	   	    		echo "		Options Indexes FollowSymLinks"
	   	    		echo "		Require all granted"
	   	    		echo "		AllowOverride None"
	   	 		echo "	</Directory>"
				echo "</VirtualHost>"
		
			} > ${HTTPDCONFIGFILE}
		
			# Figure out which of these are required
			# and needed to survive a reboot...
			chcon  --user system_u --type httpd_sys_content_t -Rv $IMAGEREPO
			semanage fcontext -a -t httpd_sys_content_t "$IMAGEREPO(/.*)?"
			restorecon -Rv $IMAGEREPO

			# We disable port 80 since we know it should not be served via httpd
			sed -i "/^Listen 80/c\# Listen 80" /etc/httpd/conf/httpd.conf  2>/dev/null
	
			systemctl restart httpd
			check-for-error-and-exit $? "Could not start HTTPD server"
			systemctl enable httpd

			echo "OCPINSTALLSOURCE=$OCPINSTALLSOURCE" >> $CLUSTERCONFIGFILE
			echo "OCCOMMAND=${OCCOMMAND}" >> $CLUSTERCONFIGFILE
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Unconfiguring installation webserver - content will remain in place."
		rm ${HTTPDCONFIGFILE}  2>/dev/null
		rm $IMAGEREPO/index.html  2>/dev/null
		sed -i "/WEBSERVERPORT/d" ${YAKKODEFAULTS}
		systemctl restart httpd > /dev/null 2>&1
	}
}


process-stage-changefirewall() {

	#If using a firewall on host, don't forget to allow connections to these ports on IP ${CLUSTERPROXY}: 6443, 22623, 80 and 443.

	[ $1 == "progress" ] && {

        	advance-stage-progression "Configure Firewall" && return

		firewall-cmd --state >/dev/null 2>&1
		if [ $? -eq 252 ]
		then
			echo "Firewall is not running. Configuration is not required."
		else
			ask-user "Change Firewall rules" "Y" && { 

				echo "Changing firewall port for HTTP apps - 80/tcp access"
				firewall-cmd --add-port=80/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=80/tcp --permanent

				echo "Changing firewall port for HTTP infra - ${WEBSERVERPORT}/tcp access"
				firewall-cmd --add-port=${WEBSERVERPORT}/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=${WEBSERVERPORT}/tcp --permanent

				echo "Changing firewall port for HTTPS 443/tcp access"
				firewall-cmd --add-port=443/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=443/tcp --permanent

				echo "Changing firewall port for COCKPIT - 9090/tcp access" 
				firewall-cmd --add-port=9090/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=9090/tcp --permanent

				echo "Changing firewall port for OCP API - 6443/tcp access"
				firewall-cmd --add-port=6443/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=6443/tcp --permanent

				echo "Changing firewall port for OCP comms - 22623/tcp access"
				firewall-cmd --add-port=22623/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=22623/tcp --permanent

				echo "Changing firewall port for OCP comms - 22623/udp access"
				firewall-cmd --add-port=22623/udp --permanent
				firewall-cmd --zone=libvirt --add-port=22623/udp --permanent

				echo "Changing firewall port for DHCP"
				firewall-cmd --add-service=dhcp --permanent

				echo "Changing firewall port for DNS / external access"
				firewall-cmd --add-service=dns --permanent

				firewall-cmd --reload
		}
		fi	
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Firewall will remain unchanged - ports stay open"
	}
}


process-stage-generateocpinstallerconfig() {

	[ $1 == "progress" ] && {

                advance-stage-progression "OCP Configuration for Installation"  && return

		ask-user "Generate OCP cluster manifests and ignition files required for cluster bootstrap" "Y" && {
	
			echo Writing "ocp-setup-env" script for administration. Run \"source ${YAKKOSETUPDIR}/ocp-setup-env\" to load post-install...
			{
				echo "PATH=\$PATH:${OCPINSTALLSOURCE}" 
				echo export KUBECONFIG=${CLUSTERSETUPDIR}/auth/kubeconfig
			}  > ocp-setup-env
			chmod +x ocp-setup-env

			# And we do this for the config file too, which is for the system
			{
				echo "PATH=\$PATH:${OCPINSTALLSOURCE}" 
				echo export KUBECONFIG=${CLUSTERSETUPDIR}/auth/kubeconfig
			}  >> ${CLUSTERCONFIGFILE}

			#And we set KUBECONFIG from here on too...
                        export KUBECONFIG=${CLUSTERSETUPDIR}/auth/kubeconfig
	
			# We load/reload, in case there was an interrupt to the AUTO setup and these values were released
			SSHPUBKEY=$(cat $OCPSSHKEY.pub)
			PULLSECRET=$(cat ${PULLSECRETFILE})

			# Check if HyperThreading is enabled, just in case
			SOCKETCOUNT=$(lscpu | grep "Socket(s):" | cut -f2 -d: | awk '{print $1}')
			CORECOUNTPS=$(lscpu | grep "Core(s) per socket:" | cut -f2 -d: | awk '{print $1}')
			CORECOUNT=$((${SOCKETCOUNT} * ${CORECOUNTPS}))
			THREADCOUNTPC=$(lscpu | grep "Thread(s) per core" | cut -f2 -d: | awk '{print $1}')
			THREADCOUNT=$((${THREADCOUNTPC} * ${CORECOUNT}))

			echo "The server has [$CORECOUNT] CPU cores and [$THREADCOUNT] threads"

			if [ ${CORECOUNT} -eq ${THREADCOUNT} ]
			then
				# No HT
				HYPERTHREADING=Disabled
			elif [ $((${CORECOUNT}*2)) -eq ${THREADCOUNT} ]
			then
				# HT is on
				HYPERTHREADING=Enabled
			else
				echo "CANNOT TELL IF HYPER-THREADING IS ENABLED, ASSUMING IT IS NOT"
				HYPERTHREADING=Disabled
			fi

			echo
			echo "Generating INSTALL CONFIG file..."
			
			{
				echo "apiVersion: v1"
				echo "baseDomain: ${CLUSTERDOMAIN}"
				echo "compute:"
				echo "- hyperthreading: ${HYPERTHREADING}"
				echo "  name: worker"
				echo "  replicas: 0"
				echo "controlPlane:"
				echo "  hyperthreading: ${HYPERTHREADING}"
				echo "  name: master"
				echo "  replicas: ${MASTERNODECOUNT}"
				echo "metadata:"
				echo "  name: ${CLUSTERNAME}"
				echo "networking:"
				echo "  clusterNetwork:"
				echo "  - cidr: 10.128.0.0/14 "
				echo "    hostPrefix: 23"
				echo "  networkType: OpenShiftSDN"
				echo "  serviceNetwork:"
				echo "  - 172.30.0.0/16"
				echo "platform:"
				echo "  none: {} "
				echo "fips: false "
				echo "pullSecret: '$PULLSECRET' "
				echo "sshKey: '$SSHPUBKEY'"
		
			} > ${CLUSTERSETUPDIR}/install-config.yaml
	
			# we make a copy for later review as this gets deleted by the create-manifests stage
			cp ${CLUSTERSETUPDIR}/install-config.yaml ${CLUSTERSETUPDIR}/install-config.yaml.original
			echo "Making a reference copy of install-config.yaml as install-config.yaml.original"
	
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting cluster ignition and configuration files"
		rm ocp-setup-env > /dev/null 2>&1
		rm ${CLUSTERSETUPDIR}/install-config.yaml  > /dev/null 2>&1
		rm ${CLUSTERSETUPDIR}/install-config.yaml.original  > /dev/null 2>&1
		rm $IMAGEREPO/*ign  > /dev/null 2>&1
	}
}


process-stage-ingestmanifestsandignition()
{

	[ $1 == "progress" ] && {

                advance-stage-progression "OCP Ingest manifest and ignition files"  && return

		if [ ${PAUSEFORCONFIGEDIT} -eq 0 ]
		then
			echo
			print-in-colour orange "ALERT: PAUSE REQUESTED AT THIS POINT TO ALLOW MANUAL EDITING OF install-config.yaml."
			print-in-colour orange "       File is located at:  ${CLUSTERSETUPDIR}/install-config.yaml"
			echo
			echo -n "<Press any key to continue from here when ready - or CTRL-C and re-issue 'yakko' later> "
			read RESPONSE
			echo
		fi
		
		ask-user "Ingest OCP cluster manifests and ignition files required for cluster bootstrap" "Y" && {

			echo Creating manifests...
			${OCPINSTALLSOURCE}/openshift-install create manifests --dir=${CLUSTERSETUPDIR}
			check-for-error-and-exit $? "Could not create OCP manifests"

			if [ ${WORKERNODECOUNT} -gt 0 ]
			then
				# There are worker nodes to be built, so masters will become non-schedulable
				sed -i -r 's/(mastersSchedulable: ).*/\1False/' $CLUSTERSETUPDIR/manifests/cluster-scheduler-02-config.yml
			fi

			echo
			echo Creating OCP Cluster ignition files required for node configuration
			$OCPINSTALLSOURCE/openshift-install create ignition-configs --dir=$CLUSTERSETUPDIR
			check-for-error-and-exit $? "Could not create OCP ignition files"
			cp $CLUSTERSETUPDIR/*.ign $IMAGEREPO
			chmod 644 $IMAGEREPO/*.ign
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Manifest and ignition file ingest"
		cp ${CLUSTERSETUPDIR}/install-config.yaml  ${CLUSTERSETUPDIR}/install-config.yaml.edit 2>/dev/null
	}
}


process-stage-build-bootstrapnode() {

	[ $1 == "progress" ] && {

                advance-stage-progression "KVM Bootstrap Host Configuration" && return

		ask-user "Configure OCP bootstrap VM host" "Y" && {
			# Bootstrap node is MAC address is the first to be defined 
			build-ocp-node bootstrap ${BOOTSTRAPMAC} 2 6000 20 bootstrap.ign
			check-for-error-and-exit $? "Could not build VM for node [bootstrap]: virt-install error code [$?], check ~/.cache/virt-manager/virt-install.log"
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting bootstrap node"
		delete-kvm-machine bootstrap.${CLUSTERFQDN}
	}
}


process-stage-build-ocp-masternodes() {

	[ $1 == "progress" ] && {

                advance-stage-progression "KVM Master Nodes Configuration"  && return

		ask-user "Configure OCP master VM hosts" "Y" && {

			build-ocp-node master-0 ${MASTER0MAC} ${MASTERVCPUS} ${MASTERRAMSIZE} ${MASTERDISKSIZE} master.ign
			check-for-error-and-exit $? "Could not build VM for node [master-0]"

			[ ${MASTERNODECOUNT} -gt 1 ] && {
				# It's either 1 or 3 nodes, never 2 AFAWK in 2020

				build-ocp-node master-1 ${MASTER1MAC} ${MASTERVCPUS} ${MASTERRAMSIZE} ${MASTERDISKSIZE} master.ign
				check-for-error-and-exit $? "Could not build VM for node [master-1]"

				build-ocp-node master-2 ${MASTER2MAC} ${MASTERVCPUS} ${MASTERRAMSIZE} ${MASTERDISKSIZE} master.ign
				check-for-error-and-exit $? "Could not build VM for node [master-2]"
			}
		}

	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting OCP master nodes"
		for MASTERNODE in $(virsh list --all --name | grep "master-" | grep ${CLUSTERFQDN})
                do
			delete-kvm-machine ${MASTERNODE}
                done
	}
}


process-stage-build-ocp-workernodes() {

	[ $1 == "progress" ] && {

                advance-stage-progression "KVM Worker Node Configuration"  && return

		NODESTOBUILD=${WORKERNODECOUNT}

		if [ $NODESTOBUILD -eq 0 ]
		then
			echo "No Worker nodes were requested. Worker nodes can be added later by calling: "
			echo "- yakko infra addnode"
		else
			ask-user "Configure OCP worker VM node(s)" "Y" 
			if [ $? -eq 0 ]
			then
				while [ $NODESTOBUILD -ne 0 ]
				do
					((NODESTOBUILD--))
       	                		((NODECOUNT++))
       	                	 	sed -i "/NODECOUNT=.*/c\NODECOUNT=${NODECOUNT}" ${CLUSTERCONFIGFILE} 2>/dev/null
		
       			               	NEWNODENAME=node-${NODECOUNT}
					NEWNODELIST="${NEWNODELIST} ${NEWNODENAME}"
		
					build-ocp-node ${NEWNODENAME} auto ${WORKERVCPUS} ${WORKERRAMSIZE} ${WORKERDISKSIZE} worker.ign
					check-for-error-and-exit $? "Could not build VM for node [${NEWNODENAME}]"
				done
			fi
		fi
	}     

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting OCP worker nodes"

		# Here's a tricky one since this function can be used during additional node build
		# or during a complete "deletecluster"
		# When it's the latter, we know that the DELETECLUSTERNAME must have the clustername set
		if [ "${DELETECLUSTERNAME}" == "${CLUSTERNAME}" ]
		then
			# Delete ALL worker nodes
			# All other cleanup is done as the cluster gets wiped
                	for NODETODELETE in $(virsh list --all --name | grep "node-" | grep ${CLUSTERFQDN})
                	do
				delete-kvm-machine ${NODETODELETE}
			done
		else
			# Delete nodes just added now with addnode
                	for NODETODELETE in ${NEWNODELIST} 
                	do
				echo "Rollback - deleting node [$NODETODELETE]"
				delete-kvm-machine ${NODETODELETE}
				sed -i "/${NODETODELETE}/d" /root/.ssh/known_hosts >/dev/null 2>&1

				# And just in case, we tell the cluster that the node is no longer
				${OCCOMMAND} delete node ${NODETODELETE}

				# Update the virtual network
				cat ${NETWORKXML} | grep ${NODETODELETE} > ${DHCPXMLTMPFILE} #It's way too hard to pass this as an argument below!
				if [ $? -eq 0 ]
				then
					restart-virtual-network delete ip-dhcp-host # this knows of ${DHCPXMLTMPFILE}
					sed -i "/${NODETODELETE}/d" ${NETWORKXML}
				fi

				#and we update the haproxy
				echo
				echo "Updating and restarting HAproxy"
				sed -i "/${NODETODELETE}/ d" /etc/haproxy/${YAKKONAME}/${CLUSTERNAME}.cfg #> /dev/null 2>&1
				systemctl restart haproxy
				check-for-error-and-exit $? "Could not start HA Proxy, the cluster cannot function without this."
			done
		fi
	}
}


process-stage-startocpbootstrap() {

	[ $1 == "progress" ] && {

                advance-stage-progression "OCP Cluster Bootstrap"  && return

		ask-user "Start/continue OCP Cluster bootstrap" "Y" && {
	
			echo You can observe the output of the bootstrap node at this stage by issuing:
			echo ssh -i $OCPSSHKEY core@bootstrap.${CLUSTERFQDN} "sudo journalctl -b -f -u bootkube.service"
			echo 

			# Again. I've seen bootstrap node get stuck because it can't reach the network and
			# this jolt fixes it. RHEL 8.4 on laptop
			systemctl restart libvirtd
			sleep 2
	
			while [ 1 ]
			do
				$OCPINSTALLSOURCE/openshift-install --dir=$CLUSTERSETUPDIR wait-for bootstrap-complete
	
				if [ $? -eq 0 ]
				then
					#the wait-for bootstrap-complete was successful
					virsh list | grep bootstrap.${CLUSTERFQDN} > /dev/null 2>&1
					if [ $? -eq 0 ]
					then
						delete-kvm-machine bootstrap.${CLUSTERFQDN}

						# Now we delete the boostrap from the haproxy!!!
						cat ${HAPROXYCONFIGFILE} | grep -v bootstrap > ${HAPROXYCONFIGFILE}.nobootstrap
						rm -f ${HAPROXYCONFIGFILE}
						mv ${HAPROXYCONFIGFILE}.nobootstrap ${HAPROXYCONFIGFILE}
						systemctl restart haproxy
					fi
					break
				else
					echo
					echo "The bootstrap process doesn't appear to have completed successfully. "
					echo "This process downloads a lot of images from quay.io and can take a long time."
					echo
					echo    "Press <ENTER> to re-issue this stage (wait-for bootstrap-complete) and give it some more time, OR... "
					echo -n "Press <CTRL-C> to abort this install and examine then rerun install and return to this point"
					read CONTINUE
					$OCPINSTALLSOURCE/openshift-install --dir=$CLUSTERSETUPDIR wait-for bootstrap-complete
					echo
				fi
			done
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "OCP boostrap stage"
	}
}


process-stage-approvecsrs() {

	[ $1 == "progress" ] && {

                advance-stage-progression "CSR Background Approval"  && return

		ask-user "Approve pending/recurring CSRs" "Y" && {

			echo "CSR approval task will run in the background and will exit automatically on cluster completion."

			CSRAPPROVALPID=0
	
			if [ $CSRAPPROVALPID -eq 0 ]
			then

				approve-csrs-normal $((${MASTERNODECOUNT} + ${WORKERNODECOUNT}))
				CSRAPPROVALPID=$!
			fi
		
			# monitoring the output through the bootstrap requires not deleting it...
			trap 'kill -s SIGTERM $CSRAPPROVALPID ; sleep 2; cleanup-and-exit' SIGINT
		}
	}		

	[ $1 == "rollback" ] && {
		rollback-stage-progression "CSR approvals"
		kill -s SIGKILL $CSRAPPROVALPID > /dev/null 2>&1
	}
}


process-stage-reduceprometheusmemory() {

	[ $1 == "progress" ] && {

                advance-stage-progression "Prometheus Memory Footprint"  && return

		ask-user "Reduce Prometheus pod memory allocation" "${REDUCEPROMETHEUS}" && {

			PROMETHEUSPID=0

			if [ $PROMETHEUSPID -eq 0 ]
			then
				{ 
					echo "prometheusK8s:" 
					echo "  resources:" 
					echo "    requests:"
   		   			echo "      memory: 256Mi"
				} > $CLUSTERSETUPDIR/prometheus-config.yaml
		
				sleep 20 # Seen issues before...
				${OCCOMMAND} create configmap cluster-monitoring-config --from-file=config.yaml=${CLUSTERSETUPDIR}/prometheus-config.yaml -n openshift-monitoring
			
				{
					trap "echo; echo 'Prometheus pods not deleted for resizing (oc delete pod prometheus-k8s-* -n openshift-monitoring)'; cleanup-and-exit" SIGTERM
					sleep 30 #This is what the recipe suggested...
		
					PROMETHEUSTIMER=3600
					while [ 1 ] 
					do
						${OCCOMMAND} get pods -n openshift-monitoring 2>/dev/null | grep "prometheus-k8s" > /dev/null 2>&1
						[ $? -eq 0 ] && break

						sleep 15
						PROMETHEUSTIMER=$(($PROMETHEUSTIMER - 15))

						# Time to give up if I am still alive
						[ $PROMETHEUSTIMER -le 0 ] && exit
					done
		
					sleep 10
					echo
					${OCCOMMAND} delete pod prometheus-k8s-0 -n openshift-monitoring > /dev/null 2>&1
					${OCCOMMAND} delete pod prometheus-k8s-1 -n openshift-monitoring > /dev/null 2>&1
					echo "Reconfigured  Prometheus for memory footprint reduction"
		
				} &
				PROMETHEUSPID=$!
			fi
		
			# monitoring the output through the bootstrap requires not deleting it...
			trap 'kill -s SIGTERM $PROMETHEUSPID; sleep 2; echo "Shutting down prometheus memory reduction (NOT DONE), please wait..."; sleep 20; cleanup-and-exit' SIGINT
		
		}
	}	

	[ $1 == "rollback" ] && {
		if [ ${REDUCEPROMETHEUS} == "Y" ]
		then
			rollback-stage-progression "Prometheus memory changes"
			kill -s SIGKILL $PROMETHEUSPID > /dev/null 2>&1
			rm $CLUSTERSETUPDIR/prometheus-config.yaml >/dev/null 2>&1
		fi
	}
}


process-stage-waitforocpinstalltocomplete() {

	[ $1 == "progress" ] && {

                advance-stage-progression "OCP - Complete Installation"  && return

		ask-user "Wait for OCP install to complete" "Y" && {

			echo Some useful commands while waiting:
			echo "- tail -f $CLUSTERSETUPDIR/.openshift_install.log"
			echo "- source ocp-setup-env ---->  For access to \"oc\" at the command line"
			echo "- oc get clusteroperators ->  To check operator progression, can also be \"oc get co\""
			echo "- oc get clusterversion --->  On build, it shows you % progression, after that, cluster version" 
			echo "- oc get nodes ------------>  To see nodes and node status"
			echo
		
			$OCPINSTALLSOURCE/openshift-install --dir=$CLUSTERSETUPDIR wait-for install-complete 
			OCPINSTALLCODE=$?
			
			# Stop background "assistants"
			kill -s SIGTERM $CSRAPPROVALPID $PROMETHEUSPID > /dev/null 2>&1
			sleep 15

			echo
			echo ${SEPARATIONLINE}
			echo
			print-in-colour ${YAKKOTEXTCOLOR}  FINISHED OCP INSTALLATION - $(date)
			print-time-elapsed
			
			# We write the first time we believe the cluster was up, for reference
			# It will also let's us know that there is no further building possible

			# This will print the date like 15-06-2021@10:45:46
			CLUSTERCOMPLETE="\"exitcode ${OCPINSTALLCODE} date $(date +"%d-%b-%Y@%T")\"" 
			echo "CLUSTERCOMPLETE=$CLUSTERCOMPLETE" >> ${CLUSTERCONFIGFILE}

			if [ $OCPINSTALLCODE -ne 0 ]
			then
				echo 
				echo The OCP Installer exited with code [ $OCPINSTALLCODE ]
				echo Cluster has $(${OCCOMMAND} get nodes | egrep "worker|master" | wc -l) nodes and $(${OCCOMMAND} get co | awk '{ print $3 }' | grep True | wc -l) operators up 
			else
				compose-html-cluster-report

				echo
				print-in-colour ${YAKKOTEXTCOLOR} "IMPORTANT:"
				print-in-colour ${YAKKOTEXTCOLOR} " - you can bookmark cluster info at http://${HTMLREPORTHOST}:${WEBSERVERPORT}"
				print-in-colour ${YAKKOTEXTCOLOR} " - you DO NOT have a registry -> yakko ops localregistry"
				print-in-colour ${YAKKOTEXTCOLOR} " - you cannot access the cluster from another computer -> yakko infra openaccess"
				print-in-colour ${YAKKOTEXTCOLOR} " - you have no user DB-> yakko ops htpasswd administrator &  yakko ops useradd <user>"
				print-in-colour ${YAKKOTEXTCOLOR} ${SEPARATIONLINE}
				
				# We build the 'last successful config' file for further auto
				if [ ! -e ${LASTBUILDCONFIG} -o -w ${LASTBUILDCONFIG} ]
				then
					{
						echo "CLUSTERNAME=${CLUSTERNAME}"
						echo "CLUSTERDOMAIN=${CLUSTERDOMAIN}"
						echo "CLUSTERFQDN=${CLUSTERFQDN}"
						echo "BASENETWORK=${BASENETWORK}"
						echo "OCPVMDISKDIR=${OCPVMDISKDIR}"
						echo "MASTERNODECOUNT=${MASTERNODECOUNT}"
						echo "WORKERNODECOUNT=${WORKERNODECOUNT}"
						echo "MASTERRAMSIZE=${MASTERRAMSIZE}"
						echo "WORKERRAMSIZE=${WORKERRAMSIZE}"
						echo "OCPGETCLIENTVERSION=${OCPGETCLIENTVERSION}"
	
					} > ${LASTBUILDCONFIG}
				fi
			fi

			# This is my tally, started on 24/11/2020 to keep count of build clusters
			if [ -r ${YAKKOSETUPDIR}/.tallyhosts ]
			then
				for TALLYHOST in $(cat ${YAKKOSETUPDIR}/.tallyhosts)
				do
					if [ "$(hostname)" == "${TALLYHOST}" ]
					then
						echo "Cluster [${CLUSTERNAME}] built on [$(date)] - Masters: ${MASTERNODECOUNT} Workers: ${WORKERNODECOUNT}" >> /YAKKO-TALLY-${TALLYHOST}
					fi
				done
			fi
			echo
			check-cluster-state 1
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "installation of OCP cluster ${CLUSTERNAME}"	
		if [ $DELETECLUSTERMODE -eq 1 ]
		then
			# We are only rolling back THIS stage
			echo "This is a WAIT stage - the cluster is still attempting build in the background."
			echo "Supporting operations already started will run until timing out."
			echo
			echo "Run  yakko  again to finish this stage when ready or follow prompts to delete cluster."
			echo
		fi
	}
}


process-stage-continue-clusterconfiguration() {

	[ $1 == "progress" ] && {

        	advance-stage-progression "Continue Cluster Configuration"

		if [ ! -z "${CLUSTERCOMPLETE}" ]
		then	
			#if there was an install code registered in ${CLUSTERCONFIGFILE} file then the installer did all it could.
			check-cluster-state 1
			cleanup-and-exit
		fi

		echo
		ask-user "Attempt AUTOMATIC configuration of cluster from this point" "Y" noauto
		if [ $? -eq 0 ]
		then 
			AUTOSETUP=1
		else
			echo
			ask-user "MANUAL CONFIGURATION: Resume where you left off (\"y\") or Start from the begining (\"n\")" "Y" noauto
			if [ $? -ne 0 ]
			then
				YAKKOSTAGE=0
			fi
		fi
	}	

	# NOTE: THIS STAGE MUST PRECEDE yakko-process-stages
	# 	SEE MAIN AT BOTTOM

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Cluster configuration"
	}
}


process-stage-gatherclusterconfiguration() {

	[ $1 == "progress" ] && {

        	advance-stage-progression "Gather Cluster Configuration information"

		# A cluster config does not exist - this should be the first run
		
		# Some of these are more "global" in nature so we store them in ${YAKKODEFAULTS}
		# (which was separate functionality in earlier versions)


		if [ "${YAKKOREBUILD}" -eq 1 ]
		then
			# If ${LASTBUILDCONFING} exists, we created a successful cluster before
			# This can only be called with 'yakko rebuildcluster' with no cluster configured
			# And for this to happen we get here with YAKKOREBUILD == 1

			echo "REBUILD requested, YAKKO will attempt repeating the last known successful cluster configuration:"
			echo
			cat .lastyakkobuild
			source ${LASTBUILDCONFIG}
		else
			# THIS SECTION IS ALL ABOUT QUESTIONS 

			echo "This section will gather relevant information to build an OpenShift cluster on this host."
			echo "Questions are separated by '----'. Default options are in [brackets], press enter to accept them."


			### QUESTION: Cluster name  ## Not stored in YAKKO defaults
			print-question-separator
			while [ 1 ]
			do
				if [ ! -z "${CLUSTERNAME}" ]
				then
					echo -n "Enter the name of the OpenShift cluster to create [\"${CLUSTERNAME}\"]: "
				else
					echo -n "Enter the name of the OpenShift cluster to create: "
				fi
				read RESPONSE
	
				if [ -z "${RESPONSE}" -a ! -z "${CLUSTERNAME}" ]
				then
					break
				fi
		
				if [ -z "${RESPONSE}" ]
				then
					echo "Invalid cluster name."
					continue
				fi
		
				if [[ ${RESPONSE} =~ ^[a-z0-9]*$ ]]
				then
					CLUSTERNAME=${RESPONSE}
					break
				else
					echo "Invalid cluster name. Please use lower-case characters and numbers only."
				fi
			done
	
	
			### QUESTION: domain name ## Stored in YAKKO defaults
			print-question-separator
			echo -n "Enter the DOMAIN name to setup your cluster under [\"${CLUSTERDOMAIN}\"]: "
	       	 	read RESPONSE
			[ ! -z "$RESPONSE" ] && CLUSTERDOMAIN=$RESPONSE


			### QUESTION: Host's IP address on the network  ## Not stored in YAKKO defaults
			# identifying 'this' host - this can be tricky as we are looking for the interface with the cable (hopefully!)
			# we cycle through the physical ports and compare them to those that are up until we nail one
			print-question-separator
			for PHYSICALNWPORT in $(ls -l /sys/class/net/ | grep -v virtual | awk '{print $9}')
			do
				for CONNECTEDNWPORT in $(ip -br -4 addr show | grep UP |awk '{print$1}')
				do
					if [ $PHYSICALNWPORT == $CONNECTEDNWPORT ]
					then 
						YAKKOMAINHOSTPORT=$CONNECTEDNWPORT
						break
					fi
				done
				if [ ! -z "$YAKKOMAINHOSTPORT" ]
				then
					break
				fi
			done

			YAKKOHOSTIP=$(ip -br -4 addr show | grep ${YAKKOMAINHOSTPORT}| awk '{print $3}' | cut -f1 -d/)

			echo "It is recommended that this host have a fixed IP address and a resolvable hostname."
			while [ 1 ]
			do
				echo -n  "Enter the IP address of this host on your network [\"${YAKKOHOSTIP}\"]: "
				read RESPONSE

	
				if [ ! -z "${RESPONSE}" ]
				then
					if [[ $RESPONSE =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]
					then
						ping -c 1 $RESPONSE > /dev/null 2>&1
						if [ $? -ne 0 ]
						then
							echo "ERROR: Could not identify this host IP address via PING. Check your IP address!"
							echo
							continue
						fi
						YAKOHOSTIP=$RESPONSE
					else
 						echo "That's not a valid IP address!"
						echo
						continue
					fi

					YAKKOHOSTIP=$RESPONSE
					break
				else
					break
				fi
			done


	       		### QUESTION: basenetwork ## Stored in YAKKO defaults
			print-question-separator
	       		echo -n "Enter the SUBNET (/24) inside KVM that you want cluster under [\"${BASENETWORK}\"]: "
	       		read RESPONSE
	       		[ ! -z "$RESPONSE" ] && BASENETWORK=$(echo $RESPONSE | cut -f1-3 -d.)


			### QUESTION: Allow open access to the cluster upon creation  # This is recorded only in yakkodefaults
			print-question-separator
			echo "YAKKO uses HAproxy to loadbalance access to OpenShift nodes, while also allowing"
			echo "or restricting access to either THIS host only, or clients in your local network." 
			echo "(You can change this later using 'yakko infra changeaccess')"
			ask-user "Allow 'open' cluster access from other clients (other than this server)" Y
			HAPROXYACCESS=$?


			### QUESTION: Cluster version
			print-question-separator
	
			# Now we get on with downloading the OCP binaries

			# NOTE: There can be discrepancies between the installer version (OCPGETCLIENTVERSION) and 
			# the RHCOS images version (OCPGETIMAGEVERSION)
			# We will download the lot under OCPGETCLIENTVERSION to keep a single point reference. This seems to make sense 
			# based on what the OCP mirror offers.
			# HOWEVER, outside of the DOWNLOAD section of the script, the version will be known as OCPINSTALLVERSION

			# regular releases are at:
			# INSTALLER: https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/latest
			# IMAGES: https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos/latest/latest

			# pre-release are at:
			# INSTALLER: https://mirror.openshift.com/pub/openshift-v4/clients/ocp-dev-preview/latest

			# Latest candidates:
			# INSTALLER: https://mirror.openshift.com/pub/openshift-v4/clients/ocp/candidate/

			# IMAGES: https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos/pre-release/latest/
		
			# Get the OCP installer specifically for x86_64. One day this may be useful for IBM ... Power ;)
			OCPPLATFORM=x86_64
			OCPROOT=https://mirror.openshift.com/pub/openshift-v4/$OCPPLATFORM
		
			# This would get you the number for the latest version
			OCPDOWNLOADCLIENT="$OCPROOT/clients/ocp/latest"
			OCPDOWNLOADIMAGE="$OCPROOT/dependencies/rhcos/latest/latest"
	
			wget -O $OCPWGETTMP $OCPDOWNLOADCLIENT/release.txt > /dev/null 2>&1
			check-for-error-and-exit $? "Failed to download version file for latest OCP - check if https://mirror.openshift.com is reachable" 
				
		        OCPGETCLIENTVERSION=$(cat $OCPWGETTMP | grep Version: | awk '{ print $2 }')

			OCPIMAGESONFILE=$(ls -d images/[0-9]* 2>/dev/null | cut -f2 -d/)

			while [ 1 ]
			do
				echo "What release version do you want to install:"
				echo "    1) Latest release available ($OCPGETCLIENTVERSION)"
				echo "    2) Releases on disk"
				for AVAILIMAGE in $OCPIMAGESONFILE
				do
					echo "        - $AVAILIMAGE"
				done
				echo "    3) Older releases (hard! you will need to pick image version and installer version) "
				echo "    4) Latest release candidate (good luck!)"
				echo "    5) Latest pre-release nightly (unknown territory...)"
				echo -n "Pick option number from above (1-5) [1]: "
				read RESPONSE
	
				if [ "$RESPONSE" == "" -o "$RESPONSE" == 1 ]
				then
					RESPONSE=1
					break
				elif [ "$RESPONSE" == "2" ]
				then
					while [ 1 ]
					do
						echo -n "Select image version from above list of on-disk images (copy/paste from above): "
						read OCPGETCLIENTVERSION
						if [ -d images/${OCPGETCLIENTVERSION} ]
						then
							break
						else
							echo "Image [${OCPGETCLIENTVERSION}] is not a valid/existing image, choose another."
						fi
					done
					break
				elif [ "$RESPONSE" == "3" ]
				then
					# Query what client is desired
					while [ 1 ]
					do
						echo -n  'Enter OCP INSTALLER CLIENT version you require, e.g. "4.5.6" (may not work btw...): ' 
						read OCPGETCLIENTVERSION
						OCPDOWNLOADCLIENT="$OCPROOT/clients/ocp/$OCPGETCLIENTVERSION"
				
						wget -O $OCPWGETTMP $OCPDOWNLOADCLIENT/sha256sum.txt >/dev/null 2>&1
						if [ $? -ne 0 ]
						then
							echo "Invalid version $OCPGETCLIENTVERSION, no content available"
						else
							break
						fi
					done
		
					# Query what RHCOS is desired
					while [ 1 ]
					do
						echo "Please refer to https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos/${OCPGETCLIENTVERSION:0:3})"
						echo -n  'Enter OCP RHCOS version you require, e.g. "4.5.6" (may also not work btw...): ' 
						 # this is harder because of how the mirror is laid out
						read OCPGETIMAGEVERSION
						VERSIONMAJOR=$(echo $OCPGETIMAGEVERSION | cut -f1 -d.)
						VERSIONMINOR=$(echo $OCPGETIMAGEVERSION | cut -f2 -d.)
						VERSIONMICRO=$(echo $OCPGETIMAGEVERSION | cut -f3 -d.)
						OCPDOWNLOADIMAGE="$OCPROOT/dependencies/rhcos/$VERSIONMAJOR.$VERSIONMINOR/$OCPGETIMAGEVERSION"
		
						wget -O $OCPWGETTMP $OCPDOWNLOADIMAGE/sha256sum.txt >/dev/null 2>&1
						if [ $? -ne 0 ]
						then
							echo "Invalid version $OCPGETIMAGEVERSION, no content available"
						else
							break 2  # We break out of 2 loops at once
						fi
					done
				elif [ "$RESPONSE" == "4" ]
				then
					# This is the preview of the upcoming release - typically a RC or release candidate
					OCPDOWNLOADCLIENT=https://mirror.openshift.com/pub/openshift-v4/clients/ocp/candidate/
					OCPDOWNLOADIMAGE=https://mirror.openshift.com/pub/openshift-v4/dependencies/rhcos/pre-release/latest
					wget -O $OCPWGETTMP $OCPDOWNLOADCLIENT/release.txt > /dev/null 2>&1
					check-for-error-and-exit $? "Failed to download version file for latest pre-buildOCP"
					#OCPGETCLIENTVERSION=$(curl -s ${OCPDOWNLOADIMAGE}/sha256sum.txt | awk '{print $2}' | grep live-kernel-x86_64 | grep fc | cut -f2,3 -d"-")
					check-for-error-and-exit $? "Failed to download version file for latest OCP" 

		        		OCPGETCLIENTVERSION=$(cat $OCPWGETTMP | grep Version: | awk '{ print $2 }')
					echo "OCP pre-release version [$OCPGETCLIENTVERSION] will be downloaded to ${YAKKOSETUPDIR}/images if required"
					break
				elif [ "$RESPONSE" == "5" ]
				then
					# This is the preview of the release after next - the latest is a nightly
					OCPDOWNLOADCLIENT=https://mirror.openshift.com/pub/openshift-v4/clients/ocp-dev-preview/latest
					OCPDOWNLOADIMAGE=https://mirror.openshift.com/pub/openshift-v4/dependencies/rhcos/pre-release/latest
					wget -O $OCPWGETTMP $OCPDOWNLOADCLIENT/release.txt > /dev/null 2>&1
					check-for-error-and-exit $? "Failed to download version file for latest pre-buildOCP"
					#OCPGETCLIENTVERSION=$(curl -s ${OCPDOWNLOADIMAGE}/sha256sum.txt | awk '{print $2}' | grep live-kernel-x86_64 | grep fc | cut -f2,3 -d"-")
					check-for-error-and-exit $? "Failed to download version file for latest OCP" 

		        		OCPGETCLIENTVERSION=$(cat $OCPWGETTMP | grep Version: | awk '{ print $2 }')
					echo "OCP nightly version [$OCPGETCLIENTVERSION] will be downloaded to ${YAKKOSETUPDIR}/images if required"

					break
				else
					echo
					echo "Invalid selection, try again!"
					echo
				fi
			done

			
			### QUESTION: Get repository for VMs ## Stored in YAKKO defaults
			print-question-separator

			VMDIRSUCCESS=0
			CAPACITYALERT=0

			while [ 1 ]
			do
				while [ 1 ]
				do
					echo -n "Enter the directory where you wish to place the OCP VM disks for this cluster [\"${OCPVMDISKDIR}\"]: "
					read RESPONSE
					[ -z "$RESPONSE" ] && RESPONSE=${OCPVMDISKDIR} 
					break
		        	done

				OCPVMDISKDIR="$RESPONSE"
				mkdir -p "${OCPVMDISKDIR}" > /dev/null 2>&1
				ERROR=$?
				if [ $ERROR -ne 0 ]
				then
					echo "ERROR: Could not create/access directory [${OCPVMDISKDIR}] (mkdir error #$ERROR)"
					echo "       specify another directory or CTRL-C to inspect your system."
					echo
					continue
				else

					# The following was discovered by Wayne Boxall, adequate check
					# https://docs.fedoraproject.org/en-US/Fedora/13/html/Virtualization_Guide/sect-Virtualization-Security_for_virtualization-SELinux_and_virtualization.html
					semanage fcontext -a -t virt_image_t "${OCPVMDISKDIR}(/.*)?" >/dev/null 2>&1
					ERROR=$?
					if [ $ERROR -ne 0 -a $ERROR -ne 1 ]
					then
						echo "ERROR: Could not set virt_image_t context on directory [${OCPVMDISKDIR}] (fcontext error #$ERROR)"
						echo "       specify another directory or CTRL-C to inspect your system."
						echo
						continue
					fi

					restorecon -R -v "${OCPVMDISKDIR}"
					ERROR=$?
					if [ $ERROR -ne 0 ]
					then
						echo "ERROR: Could not set virt_image_t restorecon context on directory [${OCPVMDISKDIR}] (restorecon error #$ERROR)"
						echo "       specify another directory or CTRL-C to inspect your system."
						echo
						continue
					fi
				fi

				echo "Changing permissions for [${OCPVMDISKDIR}] and all paths above (qemu:r/w access)."

				cd "${OCPVMDISKDIR}"

				# we now add a r+x touch to the directory hierarchy where the VMs reside
				# This really should be in a separate process-stage now
				while [ 1 ] 
				do
					chmod o+rx . > /dev/null 2>&1
					ERROR=$?
					if [ $ERROR -ne 0 ]
					then
						echo "ERROR: Could not change access to directory [${PWD}] (chmod error #$ERROR)"
						echo "       specify another directory or CTRL-C to inspect your system."
						echo
						continue
					fi


					cd .. # This may not be elegant, but it works, we crawl the directory structure to the top
					if [ "$PWD" == "/" ]
					then
						VMDIRSUCCESS=1
						break
					fi
				done

				cd ${YAKKOSETUPDIR} # One day I'll clean this up....

				if [ ${VMDIRSUCCESS} -eq 1 ]
				then
					# All checks on the directory are complete
					break
				fi
			done
			
			# The next set of questions are intertwined, as they are measured against your system

			while [ 1 ] 
			do
				if [ $(echo $OCPGETCLIENTVERSION | cut -f2 -d.) -ge 8  ]
				then
					### QUESTION: Master node count 
					print-question-separator
					while [ 1 ]
					do
						# The default comes from .yakkodefaults but is version dependent
						echo -n "How many MASTER nodes do you want to configure (1 or 3) [${MASTERNODECOUNT}]: "
		
						read RESPONSE
		
						if [ -z "${RESPONSE}" ]
						then 
							RESPONSE=${MASTERNODECOUNT}
							break
						else
							if [ $RESPONSE == 1 ]
							then
								echo ${OCPGETCLIENTVERSION} | grep 4.8 >/dev/null
								if [ $? -eq 0 ]
								then
									echo "NOTE: Single Master clusters are experimental with OpenShift 4.8"
									echo "      You will likely see some errors and yet see your cluster progress."
									echo "      If it does not progress after a while, you may want to restart."
								fi
								MASTERNODECOUNT=1
								break
							elif [ $RESPONSE == 3 ]
							then
								MASTERNODECOUNT=3
								break
							else
								echo "Invalid master node count, choose 1 or 3."
							fi
						fi
					done
				else	
					MASTERNODECOUNT=3
				fi

				### QUESTION: RAM size confirmation (MASTERS)  ##
				print-question-separator
				while [ 1 ]
		                do
		                	echo -n "How much RAM (MiB) should be allocated to MASTER nodes [${RECMASTERRAMSIZE}]: "
					read VALUE
					if [ ! -z "$VALUE" ]
					then
						NUMBERRE='^[0-9]+$'
						if ! [[ $VALUE =~ $NUMBERRE ]] ; then
							echo "Error: Not a number. Try again..."
							continue
						else
							MASTERRAMSIZE=$VALUE
						fi
					else
						MASTERRAMSIZE=${RECMASTERRAMSIZE}
					fi
					break
				done

	
				### QUESTION: Add worker nodes at build ##
				print-question-separator
				while [ 1 ]
		                do
					echo "Worker nodes can be built at cluster creation or later."
					echo "To build a cluster with ONLY schedulable MASTER node(s), type '0'"
					echo -n "How many worker nodes do you want to configure at cluster build time [2]: "
					read VALUE
					if [ ! -z "$VALUE" ]
					then
						NUMBERRE='^[0-9]+$'
						if ! [[ $VALUE =~ $NUMBERRE ]] 
						then
							echo "Error: Not a number. Try again..."
							continue
						elif [ ${VALUE} -gt ${MAXWORKERNODES} ]
						then
							echo "You need to specify a number of workers up to [${MAXWORKERNODES}]"
							continue
						elif [ $VALUE -eq 0 ]
						then
							echo "No worker nodes were requested. You can add nodes later with YAKKO."
							break
						fi
						break
					else
						# Note that if $VALUE is 0 then we already have WORKERNODECOUNT properly set
						VALUE=2
						break
					fi
				done
				WORKERNODECOUNT=${VALUE}

	
				### QUESTION: RAM size confirmation (WORKERS)  ##
				if [ ${WORKERNODECOUNT} -gt 0 ]
				then 
					print-question-separator
				 	while [ 1 ]
		                 	do
		                 		echo -n "How much RAM (MiB) should be allocated to WORKER nodes [${WORKERRAMSIZE}]: "
				 		read VALUE
				 		if [ ! -z "$VALUE" ]
				 		then
				 			NUMBERRE='^[0-9]+$'
				 			if ! [[ $VALUE =~ $NUMBERRE ]] ; then
				 				echo "Error: Not a number. Try again..."
				 				continue
				 			else
				 				WORKERRAMSIZE=$VALUE
				 			fi
				 		fi
				 		break
				 	done
				fi
	
				TOTMASTERSRAM=$(($MASTERNODECOUNT * $MASTERRAMSIZE)) # This is in MB
				TOTWORKERSRAM=$(($WORKERNODECOUNT * $WORKERRAMSIZE)) # This is in MB
				TOTCLUSTERRAM=$(($TOTMASTERSRAM + $TOTWORKERSRAM))
	
				TOTMASTERSDISK=$(($MASTERNODECOUNT * $MASTERDISKSIZE)) # This is in GB
				TOTWORKERSDISK=$(($WORKERNODECOUNT * $WORKERDISKSIZE)) # This is in GB
				TOTCLUSTERDISK=$(($TOTMASTERSDISK + $TOTWORKERSDISK))
	
				TOTSYSTEMRAM=$(free -m | grep Mem:|awk '{ print $7 }')


				# QUESTION - not really but we confirm
				print-question-separator
				echo "Requested OpenShift configuration requires:"
			        echo "- RAM:  ${TOTCLUSTERRAM} MiB "
				echo "- DISK: ${TOTCLUSTERDISK} GiB "

				if [ ${TOTSYSTEMRAM} -lt ${TOTCLUSTERRAM} ]
				then
					CAPACITYALERT=1
					echo
					print-in-colour orange "Not enough RAM available for your desired configuration:"
					print-in-colour orange "Total requirement is ${TOTCLUSTERRAM} MiB but system only has ${TOTSYSTEMRAM} MiB free"
					echo 
				fi
	
				TOTSYSTEMDISK=$(df -h --block-size=1MiB ${OCPVMDISKDIR} | grep -v Filesystem | awk '{print $4}')
				if [ ${TOTSYSTEMDISK} -lt ${TOTCLUSTERDISK} ]
				then
					CAPACITYALERT=1
					print-in-colour orange "Not enough disk space available for you desired configuration:"
					print-in-colour orange "Total requirement is [${TOTCLUSTERDISK}] but ${OCPVMDISKDIR} only has [${TOTSYSTEMDISK}]"
				fi
				
				if [ ${CAPACITYALERT} -eq 0 ]
				then
					ask-user "Accept this configuration for cluster build" Y
				else
					ask-user "Accept the above configuration anyway" Y
				fi

				if [ $? -eq 0 ]
				then
					break
				else
					CAPACITYALERT=0
					continue
				fi
				

			done
		fi

		# We write a bunch of stuff for later retrieval in $YAKKODEFAULTS
		CLUSTERSETUPDIR=${YAKKOSETUPDIR}/install-${CLUSTERNAME}
		mkdir $CLUSTERSETUPDIR > /dev/null 2>&1

		NETWORKNAME=net-${YAKKONAME}-${CLUSTERNAME}
		NETWORKXML=$CLUSTERSETUPDIR/${NETWORKNAME}.xml
		CLUSTERFQDN=${CLUSTERNAME}.${CLUSTERDOMAIN}
		CLUSTERWEBURL="https://console-openshift-console.apps.${CLUSTERFQDN}"
		CLUSTERAPIURL="https://api.${CLUSTERFQDN}:6443"
		CLUSTERPROXY="${BASENETWORK}.${PROXYADDRESS}"
                WEBSERVERIP=${CLUSTERPROXY}
		OCPSSHKEY=~/.ssh/id_rsa_ocp.${CLUSTERNAME}
		DNSMASQCONFIGFILE=/etc/NetworkManager/dnsmasq.d/dnsmasq-${YAKKONAME}-${CLUSTERNAME}.conf
		HAPROXYCONFIGFILE=/etc/haproxy/${YAKKONAME}/${CLUSTERNAME}.cfg

		# We calculate the BASEMACADDRESS last digit here...
		# This in case there is more than one cluster defined... Maybe...
		BASEMACADDRESS=${COREMACADDRESS}:$(echo ${BASENETWORK} | cut -f3 -d. | xargs printf '%x')

		populate-yakkodefaults
		populate-clusterconfigfile

		### QUESTION (last): Run auto setup
 
		# We reload the defaults...
		source ${YAKKODEFAULTS} > /dev/null 2>&1

		PAUSEFORCONFIGEDIT=1
		if [ ${YAKKOREBUILD} == 1 ]
		then
			AUTOSETUP=1
		else
			print-question-separator
			ask-user "Attempt AUTOMATIC creation of cluster \"${CLUSTERNAME}\"" "Y" noauto  && AUTOSETUP=1

			# V1.1 
			### QUESTION: Allow a PAUSE to edit install-config.yaml
			print-question-separator
			echo "Although YAKKO automates OpenShift cluster creation, you may want to customise the "
			echo "'install-config.yaml' configuration file before cluster bootstrap, for example,"
		        echo "when wanting to add a proxy server for indirect connection to the internet."	
			ask-user "Pause for edit of 'install-config.yaml' when file becomes available" N noauto
			PAUSEFORCONFIGEDIT=$?  #0 is Y, so pause in process-stage-generateocpinstallerconfig
		fi


	}
	# NOTE: THIS STAGE MUST PRECEDE yakko-process-stages
	# 	SEE MAIN AT BOTTOM

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Cluster configuration gather"
		rm ${CLUSTERCONFIGFILE} > /dev/null 2>&1
		rm -rf $CLUSTERSETUPDIR > /dev/null 2>&1
	}
}


yakko-process-stages() {

	ACTION=$1 # progress or rollback

	if [ "${ACTION}" == "rollback" -a ${DELETECLUSTERFORCE} -eq 1 ]
	then
		# This questioning is bypassed if DELETECLUSTERFORCE is 0
		echo
		ask-user "*** CONFIRM *** - Deleting cluster [${CLUSTERNAME}]" "N" noauto
		[ $? -ne 0 ] && { echo; echo "ATTENTION: No action taken. Exiting."; cleanup-and-exit; }
		
		# User wants the cluster gone!
		AUTOSETUP=0
		DELETECLUSTERMODE=0 # We are destroying everything
	fi
	
	process-stage-pullsecret ${ACTION}
	process-stage-downloadocpbinaries ${ACTION}
	process-stage-libvirt ${ACTION}
	process-stage-sshclient ${ACTION}
	process-stage-virtualnetwork ${ACTION}
	process-stage-dns ${ACTION}
	process-stage-httpserver ${ACTION}
	process-stage-haproxy ${ACTION}
	process-stage-changefirewall ${ACTION}
	process-stage-generateocpinstallerconfig ${ACTION}
	process-stage-ingestmanifestsandignition ${ACTION}
	process-stage-build-bootstrapnode ${ACTION}
	process-stage-build-ocp-masternodes ${ACTION}
	process-stage-build-ocp-workernodes ${ACTION}
	process-stage-startocpbootstrap ${ACTION}
	process-stage-approvecsrs ${ACTION}
	process-stage-reduceprometheusmemory ${ACTION}
	process-stage-waitforocpinstalltocomplete ${ACTION}

	if [ "${ACTION}" == "rollback" ]
	then
		#This last one actually deletes the clusterconfig file
		#And when this happens, yakko no longer believes that a cluster exists
		#So this must be done AFTER all stages are cleared
		process-stage-gatherclusterconfiguration rollback
		echo
		echo "Cluster [${CLUSTERNAME}] and all associated configuration have been deleted."
		echo
		cleanup-and-exit
	fi
}
						

######################################################################################################
##########  If this were a different programming language, you would call this a "main()".... ########
######################################################################################################

if [ "$1" == "version" ]
then
	echo
	echo "YAKKO version::${YAKKOVERSION} (${YAKKODATE})"
	echo
	echo "Copyright (C) 2020 - Daniel Cifuentes"
    	echo "This program comes with ABSOLUTELY NO WARRANTY."
    	echo "This is free software, and you are welcome to redistribute it"
    	echo "under certain conditions" 
	echo
	echo "https://github.com/ozchamo/YAKKO"
	echo
	echo "You can contact me through GitHub - post a Comment!"
	echo

	cleanup-and-exit
fi

if [ "$1" == "backup" ]
then
	# This is action 0, the developer wants to make a backup
	# There will be no cluster built, nothing
	yakko-backup $*
fi

# Here comes the colorful YAKKO header!
clear -x
print-in-colour ${YAKKOTEXTCOLOR} ${SEPARATIONLINE}
echo
print-in-colour ${YAKKOTEXTCOLOR} ' YAKKO: Yet Another KVM Konfigurator for Openshift'
print-in-colour ${YAKKOTEXTCOLOR} ${SEPARATIONLINE}
echo

if [ $(whoami) != 'root' ]
then 
	echo "ATTENTION: You must be user <root> to run ${YAKKONAME}"
	echo
	cleanup-and-exit
fi

CALLINGDIRECTORY=$(dirname $(realpath $0))

if [ ! -e "${CALLINGDIRECTORY}/.yakkohome" ]
then
	while [ 1 ]
	do
		# This is not even installed!
		echo
		echo "YAKKO is not installed in [${CALLINGDIRECTORY}]."
		echo -n "Enter the directory where you want to install ${YAKKONAME} [/YAKKO]: "
		read RESPONSE

		if [ -z "${RESPONSE}" ]
		then
			RESPONSE=/YAKKO
		fi

		mkdir ${RESPONSE} > /dev/null 2>&1
		RESULT=$?

		[ $RESULT -ne 0 ] && {

			if [ $RESULT -eq 1 ] 
			then
				# The directory already exists
				if [ $(ls -la ${RESPONSE} | wc -l) -gt 3  ] 
				then
					# And - it has files in it.
					echo
					echo  "Directory [$RESPONSE] already exists and contains files. "
					ask-user "Continue installing ${YAKKONAME} in this directory" "N" noauto
					[ $? -eq 1 ] && continue || break
				else
					# It's empty so we can continue
					break
				fi
			fi

			echo "Could not create directory [${RESPONSE}]. Try again."
			echo
			continue
		}

		break
	done

	cp $0 ${RESPONSE}
	check-for-error-and-exit $? "Could not copy ${YAKKONAME} to ${RESPONSE}"
	chmod +x ${RESPONSE}/${YAKKONAME}
	touch ${RESPONSE}/.yakkohome
	check-for-error-and-exit $? "Could not create installer stub in ${RESPONSE}"

	echo
	echo "${YAKKONAME} is now installed. Run again from directory [${RESPONSE}] to continue!"
	echo
	cleanup-and-exit
fi

# We define a set of key config variables and files now that we know where we are running from
YAKKOSETUPDIR=${CALLINGDIRECTORY}
IMAGEREPO=${YAKKOSETUPDIR}/images # The webserver will serve from here. oc and openshift-install are here already
CLUSTERCONFIGFILE=${YAKKOSETUPDIR}/.clusterconfig # Filename where all defaults for the cluster you are building are kept
PULLSECRETFILE=${YAKKOSETUPDIR}/.pullsecret
LASTBUILDCONFIG=${YAKKOSETUPDIR}/.lastyakkobuild
YAKKODEFAULTS=${YAKKOSETUPDIR}/.yakkodefaults # Filename where all defaults for YAKKO are kept

cd ${YAKKOSETUPDIR} >/dev/null 2>&1 # Just change to the directory of action from hereon

# We load YAKKO defaults whether they exist... or not.
source ${YAKKODEFAULTS} > /dev/null 2>&1

# HERE IT ALL BEGINS
# This is the last code group - a cluster config file exists or it doesn't

# if the user passed a parameter, let's capture it here... it could be "infra" or "ops"
YAKKOCALLOPTION=$1

if [ ! -r ${CLUSTERCONFIGFILE} ]
then
	# Make sure you don't launch it twice
	check-if-yakko-running

	if [ ! -z "${YAKKOCALLOPTION}" ] 
	then
		# There is no cluster, the only $1 option is to rebuild
		if [ "${YAKKOCALLOPTION}" == "rebuildcluster" ] 
		then
			if [ -f "${LASTBUILDCONFIG}" ]
			then
				YAKKOREBUILD=1
			else
				echo
				echo "You can't rebuild a prior cluster config since there is no known configuration stored"
				echo
				cleanup-and-exit
			fi
		else
			echo
			echo "No cluster is configured. To begin, just run \"${YAKKONAME}\"." 
			echo
			cleanup-and-exit
		fi

	fi

	process-stage-gatherclusterconfiguration progress
	yakko-process-stages progress

else
	# We know we are root, but are we logged in as the administrator into the OpenShift cluster
	source ${CLUSTERCONFIGFILE} # Load config variables that this script accumulates

	# Check the cluster yakko version vs the script yakko version
	if [ "$BUILTWITHYAKKOVERSION" != "$YAKKOVERSION" ]
	then
		echo
		echo "ALERT: This cluster was built using YAKKO version $BUILTWITHYAKKOVERSION."
		echo "       You are using a different YAKKO version - $YAKKOVERSION."
		echo
		echo "VISIT: https://github.com/ozchamo/YAKKO"
		echo
		print-in-colour ${YAKKOTEXTCOLOR}  "<Press any key to continue>"
		read CONTINUE
		echo
	fi


	# OK - the user wants to complete back out
	if [ "${YAKKOCALLOPTION}" == infra -a "$2" == deletecluster ]
	then
		yakko-infra-operations deletecluster $3
	fi
	if [ "${YAKKOCALLOPTION}" == deletecluster  ]
	then
		yakko-infra-operations deletecluster $2
	fi

	# V1.1 - restartservices gets a free pass
	if [ "${YAKKOCALLOPTION}" == infra -a "$2" == restartservices ]
	then
		yakko-infra-operations restartservices
	fi
	
	# $CLUSTERCOMPLETE is defined if THERE IS a cluster configured
	if [ ! -z "${CLUSTERCOMPLETE}" ] 
	then

		# We first check to see if the cluster is powered up - and void hassle
		check-cluster-state 0 power
		if [ $? -eq 4 ]
		then

			# When the cluster is shutdown, you can start it or DELETE it!

			if [[ ( "${YAKKOCALLOPTION}" == infra &&  "$2" == startcluster ) || "${YAKKOCALLOPTION}" == startcluster ]]
			then	
				yakko-infra-operations startcluster
			fi

			echo
			echo "The cluster is shutdown. Call 'yakko infra startcluster' to start it up!"
			echo
			cleanup-and-exit
		fi

		if [[ ( "${YAKKOCALLOPTION}" == infra &&  "$2" == stopcluster ) || "${YAKKOCALLOPTION}" == stopcluster ]]
		then	
			yakko-infra-operations stopcluster
			cleanup-and-exit
		fi


		if [ $# -eq 0 ] # parameters go here when there is a cluster - see above and (backup: for developers)
		then
			check-cluster-state 1  # yakko is called on an existing cluster - check it!
		fi

		if [ $YAKKOCALLOPTION == "infra" ]
		then
			shift # we get rid of "infra"
			yakko-infra-operations $* # always exits
		fi

		if [ $YAKKOCALLOPTION == "ops" ]
		then
			shift # we get rid of "ops"
			yakko-ops-operations $* # always exits
		fi

		echo "ERROR: Invalid argument passed [$YAKKOCALLOPTION]. "
		echo
		echo "USAGE: $YAKKONAME [ops <OPTION> [params] | infra <OPTION> [params]]"
		echo 
	else
		# This cluster is NOT OPERATIONAL - it's not technically a cluster at this point

		echo "There is no fully configured/operational OpenShift cluster"
		echo

		ask-user "Continue configuring cluster [${CLUSTERNAME}]" "Y" noauto
		if [ $? -eq 0 ]
		then
			process-stage-continue-clusterconfiguration progress
			yakko-process-stages progress
		else
			# Since there is no cluster, offer to delete
			ask-user "Delete existing configuration progress for [${CLUSTERNAME}]" "Y" noauto
			if [ $? -eq 0 ]
			then
				# In case there is any doubt, this clears, it - all must go!
				DELETECLUSTERNAME=${CLUSTERNAME}
				yakko-process-stages rollback
			fi
		fi
	fi
fi

####################################################################################
#####################                 YAKKO END!             #######################
####################################################################################
