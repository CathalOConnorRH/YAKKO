#!/bin/bash
#set -x

###########################################################################
# YAKKO - Yet another KVM Konfigurator for OpenShift
# AUTHOR: Daniel Cifuentes
# 
# A COVID Pandemic Confinement project - Circa 09/2020 
# First version was tried on 4.5 
# Reverted to OCP 4.3 try single node, which is not supported in 4.4+
###########################################################################

# Inspirational documentation for this:
# https://github.com/eitchugo/openshift-libvirt/blob/master/OpenShift_4_libvirt_install_1_master.md

##########################################################################
# BACKLOG:
#
# - use chrony? 
#   20/05/2021 verified that in OCP 4.7, master nodes already have /etc/chrony.conf
#   configured as indicated in https://docs.openshift.com/container-platform/4.7/installing/install_config/installing-customizing.html#installation-special-config-chrony_installing-customizing
#
# - add timer in case addnode fails
# 
# COMPLEX:
# - Work on non-virtual network. That may be a project for the next pandemic
##########################################################################

######## THESE CAN BE USER CONFIGURABLE FOR FURTHER TESTING.At your own risk.
MASTERNODECOUNT=3  # Unless instructed otherwise, OCP 4.8+
MASTERVCPUS=4      # Recommended 4
WORKERVCPUS=2      # Recommended 2
MASTERDISKSIZE=30  # Disk image size for master, GB
WORKERDISKSIZE=30  # Disk image size for worker, GB
MAXNODEVCPUS=4     # Max number of allowable CPUs for a worker node
MAXWORKERNODES=5   # Max number of worker nodes allowed at cluster BUILD time, after that, no limit 
REDUCEPROMETHEUS=Y # Prometheus pod RAM can be reduced, which makes sense, change to N if not desired. 
                   # You can change this with MANUAL build too.
 
# THESE CAN BE CHANGED INTERACTIVELY #####################################
MASTERRAMSIZE=16000 # Recommended 8192. 6000 not enough
WORKERRAMSIZE=6000 # Recommended ... 2048!? Worked well with 5Gi. Setting up as 8 to do some real work
##########################################################################

# The BASEMACADDRESS is missing the last two entries/hexes. The second to last is calculated on
# the last number of the BASEMACNETWORK, in case two clusters run on the same box, to prevent 
# virtual network confusion, even if perhaps... it may work without conflict. Original code had
# this number as 52:54:00:4a:66 but now the last hex number will be the 3 network digit i.e. 140 which is "8c"
COREMACADDRESS="52:54:00:4a"
PROXYADDRESS=1  # So that the overall "proxy" to the cluster is BASENETWORK.PROXY e.g. 192.168.140.1
BASENETWORK="192.168.140"

# File and directory variables used throughout
YAKKONAME=yakko   # In case we want to change the name of the script
OCPWGETTMP=/tmp/ocpsetupwget.tmp
OCPVMDISKDIR=/var/lib/libvirt/images
CLUSTERDOMAIN=localdomain  
BACKUPDEVICES="/mnt/NFS/YAKKO-BACKUPS /run/media/daniel/YAKKO-USB"

# Cluster build progression variables
YAKKOSTAGE=0
STAGEPROGRESS=0
YAKKOREBUILD=0 
AUTOSETUP=0 # 1 is Auto, 0 is manual

# Some parameter options
YAKKOINFRAOPTIONS=" startcluster / stopcluster / addnode / deletenode / nodelogs / sshtonode / openaccess / deletecluster "
YAKKOCLUSTEROPTIONS=" htpasswd / useradd / userdelete / mastersched / nodelabel / localregistry / ingresscert / yakkotest "

# Decorations
SEPARATIONLINE="__________________________________________________________________________"


################ A FEW INITIALISATION FUNCTIONS ################################################

populate-clusterconfigfile() {
	# CLUSTERCONFIGFILE CREATION
	# Populate the config file with some references for future calls
	{
		echo "CLUSTERNAME=${CLUSTERNAME}" 
		echo "CLUSTERFQDN=${CLUSTERFQDN}"
		echo "CLUSTERWEBURL=${CLUSTERWEBURL}"
		echo "CLUSTERAPIURL=${CLUSTERAPIURL}"
		echo "YAKKOSTAGE=0"
		echo "CLUSTERSETUPDIR=${CLUSTERSETUPDIR}" 
		echo "NETWORKNAME=${NETWORKNAME}" 
		echo "OCPGETCLIENTVERSION=${OCPGETCLIENTVERSION}"
		echo "NETWORKXML=$CLUSTERSETUPDIR/${NETWORKNAME}.xml"
		echo "NETWORKADDRESSSLOT=20"
		echo "NODECOUNT=0"
		echo "OCPSSHKEY=${OCPSSHKEY}"
		echo "HAPROXYCONFIGFILE=${HAPROXYCONFIGFILE}"
		
	} > ${CLUSTERCONFIGFILE}

	source ${CLUSTERCONFIGFILE}
}

populate-yakkodefaults() {
  
	{
		echo "CLUSTERNAME=${CLUSTERNAME}"
		echo "CLUSTERDOMAIN=${CLUSTERDOMAIN}"
		echo "OCPVMDISKDIR=${OCPVMDISKDIR}"
		echo "MASTERNODECOUNT=${MASTERNODECOUNT}"
		echo "WORKERNODECOUNT=${WORKERNODECOUNT}"
		echo "CLUSTERPROXY=${CLUSTERPROXY}"
		echo "WEBSERVERIP=${WEBSERVERIP}"
		echo "WEBSERVERPORT=${WEBSERVERPORT}"
		echo "WEBSERVERURL=http://${WEBSERVERIP}:${WEBSERVERPORT}"
	
		# NETWORK CONFIGURATION
		echo "BASEMACADDRESS=${BASEMACADDRESS}"
		echo "BASENETWORK=${BASENETWORK}"
		echo "DNSMASQCONFIGFILE=${DNSMASQCONFIGFILE}"
		echo "YAKKOHOSTIP=${YAKKOHOSTIP}"

		# This will be used for creating nodes later on so that any new nodes start at $NETWORKADDRESSSLOT
		# Note that bootstrap and masters have fixed numbers for IP and MAC
		# 52:54:00 is KVM/QEMU default    4A:66:00 is a transliteration of YAKKO ;)
		# All worker nodes will begin with MAC and IP $NETWORKADDRESSSLOT
		echo "NETWORKADDRESSSLOT=20"
		echo "BOOTSTRAPMAC=${BASEMACADDRESS}:09"
		echo "MASTER0MAC=${BASEMACADDRESS}:10"
		echo "MASTER1MAC=${BASEMACADDRESS}:11"
		echo "MASTER2MAC=${BASEMACADDRESS}:12"
		echo "BOOTSTRAPIP=${BASENETWORK}.9"
		echo "MASTER0IP=${BASENETWORK}.10"
		echo "MASTER1IP=${BASENETWORK}.11"
		echo "MASTER2IP=${BASENETWORK}.12"

	} > ${YAKKODEFAULTS}

	source ${YAKKODEFAULTS}

}

################ A FEW REUSABLE FUNCTIONS ################################################


print-in-green() {
        tput setaf 2;tput bold
	echo "$*"
        tput sgr0
}


print-time-elapsed() {

	TIMEELAPSEDSECS=$(( $SECONDS - $TIMESTART))
	TIMEELAPSEDMINS=$(( $TIMEELAPSEDSECS / 60 ))

	print-in-green "Time elapsed: " ${TIMEELAPSEDMINS} mins $(( ${TIMEELAPSEDSECS} - (${TIMEELAPSEDMINS} * 60 ) )) secs

}


ask-user() {

        # $1 is the string to display
	# $2 is the default if user presses <ENTER>
        # $3 as "noauto" ignores the AUTOSETUP flag
        DIALOGUETEXT=$1
	DEFAULTRESPONSE=$2
        NOAUTO=$3

	# We are within a stage, so we need to setup a trap to rollback
	[ ! -z "${CURRENTSTAGE}" ] && trap "echo; echo 'Input interrupted. Aborting.'; ${CURRENTSTAGE} rollback; echo; exit" SIGINT

	if [ $AUTOSETUP -eq 1 -a "$NOAUTO" == ""  ]
	then 
		# if in AUTO mode return DEFAULTRESPONSE
                if [ "$DEFAULTRESPONSE" == "y" -o "$DEFAULTRESPONSE" == "Y" ]
                then
                        return 0
                elif [ "$DEFAULTRESPONSE" == "n" -o "$DEFAULTRESPONSE" == "N" ]
                then
                        return 1 # 1 = false!
		fi
	fi

	# We use AURESPONSE as "Ask User Response" - because RESPONSE is global :(
 	while [ 1 ]
        do
                echo -n "$DIALOGUETEXT - proceed (y/n) [$DEFAULTRESPONSE]? "
                read AURESPONSE

		[ -z "${AURESPONSE}" ] && AURESPONSE=${DEFAULTRESPONSE} 

                if [ "$AURESPONSE" == "y" -o "$AURESPONSE" == "Y" ]
                then
                        return 0
                elif [ "$AURESPONSE" == "n" -o "$AURESPONSE" == "N" ]
                then
                        return 1 # 1 = false!
                else
                        echo "Invalid reponse [$AURESPONSE]."
                fi
        done
}


check-for-error-and-exit() {
	# Something bad got caught somewhere - write this out and abort
	# $1 is the error code passed (0 is good)
	# $2 is a string to report

	# There is no error found
	[ "$1" -eq 0 ] && return

	# Else... Doom!
	echo
	echo "ERROR: $2. Exiting."
	echo

	if [ ! -z "${CURRENTSTAGE}" ]
	then
		#We are within a stage so we rollback
		ask-user "Rollback steps of this stage (y) or leave for debugging (n)?" "Y" noauto
		[ $? -eq 0 ] && ${CURRENTSTAGE} rollback 
	fi
	echo
	exit
}


install-package-if-missing() {
	
	# $1 is the package to check for
	PACKAGE=$1

	dnf list installed | grep $PACKAGE > /dev/null 2>&1
	[ $? -ne 0 ] && {
		echo Installing package [$PACKAGE]
		dnf -y install $PACKAGE
		check-for-error-and-exit $? "Failed to install package [$PACKAGE]"
	}
}


get-node-fqdn()
{
	# This is a safety measure...
	# This function should be called as
	# $(get-node-fqdn $NODENAME)
	# it returns a nodename with the FQDN attached

	FQDNNODENAME=$1
	echo ${FQDNNODENAME} | grep ${CLUSTERFQDN} > /dev/null 2>&1
	[ $? -ne 0 ] && FQDNNODENAME=${FQDNNODENAME}.${CLUSTERFQDN}

	echo ${FQDNNODENAME}
}


check-node-name()
{
	# Quick function to check that user is passing valid yakk nodename
	# check-node-name CHECKNODENAME [exit]

	# Return 0 if the VM name belongs to the cluster
	# Return 1 if the VM name does not belong to the cluster
	# Return 2 if the VM name does not exist!

	CHECKNODENAME=$1
	EXITONINVALID=$2

	virsh list --all | grep ${CHECKNODENAME}  > /dev/null 2>&1
	if [ $? -eq 1 ]
	then
		# There is no such nodename
		return 2
	fi

	# If something skips the below check, buy the lotto with the nodename ASCIIs...
	virsh list --all | awk '{print $2}' | grep ${CHECKNODENAME} | grep -E '^master-|^node-|^bootstrap' | grep "${CLUSTERFQDN}"  > /dev/null 2>&1
	if [ $? -eq 0 ]
	then
		# Node name belongs to YAKKO setup
		return 0
	else
		[ "${EXITONINVALID}" == "exit" ] && {
			echo
			echo "Invalid node name [$CHECKNODENAME]. Exiting..."
			echo
			exit
		}
		return 1
	fi
}


delete-kvm-machine()
{
	# This is a safety measure...
	NODETODELETEFQDN=$(get-node-fqdn $1)

	check-node-name $NODETODELETEFQDN
	RESULT=$?

	if [ $RESULT -eq 0 ]
	then
		virsh destroy ${NODETODELETEFQDN} 2>/dev/null #Errors when machine is not running... so what.
		virsh undefine --domain ${NODETODELETEFQDN} --remove-all-storage
	fi

	if [ $RESULT -eq 1 ]
	then
		echo "ERROR: Tried to delete non-cluster KVM machine: [${NODETODELETEFQDN}]"
		#exit
	fi

	# if [ $RESULT -eq 2 ]
	# then
	# echo tried to delete a inexistent VM :)
	# fi
}


advance-stage-progression() {

	# We skip all stages until we get to the one we were in...
	((++STAGEPROGRESS))

	#We'll get a timestamp of the first stage for a final run report
	[ -z "${TIMESTART}" ] && TIMESTART=$SECONDS

	if [ ${STAGEPROGRESS} -lt ${YAKKOSTAGE} ]
	then
		return 0
	else
		echo
		print-in-green ${SEPARATIONLINE}
		echo
		print-in-green "STAGE ${STAGEPROGRESS}: $1 (Time start: $(date +%H:%M%p))"
		echo
	
		# We write the stage we are at so that we can return if desired
		sed -i "/YAKKOSTAGE.*/c\YAKKOSTAGE=${STAGEPROGRESS}" ${CLUSTERCONFIGFILE} 2>/dev/null

		# Since this stage will progress, we capture CTRL-C to rollback 
		# we set it to 0 so that the running advance-stage can call itself back
		trap 'echo; ${FUNCNAME[0]} rollback; echo; exit' SIGINT

		# And we set the CURRENTSTAGE in case we have to rollback from a deeper function, to ease lookup
		# This works because advance-stage-progression CAN ONLY be called within a stage, and at the begining!
		CURRENTSTAGE=${FUNCNAME[1]}

		return 1
	fi
}


rollback-stage-progression() {
	echo
	echo ROLLBACK STAGE: $*
}


get-node-list() {

	# call: get-node-list <all|active> [print]

	if [ $1 == "all" ]
	then
		NODELIST=" $(virsh list --all --name | grep -e "master-" -e "node-" -e "bootstrap") "
	fi

	if [ $1 == "active" ]
	then
		NODELIST=" $(virsh list --name | grep -e "master-" -e "node-" -e "bootstrap") "
	fi

	if [ "$2" == "print" ]
	then
		#we also print the list in columns
		for NODE in ${NODELIST}
		do
			echo ${NODE}
		done
	fi
}

pick-a-node() {

	# Call: pick-a-node <string-to-display-for-chooser-query>
	while [ 1 ]
	do
		echo "Available nodes for this action are:"
		get-node-list active print
		echo
		echo -n "$1: "
		read NODENAME
		[ $? -eq 0 ] && break
	done
}
	

check-cluster-state() {
	# Call: check-cluster-state <0|1> ["api"]
	# if $1 ==  0 don't print state
	# if $1 ==  1 print state AND EXIT
	# if $2 == power just check for the power status of the cluster
	# if $2 is the string "api" then we don't bail if the API server is up as some calls 
	# are looking for this to function, for example if I need a worker node for some
	# operators to come up.
	# Valid calls are:
	# check-cluster-state 1
	# check-cluster-state 0
	# check-cluster-state 0 api

	# Return values are
	# 0 -> All good
	# 1 -> API not good
	# 2 -> Web Console not good
	# 3 -> API and Web Console not good
	# 4 -> Cluster is shutdown!

	PRINTSTATE=$1
	SPECIALQUERY=$2

	# This is only executed at the end of the process or on subsequent calls

	source ${CLUSTERCONFIGFILE}

	MASTERUPCOUNT=$(virsh list --all | grep "master-" | grep "running" | wc -l)

	if [ "${SPECIALQUERY}" == "power"  ]
	then
		if [ ${MASTERUPCOUNT} -eq 0 ]
		then
			return 4 # Special case - the cluster is SHUTDOWN!
		else
			return 0 # The cluster is powered up
		fi
	fi

	# If the web console is available, offer info for it regardless of the output above
	RESULTCONSOLE=1
	wget -O $OCPWGETTMP ${CLUSTERWEBURL} --no-check-certificate > /dev/null 2>&1
	RESULTCONSOLE=$?

	RESULTSERVER=1
	wget -O $OCPWGETTMP ${CLUSTERAPIURL} > /dev/null 2>&1
	RESULTSERVER=$?
	[ $RESULTSERVER -eq 5 ] && RESULTSERVER=0 # SSL errors doesn't mean it's not up

	[ $RESULTCONSOLE -eq 0 -a $RESULTSERVER -eq 0 ] && OCPACCESSSTATUS=0 # All good
	[ $RESULTCONSOLE -eq 0 -a $RESULTSERVER -ne 0 ] && OCPACCESSSTATUS=1 # API not good
	[ $RESULTCONSOLE -ne 0 -a $RESULTSERVER -eq 0 ] && OCPACCESSSTATUS=2 # Web Console not good
	[ $RESULTCONSOLE -ne 0 -a $RESULTSERVER -ne 0 ] && OCPACCESSSTATUS=3 # API and Web Console not good
		
	if [ ${PRINTSTATE} -ne 0 ] 
	then 
		# we are asked to print state
		echo " CLUSTER: ${CLUSTERFQDN}   (Built: $(echo ${CLUSTERCOMPLETE} | awk '{print $4}'))"   
		echo

		if [ $OCPACCESSSTATUS -eq 3 ]
		then 
			if [ ${MASTERUPCOUNT} -eq 0 ]
			then
				echo "All nodes of the cluster are currently powered off."
			else
				echo "ERROR: The cluster does not appear to be accessible or there is no console active yet."
				echo
				echo "You can check the status of the masters by issuing, for example: "
				echo "ssh -i $OCPSSHKEY core@master-0.${CLUSTERFQDN}  journalctl -b -f -u crio.service"
				echo
				echo "or simply: ${YAKKONAME} infra sshtonode master-0"
			fi	
			echo
		else
			ACTIVEMASTERS=$(oc get nodes | grep "master-" | grep " Ready" | wc -l)
			TOTALMASTERS=$(oc get nodes | grep "master-" | wc -l)

			ACTIVENODES=$(oc get nodes | grep "node-" | grep " Ready" | wc -l)
			TOTALNODES=$(oc get nodes | grep "node-" | wc -l)

			ACTIVEOPERATORS=$(oc get co | grep -v AVAILABLE | awk '{print $3}' | grep True | wc -l)
			TOTALOPERATORS=$(oc get co | grep -v AVAILABLE | wc -l)

			echo " Active Masters:   ${ACTIVEMASTERS}/${TOTALMASTERS}"
			echo " Active Nodes:     ${TOTALNODES}/${TOTALNODES} (workers/infra)"
			echo
			echo " Active Operators: ${ACTIVEOPERATORS}/${TOTALOPERATORS}"

			echo
			echo "             state      "
			if [ $OCPACCESSSTATUS -eq 0 ] 
			then
				#echo "The console and API server appear to be operational:"
				echo " Web Console: [ ✔ ]  ${CLUSTERWEBURL}"
                                echo " API Server:  [ ✔ ]  ${CLUSTERAPIURL}"
			elif [ $OCPACCESSSTATUS -eq 1 ]
			then
				#echo "The console appears to be operational, the API server does not:"
				echo " Web Console: [ ✔ ]  ${CLUSTERWEBURL}"
                                echo " API Server:  [ ✘ ]" 
			elif [ $OCPACCESSSTATUS -eq 2 ]
			then
				#echo "The API server appears to be operational, the console does not:"
				echo " Web Console: [ ✘ ]"
                                echo " API Server:  [ ✔ ]  ${CLUSTERAPIURL}"
			fi
			echo

			if [ ! -z "${YAKKOADMIN}" ]
			then
				echo " Administrator: ${YAKKOADMIN}  (Password not available for display)"
			else
				echo " Administrator: kubeadmin"
				echo " Password:      $(cat ${CLUSTERSETUPDIR}/auth/kubeadmin-password)"
			fi

			echo
			echo " - To use OpenShift's 'oc' command --> source ocp-setup-env  (in this shell)"
			echo " - To make infrastructure changes ---> ${YAKKONAME} infra <options>"
			echo " - To make operational changes ------> ${YAKKONAME} ops <options>"
			echo
		fi

		# AND WE EXIT after printing STATUS of the cluster

		# We exit if we are not still building the cluster ;)
		exit
	else
		# We are not being asked to pring anything
		# We manipulate the return value if we are just being asked about the API server
		if [ ${SPECIALQUERY} == "api" -a ${OCPACCESSSTATUS} == 2 ]
		then
			OCPACCESSSTATUS=0
		fi
	fi

	echo

	return ${OCPACCESSSTATUS}
}


build-ocp-node() {

	trap 'echo; ${FUNCNAME[1]} rollback; exit' SIGINT

	#master example is  build-ocp-node master-X 52:00:84:12:34:56 $MASTERVCPUS $MASTERRAMSIZE $MASTERDISKSIZE master.ign

	NODEHOSTNAME=$1 

	# Check if httpd is up - I've hit this before
	systemctl is-active httpd > /dev/null 2>&1
	[ $? -ne 0 ] && {
		systemctl restart httpd
		check-for-error-and-exit $? "Provisioning HTTPD server seems to be inactive - cannot continue building node"
	}

	if [ "$2" == "auto" ]
	then
		# If $1 is not 'auto' it's because the MAC has been passed - for MASTER nodes only
		# If not, we're creating a new WORKER node, this calls for an auto mac and ip address
		NODEMACADDRESS=${BASEMACADDRESS}:${NETWORKADDRESSSLOT}

		# Update the networking tables for KVM
		# This function adds a dhcp entry in the virtual network table by inserting 
		# it in the DHCP scope XML definition and then restarting the network!
 		# <host mac='${NODEMAC}' name='nodename.${CLUSTERFQDN}' ip='${NODEIP}'/>"

		HOSTDHCPENTRY="<host mac=\"${NODEMACADDRESS}\" name=\"${NODEHOSTNAME}.${CLUSTERFQDN}\" ip=\"${BASENETWORK}.${NETWORKADDRESSSLOT}\"/>"
		sed -i "/<\/dhcp>/i\			${HOSTDHCPENTRY}" ${NETWORKXML}

		# Restart the network
		echo "Restarting virtual network"
		virsh net-update ${NETWORKNAME} add-last ip-dhcp-host "${HOSTDHCPENTRY}" --live --config 
                check-for-error-and-exit $? "Could not restart the virtual network"

		# Update the HAproxy and restart it
		echo "Updating and restarting HAproxy"
		sed -i "/addingressrouternode80/a\    server ${NODEHOSTNAME} ${BASENETWORK}.${NETWORKADDRESSSLOT}:80 check inter 1s"  ${HAPROXYCONFIGFILE}
		sed -i "/addingressrouternode443/a\    server ${NODEHOSTNAME} ${BASENETWORK}.${NETWORKADDRESSSLOT}:443 check inter 1s" ${HAPROXYCONFIGFILE}
                systemctl restart haproxy
                check-for-error-and-exit $? "Could not start HA Proxy, the cluster cannot function without this."

		# Update the last mac address used in the CLUSTERCONFIGFILE 
		((NETWORKADDRESSSLOT++))
		sed -i "/NETWORKADDRESSSLOT=/c\NETWORKADDRESSSLOT=${NETWORKADDRESSSLOT}" ${CLUSTERCONFIGFILE}
	else
		NODEMACADDRESS=$2
	fi

	NODEVCPUS=$3
	NODERAMSIZE=$4
	NODEDISKSIZE=$5
	IGNITIONFILE=$6

	echo "Building OCP node: ${NODEHOSTNAME} (MAC Addr: ${NODEMACADDRESS})"

	if [ $(echo ${OCPINSTALLVERSION} | cut -c3 ) -gt 5 ]  # We are on OCP 4.6 or higher
	then
		virt-install \
			--memory ${NODERAMSIZE} \
			--vcpus ${NODEVCPUS} \
			--cpu host \
			--disk path=${OCPVMDISKDIR}/${NODEHOSTNAME}.${CLUSTERFQDN}.qcow2,size=${NODEDISKSIZE},bus=virtio,format=qcow2 \
			--install kernel=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-live-kernel-x86_64,initrd=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-live-initramfs.x86_64.img,kernel_args_overwrite=yes,kernel_args="coreos.inst=yes coreos.inst.install_dev=vda coreos.live.rootfs_url=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-live-rootfs.x86_64.img coreos.inst.image_url=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-metal.x86_64.raw.gz coreos.inst.ignition_url=${WEBSERVERURL}/${IGNITIONFILE} coreos.inst.insecure ip=dhcp rd.neednet=1" \
			--os-type=linux \
			--os-variant=rhel8-unknown \
			--graphics vnc \
			--network network=${NETWORKNAME},mac=${NODEMACADDRESS}  \
			--noautoconsole --wait -1 \
			--name ${NODEHOSTNAME}.${CLUSTERFQDN}
		BUILDOCPNODERESULT=$?
	else
      		virt-install \
	                --memory ${NODERAMSIZE} \
	       	         --vcpus ${NODEVCPUS} \
       		         --cpu host \
       		         --disk path=${OCPVMDISKDIR}/${NODEHOSTNAME}.${CLUSTERFQDN}.qcow2,size=${NODEDISKSIZE},bus=virtio,format=qcow2 \
       		         --install kernel=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-installer-kernel-x86_64,initrd=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-installer-initramfs.x86_64.img,kernel_args_overwrite=yes,kernel_args="coreos.inst=yes coreos.inst.install_dev=vda coreos.inst.image_url=${WEBSERVERURL}/${OCPINSTALLVERSION}/rhcos-metal.x86_64.raw.gz coreos.inst.ignition_url=${WEBSERVERURL}/${IGNITIONFILE} ip=dhcp rd.neednet=1" \
       		         --os-type=linux \
       		         --os-variant=rhel8-unknown \
       		         --graphics vnc \
       		         --network network=${NETWORKNAME},mac=${NODEMACADDRESS}  \
       		         --noautoconsole --wait -1 \
       		         --name ${NODEHOSTNAME}.${CLUSTERFQDN}
		BUILDOCPNODERESULT=$?
	fi

	# We clear any old entries in known hosts so that user sees no nasty security business
	sed -i "/${NODEHOSTNAME}.${CLUSTERFQDN}/d" /root/.ssh/known_hosts > /dev/null 2>&1

	return $BUILDOCPNODERESULT
}


approve-csrs-normal() {

	# running oc here is a little trickier as this gets forked off, so we test for it before
	[ -x ${OCPINSTALLSOURCE}/oc ] 
	check-for-error-and-exit $? "Cannot process CSRs as this stage cannot execute command ${OCPINSTALLSOURCE}/oc"

	# This runs in the backgound approving certificates as they come...
	{
		trap "echo; echo 'CSR Approvals (oc get csr) stopped...'; exit" SIGTERM

		while [ 1 ] 
		do
			${OCPINSTALLSOURCE}/oc get csr 2>/dev/null | grep Pending | awk '{ print $1 }' | xargs ${OCPINSTALLSOURCE}/oc adm certificate approve > /dev/null 2>&1
			#check-for-error-and-exit $? "Could not retrieve CSRs"
			sleep 10
		done
	} &

	return $!
}


yakko-backup() {

	# A small developer backdoor...
	# Too lazy to push to git all the time
	# $2 creates a message that accompanies the backup... Like commit -m ;)

	BACKUPFILE=${YAKKONAME}.$(date +%Y%m%d.%H%M)
	BACKUPMSG="$*"

	for YBD in ${BACKUPDEVICES}
	do
		if [ ! -d "$YBD" ]
		then
			mkdir /YAKKO-BACKUPS >/dev/null
			cp $0 /YAKKO-BACKUPS/${BACKUPFILE}
			echo
			echo
			echo "ERROR: [$YBD] cannot be written to for backup."
			echo "NOTE: A backup has been made in root directory (/YAKKO-BACKUPS)"
			echo
			break
		fi
			
		cp $0 $YBD/${BACKUPFILE}
		rm $YBD/${YAKKONAME}
		cp $0 $YBD/${YAKKONAME} # This will always be the latest. ln does not work on VFAT ;)
		if [ ! -z "$BACKUPMSG" ]
		then
			echo $BACKUPMSG > $YBD/${BACKUPFILE}.txt
		fi
	done

	echo "Backed up current ${YAKKONAME} as ${BACKUPFILE}"
	echo
	exit
}


yakko-infra-operations() {

	# We're here bacause 'yakko infra' was invoked

	# $1 is an op listed in $YAKKOINFRAOPTIONS
	# YAKKOINFRAOPTIONS is defined at the top with the list of valid ops on an existing cluster	

	OPTION=$1
	shift

	echo "${YAKKOINFRAOPTIONS}" | grep " ${OPTION} " > /dev/null

	if [ $? -ne 0 -o -z "${OPTION}" ]
	then
		# Catchall for any other passed parameted at this point
		echo "USAGE: ${YAKKONAME} infra <OPTION> [parameters]" 
		echo
		echo "OPTION is one of:"
		echo "    - startcluster  -> start up an existing cluster"
		echo "    - stopcluster   -> shutdown an existing cluster"
		echo "    - addnode       -> grow the cluster compute capacity by adding a new compute/infra node"
		echo "    - deletenode    -> remove a running node from the cluster"
		echo "    - nodelogs      -> display the logs of a particular node"
		echo "    - sshtonode     -> provide terminal access to an individual cluster node"
		echo "    - openaccess    -> enable OpenShift access by other clients in your network"
		echo "    - deletecluster -> delete entire cluster and all infrastructure"
		echo
		exit
	fi

	if [ ${OPTION} == "startcluster" ]
	then
		#infrastartcluster

		# Sometimes, HA Proxy may not be running...
		echo "(Re)starting HA Proxy..."
		echo
		systemctl restart haproxy
		check-for-error-and-exit $? "Could not start HA Proxy, the cluster cannot function without this."
		
		if [ ! -z "$1" ]
		then
			# Surely the user knows what he's doing...
			NODENAME=$1
       	 		echo "Starting up: ${NODENAME}"
       	 		virsh start ${NODENAME}.${CLUSTERFQDN}
		else
			get-node-list all
			for NODENAME in ${NODELIST}
			do
       	 			echo "Starting up: ${NODENAME}"
       	 			virsh start ${NODENAME}
				sleep 1
			done
		fi
	fi

	if [ ${OPTION} == "stopcluster" ]
	then
		#infrastopcluster

		get-node-list active
		for NODENAME in ${NODELIST}
		do
			echo "Shutting down: ${NODENAME}"
			ssh -i ${OCPSSHKEY} -o "StrictHostKeyChecking no" core@${NODENAME} sudo shutdown -h 1
			echo
		done
	fi

	if [ "${OPTION}" == "addnode" ]
	then
		# infraaddnode

		echo
                echo ">>> ADD A NEW WORKER NODE  <<<"
		
		check-cluster-state 0 api
		check-for-error-and-exit $? "Cluster is not fully operational for this operation"

		echo "NOTE: YAKKO will NOT TEST for capacity to handle this request, proceed with caution"
		echo

		WORKERNODECOUNT=1
		if [ ! -z "$1" -a ! -z "$2" -a ! -z "$3" ]
		then
			# Automation: 
			AUTOSETUP=1
			WORKERNODECOUNT=$1
			WORKERVCPUS=$2
			WORKERRAMSIZE=$3


			if [ $WORKERRAMSIZE -lt 2560 -o $WORKERRAMSIZE -gt 16384 ]
			then
				echo
				echo "ERROR: RAM size needs to be between 2560 and 16384 MB"
				echo
				exit
			fi
		else

			# For now we will use the stock configuration, add query for RAM and CPU?
			while [ 1 ]
       	         	do
       	         		echo -n "How many cores should be allocated to this node [${WORKERVCPUS}]: "
				read VALUE
				if [ ! -z "$VALUE" ]
				then
					NUMBERRE='^[0-9]+$'
					if ! [[ $VALUE =~ $NUMBERRE ]] ; then
						echo "Error: Not a number. Try again..."
						continue
					elif [ $VALUE -gt ${MAXNODEVCPUS} ]
					then
						echo "Error: Cannot assign more than ${MAXNODEVCPUS}"
						continue
					elif [ $VALUE -eq 0 ]
					then
						echo "Error: Cannot assign ZERO CPUs"
						continue
					else
						WORKERVCPUS=$VALUE
					fi
				fi
				break
			done
			echo
	
			while [ 1 ]
			do
				echo -n "How much RAM (MiB) should be allocated to this node (2560-16384MiB) [${WORKERRAMSIZE}]: "
				read VALUE
				if [ ! -z "$VALUE" ]
				then
					NUMBERRE='^[0-9]+$'
					if ! [[ $VALUE =~ $NUMBERRE ]] ; then
						echo "Error: Not a number. Try again..."
						continue
					else
						if [ $VALUE -lt 2560 -o $VALUE -gt 16384 ]
						then
							echo "RAM size needs to be between 2560 and 16384 MB"
							continue
						else
							WORKERRAMSIZE=$VALUE
						fi
					fi
				fi
				break
			done
		fi

		YAKKOSTAGE=0 # This is to artificially use the process-stage framework
		process-stage-configureocpworkernodes progress

		approve-csrs-normal
		CSRAPPROVALPID=$?

		trap "echo;echo \"Node [${NEWNODENAME}]  has not joined the cluster - deleting...\"; delete-kvm-machine ${NEWNODENAME}; exit" SIGINT

		echo
		echo "Node(s) ready to begin integration into the cluster. This will take a few minutes..."
		echo "To observe node status, run 'oc get nodes' on another terminal."
		echo

		# NEWNODELIST was populated during process-stage-configureocpworkernodes
		while [ ! -z "${NEWNODELIST}" ]
		do 
			for EACHNODE in ${NEWNODELIST}
			do
				oc get node ${EACHNODE} 2>/dev/null  | grep -v NAME | grep -v "NotReady" | grep Ready  >/dev/null 2>&1
				if [ $? -eq 0 ]
				then 
					echo "Node (${EACHNODE}) has been added to the cluster and is in READY state "
					echo
					NEWNODELIST=$(echo ${NEWNODELIST} | sed -e "s/\ *${EACHNODE}//")
				fi
				sleep 10
			done
		done 

		kill -s SIGTERM $CSRAPPROVALPID > /dev/null 2>&1

		print-time-elapsed
		echo
	fi

	if [ "${OPTION}" == "deletenode" ]
	then
		# infradeletenode

		echo
                echo ">>> DELETE NODE FROM THE CLUSTER  <<<"

		check-cluster-state 0 api
		check-for-error-and-exit $? "Cluster is not fully operational for this operation"

		echo "Deleting a node may cause unintended consequences and prevent some workloads from"
		echo "restarting, depending on their dependencies and the resources left in the cluster"
		echo "Use at your own risk!"
		echo

		if [ ! -z "$1" ]
		then
			# Here's hoping the user knows what he's doing
			NODENAME=$1

			echo "Deleting node [${NODENAME}]"
			echo

			oc get nodes | awk '{print $1}' | grep "^${NODENAME}$"
                        [ $? -ne 0 ] && {
				echo
                        	echo "Invalid node name [${NODENAME}]. Exiting..."
				echo
				exit
			}
		else

			CURRENTNODES=$(oc get nodes | awk '{print $1}' | grep "^node-")
		
			if [ -z "${CURRENTNODES}" ]
			then
				echo "There are no worker/infra nodes defined, nothing to delete!"
				echo
				exit
			fi

			while [ 1 ]
			do
				echo "The following nodes are available for deletion: "
				for EACHNODE in ${CURRENTNODES}
				do
					echo ${EACHNODE}
				done
				echo
	
				echo -n "Enter the name of the node you want to delete from the cluster: "
				read NODENAME
	
				oc get nodes | awk '{print $1}' | grep "^${NODENAME}$"
				[ $? -eq 0 ] && break
	
				echo "Invalid node name."
			done
		fi

		# Drain the node...
		oc adm drain ${NODENAME} --force=true --ignore-daemonsets
		oc delete node ${NODENAME}

		# Delete the VM
		delete-kvm-machine ${NODENAME}

		# Update the virtual network
		echo "Restarting virtual network"
		cat ${NETWORKXML} | grep ${NODENAME} > /tmp/dhcp-yakko-line.xml #It's way too hard to pass this as an argument below!
		virsh net-update ${NETWORKNAME} delete ip-dhcp-host /tmp/dhcp-yakko-line.xml --live --config 
                check-for-error-and-exit $? "Could not restart the virtual network"
		rm /tmp/dhcp-yakko-line.xml
		sed -i "/${NODENAME}/d" ${NETWORKXML}

		#and we update the haproxy
		echo
		echo "Updating and restarting HAproxy"
		sed -i "/${NODENAME}/ d" ${HAPROXYCONFIGFILE}
                systemctl restart haproxy
                check-for-error-and-exit $? "Could not start HA Proxy, the cluster cannot function without this."
	fi

	if [ "${OPTION}" == "nodelogs" ]
	then
		#infranodelogs

		if [ ! -z "$1" ]
		then
			# Surely the user knows what he's doing...
			NODENAME=$(get-node-fqdn $1)
			check-node-name $NODENAME exit
		else
			pick-a-node "Select the node name whose logs you want to follow"
		fi

		echo
		echo "Displaying logs for node ["${NODENAME}"] - (CTRL-C to disconnect when done)"
		echo
		ssh -i ${OCPSSHKEY} core@${NODENAME}  journalctl -b -f -u crio.service
	fi

	if [ "${OPTION}" == "sshtonode" ]
	then
		#infrasshtonode

		if [ ! -z "$1" ]
		then
			# Surely the user knows what he's doing...
			NODENAME=$(get-node-fqdn $1)
			check-node-name $NODENAME exit
		else
			pick-a-node "Select the node you want to ssh into"
		fi
		echo
		echo "Establishing SSH session to node ["${NODENAME}"] - (CTRL-D to disconnect when done)"
		echo
		ssh -i ${OCPSSHKEY} -o "StrictHostKeyChecking no" core@${NODENAME}
	fi

	if [ "${OPTION}" == "openaccess" ]
	then
		#infraopenaccess

		echo
		echo ">>> ENABLE OPEN ACCESS TO OPENSHIFT <<<"
		echo

		echo "Enabling \"${OPTION}\" will permit access to your cluster from clients in your environment."
		echo "This is achieved by opening the haproxy configuration in ${HAPROXYCONFIGFILE} and by"
		echo "enabling wildcard DNS in your network configuration to provide access to all sub-domains"
		echo "created by OpenShift/Kubernetes for projects/namespaces."
		echo 
		echo "HOW \"openaccess\" WORKS ON YOUR LAN:"
		echo
		echo "   - After installation, a YAKKO cluster only listens to requests from the YAKKO host"
		echo "     on the KVM virtual network. HAproxy access will be opened to listen to requests "
		echo "     from any host (and not just the YAKKO host) via ports ports 80, 443, 6443 and 22623." 
		echo "     NOTE: You need to verify that these ports are not in use on this host!"  
		echo
		echo "   - For other clients to know of your server, you need to extend a DNS wildcard:"
		echo
		echo "     1) You can use a DNS wildcard lookup facility served from this host *if needed*."
		echo "        For home/lab purposes, DNSMASQ is a great tool with this capability. "
		echo "        YAKKO can deploy a DNS workaround on this server. OR..."
		echo 
		echo "     2) If you choose to use your own DNS facility, you need to add a wildcard pointing"
		echo "        to this host's OCP entrypoint. If you already use DNSmasq, just add this line "
		echo "        to your DNSmasq configuration (be sure to replace the IP address if not correct):"
		echo
		echo "             address=/${CLUSTERFQDN}/${YAKKOHOSTIP}"
		echo

		ANSWER="N"
		if [ "$1" == "" ]
		then
			ask-user "Enable open access to your OCP cluster via HAproxy" "Y" noauto
			ANSWER=$?
		else
			ANSWER=$1
		fi

		if [ "$ANSWER" == "0" -o "$ANSWER" == "Y" -o "$ANSWER" == "y" ] 
		then
			for PORT in 80 443 6443 22623 
			do 
				echo "Changing access for port $PORT"
				sed -i "/    bind ${CLUSTERPROXY}:${PORT}/c\    bind :${PORT}" ${HAPROXYCONFIGFILE}
				sleep 1
			done
			echo Restarting HAPROXY...
			systemctl restart haproxy
                        check-for-error-and-exit $? "Could not start HA Proxy, the cluster cannot function without this."
			echo

			# This is only used when you pass a parameter to openaccess - the idea is to automate...
			[ "$ANSWER" == "Y" -o "$ANSWER" == "y" ] && exit
		else
			echo
			echo "No changes were made. You can only access OpenShift from this server."
			echo
			exit
		fi

		systemctl status dnsmasq >/dev/null 2>&1
		if [ $? -eq 0 ] 
		then 
			echo "It appears that you are using DNSmasq in your system, so YAKKO will not attempt"
			echo "to configure your setup. You may want to use the instructions above."
		else
			echo "If you DO NOT HAVE your own DNS service, you can use this server as a DNSmasq DNS source."
                        echo
                        echo "You have nominated IP address [${YAKKOHOSTIP}] as this server's address on your LAN."
                        echo

			ask-user "Enable DNSmasq services on this server" "N" noauto
			if [ $? -eq 0 ] 
			then
				echo
				echo "Updating dnsmasq.conf at ${DNSMASQCONFIGFILE}"
				sleep 1
				# CAN THIS RUN ON THIS SERVER!
				{
					echo "listen-address=127.0.0.1,${YAKKOHOSTIP}"
					echo "address=/apps.${CLUSTERFQDN}/${YAKKOHOSTIP}"
					echo "address=/api.${CLUSTERFQDN}/${YAKKOHOSTIP}"
					echo "server=/${CLUSTERFQDN}/${CLUSTERPROXY}"
				} > ${DNSMASQCONFIGFILE}
	
				echo "Restarting NetworkManager for updated dnsmasq config"
				systemctl restart NetworkManager
				sleep 2
				check-for-error-and-exit $? "Failed to restart [NetworkManager]!!!" 
	
				echo
				echo "Ready. To test, enable [$YAKKOHOSTIP] as a DNS server in a client and point your"
				echo "web browser on that client to the cluster console at: "
				echo
				echo "    $(${OCPINSTALLSOURCE}/oc whoami --show-console)"
				echo
			else
				echo
				echo "Local DNSmasq server not modified. If you run your own DNSmasq server"
				echo "use the above instructions for configuring your dnsmasq.conf."
				echo
			fi
		fi
	fi

	if [ ${OPTION} == "deletecluster" ]
	then
		# infradeletecluster
		# Danger Will Robinson!

		if  [ "$1" == "${CLUSTERNAME}" ]
		then
			echo "You have requested to DELETE the current cluster: [${CLUSTERNAME}]."
			echo
			echo -n "Please confirm by entering the cluster name again: "
			read DELETECLUSTERNAME
			if [ ${DELETECLUSTERNAME} == ${CLUSTERNAME} ]
			then
				execute-yakko-stages rollback
			else
				echo
				echo "ERROR: incorrect cluser name, delete not confirmed."
			fi
		else
			echo "ALERT: To delete cluster [${CLUSTERNAME}] and all associated ${YAKKONAME} configuration, you also need to pass the clustername" 
			echo "RUN:   $0 infra deletecluster ${CLUSTERNAME}"
			echo
		fi
	fi

	exit

}


yakko-cluster-operations() {

	# This is just nice stuff to have after the install is done
	# we're here because the user called "yakko ops"

	OPTION=$1
	shift 

	echo "${YAKKOCLUSTEROPTIONS}" | grep " ${OPTION} " > /dev/null
	if [ -z "${OPTION}" -o $? -ne 0 ]
	then
		# Catchall for any other passed parameted at this point
		echo "USAGE: ${YAKKONAME} ops <OPTION> [parameters]" 
		echo
		echo "OPTION is one of:"
		echo "    - htpasswd      -> deploy local password access and a new administrator"
		echo "    - useradd       -> add a new user to local password DB"
		echo "    - userdelete    -> delete an existing user from the local password DB"
		echo "    - mastersched   -> enable/disable master scheduling"
		echo "    - nodelabel     -> Change the label of a node between worker <-> infra"
		echo "    - localregistry -> enable a local registry so you can actually use the cluster"
		echo "    - ingresscert   -> install an existing wildcard certificate"
		echo "    - yakkotest     -> deploy the 'yakkotest' app on your cluster, to test the lot!!"
		echo
		exit
	fi

	if [ "${OPTION}" != "yakkotest" ]
	then
		# This cluster is OPERATIONAL (not withstanding the state) 
		oc whoami | grep -e ":admin" -e "${YAKKOADMIN}"  > /dev/null
		AMIKUBEADMIN=$?
		if [ ${AMIKUBEADMIN} != 0 ]
		then
			echo "ATTENTION: You must be an OpenShift administrator to run ${YAKKONAME}"
			echo
			echo "If the kubeadmin user is still available you can login using:"
			echo "   oc login -u kubeadmin -p $(cat ${CLUSTERSETUPDIR}/auth/kubeadmin-password) https://api.${CLUSTERFQDN}:6443"
			echo
			exit
		fi
	fi

	HTPASSWDFILE=/tmp/ocp-htpasswd

	if [ ${OPTION} == "htpasswd" ]
	then
		#opshtpasswd

		echo
		echo ">>> ENABLE ADMIN and LOCAL PASSWORDS IN OPENSHIFT (HTPasswd) <<<"
		echo

		# Need htpasswd from httpd-tools
		install-package-if-missing httpd-tools 

		if [ -z "${YAKKOHTPASSWD}" ]
		then
			if [ -z "$1" ]
			then
				NEWUSER=administrator
				echo "You must enter a new administrator who will be granted cluster-admin role."
				echo -n "Enter a new admin username to add to the HTPasswd provider [administrator]: "
				read NEWUSER
			        [ -z "${NEWUSER}" ] && NEWUSER="administrator"	
			else
				NEWUSER="$1"
			fi

			if [ -z "$2" ]
			then
				echo
				echo -n "Enter password for user [$NEWUSER]: "
				read -s NEWPASSWORD
				echo
				echo -n "Retype password for confirmation: "
				read -s CONFIRMPASSWORD
				echo
				if [ "$NEWPASSWORD" != "$CONFIRMPASSWORD" ]
				then
					echo "Passwords didn't match! Exiting..."
					echo
					exit
				fi
			else
				NEWPASSWORD="$2"
			fi

			{
				echo "apiVersion: config.openshift.io/v1"
				echo "kind: OAuth"
				echo "metadata:"
				echo "  name: cluster"
				echo "spec:"
				echo "  identityProviders:"
				echo "  - name: Local Password"
				echo "    mappingMethod: claim"
				echo "    type: HTPasswd"
				echo "    htpasswd:"
				echo "      fileData:"
				echo "        name: htpass-secret"
			} > /tmp/oauth-config.yaml

			oc apply -f /tmp/oauth-config.yaml
			check-for-error-and-exit $? 'Could not apply OAuth Custom Resource for HTaccess (see /tmp/oauth-config.yaml)' 

			htpasswd -c -B -b ${HTPASSWDFILE} $NEWUSER $NEWPASSWORD
			oc create secret generic htpass-secret --from-file=htpasswd=${HTPASSWDFILE} -n openshift-config
			echo "YAKKOHTPASSWD=1" >> ${CLUSTERCONFIGFILE}
			sleep 3

			oc adm policy add-cluster-role-to-user cluster-admin $NEWUSER
			check-for-error-and-exit $? "Could not enable $NEWUSER as a user." 
			echo
			echo "Added [$NEWUSER] admin user with cluster-admin role successfuly"
			echo
			echo "YAKKOADMIN=${NEWUSER}" >> ${CLUSTERCONFIGFILE}

			if [ -z "$3" ]
			then
				ask-user "Disable 'kubeadmin' account" Y 
				ANSWER=$?
			else
				ANSWER=$3
			fi

			if [ "$ANSWER" -eq "0" -o "$ANSWER" == "Y" -o "$ANSWER" == "y" ]
			then
				echo "Deleting secret for 'kubeadmin' account" 
				oc --user=admin delete secret kubeadmin -n kube-system
				[ $? -eq 0 ] && echo "YAKKOADMIN=${NEWUSER}" >> ${CLUSTERCONFIGFILE}
				echo "Note that the system:admin account is still available"
				echo
			fi
	
		else
			echo "Local passwords have already been enabled."
			echo
		fi
	fi

	if [ ${OPTION} == "useradd" ]
	then
		#opsuseradd

		echo
		echo ">>> ADD A LOCAL USER TO OPENSHIFT <<<"
		echo
		[ "${YAKKOHTPASSWD}" -eq 1 ] 
		check-for-error-and-exit $? "You need to first configure Local Passwords via \"YAKKONAME enable htpasswd\"" 

		if [ -z "$1" ]
		then
			echo -n "Enter the name for a new user to add to the HTPasswd provider: "
			read NEWUSER
		else
			NEWUSER="$1"
		fi
		
		if [ -z "$2" ]
		then
			echo -n "Enter password for user [$NEWUSER]: "
			read -s NEWPASSWORD
			echo
			echo -n "Retype password for confirmation: "
			read -s CONFIRMPASSWORD
			echo
			if [ "$NEWPASSWORD" != "$CONFIRMPASSWORD" ]
			then
				echo "Passwords didn't match! Exiting..."
				echo
				exit
			fi
		else
			NEWPASSWORD=$2
		fi

		oc get secret htpass-secret -n openshift-config -o jsonpath={.data.htpasswd} | base64 -d > ${HTPASSWDFILE}
		htpasswd -Bb ${HTPASSWDFILE} ${NEWUSER} "${NEWPASSWORD}"
		oc patch secret htpass-secret -n openshift-config -p "{\"data\":{\"htpasswd\":\"$(base64 -w0 ${HTPASSWDFILE})\"}}"
		check-for-error-and-exit $? "Could not retrieve existing htpasswd file from the cluster" 

		oc adm policy add-cluster-role-to-user self-provisioner $NEWUSER
		check-for-error-and-exit $? "Could not assign self-provisioner role to $NEWUSER" 

		echo
		echo "Success: added user $1 and assigned self-provisioner role."
		echo "It may take a few moments before you can login."
		echo
	fi

	if [ "${OPTION}" == "userdelete" ]
	then
		#opsuserdelete

		echo
		echo ">>> DELETE AN EXISTING LOCAL USER FROM OPENSHIFT <<<"
		echo
		
		[ "${YAKKOHTPASSWD}" -eq 1 ]
                check-for-error-and-exit $? "There is no local HTPasswd configured, cannot delete anyone yet!"

                ! [ -z "$1" ]
                check-for-error-and-exit $? "you need to also pass a USERNAME for the username to delete"

		DELUSER=$1
		oc get secret htpass-secret -n openshift-config -o jsonpath={.data.htpasswd} | base64 -d > ${HTPASSWDFILE}

		cat ${HTPASSWDFILE} | grep $DELUSER > /dev/null
		if [ $? -eq 0 ]
		then
			htpasswd -D ${HTPASSWDFILE} $DELUSER
			oc patch secret htpass-secret -n openshift-config -p "{\"data\":{\"htpasswd\":\"$(base64 -w0 ${HTPASSWDFILE})\"}}"
			check-for-error-and-exit $? "Could not update password file in OCP, user not deleted"
		else
			echo "User [$DELUSER] not found in OCP, could not delete."	
		fi
		echo
	fi
		
	if [ "${OPTION}" == "localregistry" ]
	then
		#opslocalregistry

		echo
		echo ">>> ENABLE LOCAL REGISTRY IN OPENSHIFT <<<"
		echo

		ANSWER=N
		if [ "$1" == "" ]
		then
			ask-user "Enabling local registry (images will be lost on registry restart)" "Y" noauto
			ANSWER=$?
		else
			ANSWER=$1
		fi

		if [ "$ANSWER" == 0 -o "$ANSWER" == "Y" -o "$ANSWER" == "y" ]
		then
			oc patch configs.imageregistry.operator.openshift.io cluster --type merge --patch '{"spec":{"storage":{"emptyDir":{}}}}'
			oc patch configs.imageregistry.operator.openshift.io cluster --type merge --patch '{"spec":{"managementState":"Managed"}}'
			echo

			LOCALREGISTRY=1
			echo "LOCALREGISTRY=1" >> ${CLUSTERCONFIGFILE}
		else
			echo "Local registry not enabled."
			echo
		fi
		
	fi

	if [ "${OPTION}" == "mastersched" ]
	then
		# opsmastersched

		echo
                echo ">>> CHANGE MASTERS' SCHEDULING STATE  <<<"
                echo

		check-cluster-state 0 api

		echo "This is an important change that may affect the behaviour of your workloads"
		echo "and is simply being provided by YAKKO as a mechanism to change new nodes quickly."
		echo "Use at your own risk!"
		echo

		oc get nodes | grep master-0 | grep worker > /dev/null 2>&1
		if [ $? -eq 0 ] #Masters are schedulable because they read 'worker'
		then
			MASTERSCHEDSTATE=true
			echo "Masters are currently >> SCHEDULABLE <<"
			echo
			if [ $(oc get nodes | grep "node-" | grep -v NotReady | grep Ready | wc -l) -eq 0 ] 
			then
				echo 
				echo "ATTENTION: There are no worker nodes available! Proceed with caution."
				echo
			fi
			ask-user "Change masters to [NOT SCHEDULABLE]" Y noauto
			[ $? -eq 0 ] && NEWMASTERSCHEDSTATE=false
		else
			MASTERSCHEDSTATE=false
			echo "Masters are currently >> NOT SCHEDULABLE <<"
			echo
			ask-user "Change masters to [SCHEDULABLE]" Y noauto
			[ $? -eq 0 ] && NEWMASTERSCHEDSTATE=true
		fi

		if [ ! -z "${NEWMASTERSCHEDSTATE}" ]
		then
			# Little hack...
			export KUBE_EDITOR="sed -i s+mastersSchedulable:\ ${MASTERSCHEDSTATE}+mastersSchedulable:\ ${NEWMASTERSCHEDSTATE}+"

			oc edit schedulers.config.openshift.io cluster
			[ $? -ne 0 ] && echo "This operation was not succssful"
			echo
		fi
	fi

	if [ "${OPTION}" == "nodelabel" ]
	then
		# opsnodelabel
		# This one is for fun, has a cute little hack

		echo
                echo ">>> CHANGE A NODE'S LABEL: WORKER <-> INFRA <<<"
                echo

                check-cluster-state 0 api
                check-for-error-and-exit $? "Cluster is not fully operational for this operation"

                CURRENTNODES=" $(oc get nodes | grep "^node-" | awk '{print $1}') "

                if [ -z "${CURRENTNODES}" ]
                then
                        echo "There are no worker/infra nodes defined, nothing to change!"
                        echo
                        exit
                fi

		echo "This is an important change that may affeect the behaviour of your workloads"
		echo "and is simply being provided by YAKKO as a mechanism to change new nodes quickly."
		echo "Use at your own risk!"
		echo
                echo "The following nodes are available for relabeling: "
		oc get nodes | grep "^node-" | awk '{print $1, $3}'
                echo

                while [ 1 ]
                do

                        echo -n "Enter the name of the node you want to relabel: "
                        read NODENAME
			
			echo ${CURRENTNODES} | grep ${NODENAME} > /dev/null 2>&1
			[ $? -ne 0 ] && {
				echo "Invalid node name"
				echo
				continue
			}
		break
		done

		NODELABEL=$(oc get nodes | grep ${NODENAME}" "| awk '{print $3}')

		if [ ${NODELABEL} == "worker" ]
		then
			NEWNODELABEL="infra"
		else
			NEWNODELABEL="worker"
		fi
		
		# Little hack...
		export KUBE_EDITOR="sed -i s+node-role.kubernetes.io/${NODELABEL}+node-role.kubernetes.io/${NEWNODELABEL}+"

		echo
		ask-user "Change [${NODENAME}] label from [${NODELABEL}] to [${NEWNODELABEL}]" Y noauto
		if [ $? -eq 0 ]
		then
			oc edit node ${NODENAME}
			[ $? -ne 0 ] &&
				echo "This operation was not succssful"
		else
			echo "No changes were made./"
		fi
		echo
	
	fi

	if [ "${OPTION}" == "ingresscert" ]
	then
		# opsingresscert
		echo
		echo ">>> INSTALL AN INGRESS WILDCARD CERTIFICATE <<<"
		echo

		if [ ! -z "$1" ]
		then
			AUTOSETUP=1
			CERTBUNDLEFILE=$1
			CERTBUNDLEPATH=$(dirname $1)

			if [ ! -r ${CERTBUNDLEFILE} ]
			then
				echo "$1 is not a valid certificate bundle - check file and permissions!"
				echo
				exit
			fi
		else

			echo
			echo "To proceed you will need to acquire a wildcard certificate for apps.${CLUSTERFQDN}"
			echo
			ask-user "You will need to specify the path to an existing certificate bundle" Y auto

			if [ $? -eq 1 ]
			then
				echo "To obtain a certificate from this server using the free 'letsencrypt.com' service"
				echo "you will need to install certbot, e.g. "
				echo "	dnf install certbot"
				echo
				echo "and issue a request like:"
				echo "	certbot -d '*.apps.${CLUSTERFQDN}' --manual --preferred-challenges dns certonly"
				echo
				echo "Note that for this you must own DNS admin rights to ${CLUSTERDOMAIN}"
				echo "to add DNS TXT Record when prompted."
				echo 
				echo "The following site can help:"
				echo "	https://stephennimmo.com/securing-openshift-ingress-with-lets-encrypt/"
				echo
				exit
			fi

			CERTBUNDLEPATH=/etc/letsencrypt/live/apps.${CLUSTERFQDN}
			CERTBUNDLEFILE=${CERTBUNDLEPATH}/fullchain.pem

			# WE check in advance if the cert is where certbot puts it...
			if [ ! -r ${CERTBUNDLEFILE} ]
			then
				CERTBUNDLEFILE=""
			fi

			while [ 1 ]
			do
				if [ -z "${CERTBUNDLEFILE}" ]
				then
					echo -n "Enter path to certificate bundle: "
				else
					echo "Enter path to certificate bundle [$CERTBUNDLEFILE]: "
				fi
				read CERTBUNDLEALTFILE
	
		       		if [ -z "${CERTBUNDLEALTFILE}" -a ! -z ${CERTBUNDLEFILE} ]
				then 
					# The user accepted the default which has been verified already
					break
				fi

		       		if [ ! -z "${CERTBUNDLEALTFILE}" ]
				then
					if [ -r ${CERTBUNDLEALTFILE} ]
					then
						CERTBUNDLEFILE=${CERTBUNDLEALTFILE}
						break
					else
						echo "Invalid certificate bundle."
						echo
						continue
					fi
				fi

			done
		fi

		if [ -r ${CERTBUNDLEPATH}/privkey.pem ]
		then
			echo "Private key [privkey.pem] found at ${CERTBUNDLEPATH} - continuing..."
		else
			echo "Private key [privkey.pem] was expected at ${CERTBUNDLEPATH} but not found there. Exiting!"
			exit
		fi

		echo

		oc create configmap custom-ca --from-file=ca-bundle.cert=${CERTBUNDLEFILE} -n openshift-config
		oc patch proxy/cluster --type=merge  --patch='{"spec":{"trustedCA":{"name":"custom-ca"}}}'
		check-for-error-and-exit $? "Unable to apply patched config map in / custom-ca!"

		oc create secret tls custom-ca-secret --cert=${CERTBUNDLEFILE} --key=${CERTBUNDLEPATH}/privkey.pem -n openshift-ingress
		oc patch ingresscontroller.operator default \
		       	--type=merge -p '{"spec":{"defaultCertificate": {"name": "custom-ca-secret"}}}' -n openshift-ingress-operator
		check-for-error-and-exit $? "Unable to apply patched private key in!"

		echo

	fi

	if [ "${OPTION}" == "yakkotest" ]
	then
		# opsyakkotest

		echo
                echo ">>> DEPLOY YAKKO TEST ON THE CLUSTER!  <<<"
                echo

		if [ -z "${LOCALREGISTRY}" ]
		then
			echo 
			echo "Cannot deploy YAKKO test app as there is no registry defined."
			echo 'First, run "yakko ops localregistry"'
			echo
			exit
		fi

		oc new-project yakkotest
		check-for-error-and-exit $? "Could not create project 'yakkotest' in OpenShift"
		oc new-app httpd:latest~https://github.com/ozchamo/yakko-test.git --name=yakko
		check-for-error-and-exit $? "could not create new application 'yakko' in OpenShift"
		# Long form: oc new-app --image-stream httpd:latest https://github.com/ozchamo/yakko-test.git --name=yakko
		# Except this does not work because Language Detection is enabled and... it doesn't detect!
		oc expose service yakko --hostname=yakkotest.apps.${CLUSTERFQDN}
		check-for-error-and-exit $? "Could not expose route for 'yakkotest.apps.${CLUSTERFQDN}'"

		echo ${SEPARATIONLINE}
		echo
		echo
		echo "OpenShift will begin building the project"
		echo "Inspect progress by issuing 'oc get pods -n yakkotest'"
		echo
		echo "Once yakkotest is up, point your browser to: http://$(oc get routes | grep yakkotest | awk '{print $2}')"
		echo
	fi
		
	exit
}


###### STAGE PROCESSORS FOLLOW ################################################
# progress is move forwarwd, configure, install
# rollback is move back, undo, delete
###############################################################################


process-stage-libvirt() {

	[ $1 == "progress" ] && {
	
		advance-stage-progression "Libvirt package install/start" 
		# This one is mandatory so there is no && return at the end of the call
		# The thing is, if there is no KVM, there is no hope!

		#VIRTUALISATION IS MANDATORY THE FIRST TIME WE RUN THIS
		systemctl status libvirtd --no-pager > /dev/null 2>&1
		[ $? -ne 0 ] && {
			cat /proc/cpuinfo | egrep "vmx|svm" >/dev/null 2>&1
			check-for-error-and-exit $? "Virtualisation extensions are not enabled in this system!"			

			install-package-if-missing libvirt 
			#install-package-if-missing bridge-utils 
			install-package-if-missing virt-install
			install-package-if-missing qemu-kvm
			install-package-if-missing virt-top
		}
		systemctl enable libvirtd --now > /dev/null 2>&1
		systemctl status libvirtd --no-pager > /dev/null 2>&1
		check-for-error-and-exit $? "Failed to enable [libvirtd]" 

		echo "Libvirt is installed and active"

		# and just in case...
		lsmod | grep kvm >/dev/null
		check-for-error-and-exit $?  "KVM kernel modules are not loaded!"
	}

	# Nothing to rollback
	[ $1 == "rollback" ] && {
		rollback-stage-progression "Libvirt will remain installed"
	}
}


process-stage-pullsecret() {

	[ $1 == "progress" ] && {

		advance-stage-progression "Load pull secret" && return

		[ -r ${PULLSECRETFILE} ] && PULLSECRET=$(cat ${PULLSECRETFILE})

		ask-user "Add a new pull secret" N
		WANTPULLSECRET=$?

		# There is no pull secret on file or user wants a new one now
		if [ -z "${PULLSECRET}" -o ${WANTPULLSECRET} -eq 0 ]
		then
			echo "A new pull secret is required."
		        echo "Please copy/paste pull secret from [ https://cloud.redhat.com/openshift/install/metal/user-provisioned ]:"
		        read PULLSECRET
		        echo $PULLSECRET > ${PULLSECRETFILE}
		fi
	}

	# Nothing to rollback - we don't want to delete the existing pull secret
	[ $1 == "rollback" ] && {
		rollback-stage-progression "Existing Pull Secret will remain in place"
	}
}


process-stage-sshclient() {

	[ $1 == "progress" ] && {

	        advance-stage-progression "SSH key configuration" && return

		ask-user "Create new SSH key for node access" "Y"  && {
			
			#We clear a potential clash for ssh logins in .known_hosts
			sed -i "/bootstrap.${CLUSTERFQDN}/d" /root/.ssh/known_hosts > /dev/null 2>&1
			ssh-keygen -t rsa -b 4096 -N '' -f ${OCPSSHKEY}
		 	check-for-error-and-exit $?  "Failed to create SSH key"
			eval "$(ssh-agent -s)"
			ssh-add ${OCPSSHKEY}
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting ssh key and removing cluster hosts from ssh known hosts..."
		rm -r ${OCPSSHKEY} > /dev/null 2>&1
		rm -r ${OCPSSHKEY}.pub > /dev/null 2>&1

		get-node-list all
		for NODENAME in ${NODELIST}
		do
			sed -i "/${NODENAME}/d" /root/.ssh/known_hosts
		done
	}
}


process-stage-virtualnetwork() {

	[ $1 == "progress" ] && {
	
        	advance-stage-progression "Virtual Network Configuration" && return

		ask-user "Configure Virtual Network" "Y" && {

			NETWORKXML=$CLUSTERSETUPDIR/${NETWORKNAME}.xml
		
			echo Cleaning up network...
			virsh net-destroy ${NETWORKNAME} > /dev/null 2>&1
			virsh net-undefine ${NETWORKNAME} > /dev/null 2>&1
			
			NETWORKTYPE=1 # Query when BRIDGE is supported. Not yet ;)
			echo Only NAT is supported for now
			#if [ $NETWORKTYPE != 1 -a $NETWORKTYPE != 2 ]
			#then
			#	echo -n 'Should this network be 1.NAT or 2.BRIDGE (1 or 2)? '
			#	read NETWORKTYPE
			#fi
		
			if [ $NETWORKTYPE == 1 ] # NAT
			then
				echo "YAKKO will create all infrastructure in the ${BASENETWORK}/24 subnet with preallocated IP addresses:"
				echo Bootstrap: ${BOOTSTRAPIP}	
				echo Masters: ${MASTER0IP} ${MASTER1IP} and ${MASTER2IP}
				echo
		
				{
					echo "<network>" 
					echo "	<name>${NETWORKNAME}</name>"
		
	 				echo "	<forward mode='nat'>"
					echo "		<nat>"
					echo "			<port start='1024' end='65535'/>"
					echo "		</nat>"
					echo "	</forward>"
		
					echo "	<bridge name='virbrocp' stp='on' delay='0'/>"
		
					echo "	<domain name='${CLUSTERFQDN}' localOnly='yes'/>"
					echo "	<dns>"
					echo "		<forwarder domain='apps.${CLUSTERFQDN}' addr='127.0.0.1'/>"
					echo "		<host ip='${CLUSTERPROXY}'>"
					echo "			<hostname>api</hostname>"
					echo "			<hostname>api-int</hostname>"
					echo "		</host>"
					echo "		<host ip='${MASTER0IP}'>"
					echo " 	         	<hostname>etcd-0</hostname>"
					echo " 	         	<hostname>master-0</hostname>"
					echo "		</host>"
					echo "		<host ip='${MASTER1IP}'>"
					echo " 	         	<hostname>etcd-1</hostname>"
					echo " 	         	<hostname>master-1</hostname>"
					echo "		</host>"
					echo "		<host ip='${MASTER2IP}'>"
					echo " 	         	<hostname>etcd-2</hostname>"
					echo " 	         	<hostname>master-2</hostname>"
					echo "		</host>"
		
					# SRV Records are not required from OCP 4.4 onwards... But never mind
		
					echo " 	 	<srv service='etcd-server-ssl' protocol='tcp' domain='${CLUSTERFQDN}' target='etcd-0.${CLUSTERFQDN}' port='2380' priority='0' weight='10'/>"
					echo " 	 	<srv service='etcd-server-ssl' protocol='tcp' domain='${CLUSTERFQDN}' target='etcd-1.${CLUSTERFQDN}' port='2380' priority='0' weight='10'/>"
					echo " 	 	<srv service='etcd-server-ssl' protocol='tcp' domain='${CLUSTERFQDN}' target='etcd-2.${CLUSTERFQDN}' port='2380' priority='0' weight='10'/>"
					echo "	</dns>"
					echo "	<ip address='${CLUSTERPROXY}' netmask='255.255.255.0'>"
	   	 			echo "		<dhcp>"
					echo "			<range start='${BASENETWORK}.5' end='${BASENETWORK}.254'/>"
					echo "			<host mac='${BOOTSTRAPMAC}' name='bootstrap.${CLUSTERFQDN}' ip='${BOOTSTRAPIP}'/>"
					echo " 			<host mac='${MASTER0MAC}' name='master-0.${CLUSTERFQDN}' ip='${MASTER0IP}'/>"
					echo " 			<host mac='${MASTER1MAC}' name='master-1.${CLUSTERFQDN}' ip='${MASTER1IP}'/>"
					echo " 			<host mac='${MASTER2MAC}' name='master-2.${CLUSTERFQDN}' ip='${MASTER2IP}'/>"
					echo "		</dhcp>"
					echo "	</ip>"
					echo "</network>"
		
				} > $NETWORKXML
			fi

			if [ ${NETWORKTYPE} == 2 ] # BRIDGED
			then
				# All virtual machines will have LAN IP Addresses
				echo ONE DAY...
			fi
			
			echo Defining network at $NETWORKXML
			virsh net-define --file $NETWORKXML
			check-for-error-and-exit $? "Defined inactive networks are: $(virsh net-list --inactive)"
			
			echo Setting network to start on boot...
			virsh net-autostart ${NETWORKNAME}
			check-for-error-and-exit $? "Could not configure virtual network for auto-start"
		}
		echo "Re/starting network to ensure it is operational..."
		virsh net-destroy ${NETWORKNAME} 2>/dev/null
		virsh net-start ${NETWORKNAME}
		check-for-error-and-exit $? "Could not start virtual network"
		echo "Virtual network is up"
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting virtual network configuration"
		virsh net-destroy ${NETWORKNAME} > /dev/null 2>&1
		virsh net-undefine ${NETWORKNAME} > /dev/null 2>&1

	}
}


process-stage-dns() {


	[ $1 == "progress" ] && {
	
        	advance-stage-progression "DNS Configuration" && return

		ask-user "Configure DNS for KVM network (dnsmasq/NetworkManager)" "Y" && {

			# Courtesy of Sebastiaan Stoffels - installed from minimal F34 and found this helps
			install-package-if-missing bind-utils

			systemctl status dnsmasq >/dev/null 2>&1
			if [ $? -eq 0 ]
			then
				# DNSMASQ is enabled on this host, we should use this instead of NetworkManager plugin
				# But, this is dangerous, so we have to leave this one to the ADMIN

				echo "YAKKO has detected that you are not using the dnsmasq plugin for NetworkManager"
				echo "and instead you are using standard DNSMASQ."
				echo
				echo "You will need to add these two addresses to your DNSMASQ configuration before continuing"
				echo "upon which ${YAKKONAME} will test the DNS of your system before continuing"
				echo
				echo "	server=/${CLUSTERFQDN}/${CLUSTERPROXY}"
				echo "	address=/apps.${CLUSTERFQDN}/${CLUSTERPROXY}"
				echo
				ask-user "Confirm that DNSMASQ has been configured and restarted" "Y" noauto
				echo
			else
				echo Configuring dnsmask plugin in NETWORKMANAGER
				# CHANGE TO END USER SYSTEM HERE
				cat /etc/NetworkManager/NetworkManager.conf | grep "\[main\]" > /dev/null 2>&1
				[ $? -ne 0 ] && echo '\[main\]' >> /etc/NetworkManager/NetworkManager.conf
	
				cat /etc/NetworkManager/NetworkManager.conf | grep "dns = dnsmasq" > /dev/null 2>&1
				[ $? -ne 0 ] && sed -i.bak '/\[main\]/ a dns = dnsmasq' /etc/NetworkManager/NetworkManager.conf
	
				#rm /etc/NetworkManager/dnsmasq.d/${YAKKONAME}* 2>/dev/null #Deleting old entries
		
				{
					echo "server=/${CLUSTERFQDN}/${CLUSTERPROXY}"
					echo "address=/apps.${CLUSTERFQDN}/${CLUSTERPROXY}"
				} > ${DNSMASQCONFIGFILE}
		
				systemctl restart NetworkManager
				check-for-error-and-exit $? "Could not restart NetworkManager"

				# Trying to see if we can address the systemd-resolved changes in Fedora 33
				cat /etc/resolv.conf | grep "nameserver 127.0.0.53"
				if [ $? -eq 0 ]
				then	
					# CHANGE TO END USER SYSTEM HERE

					# We need to add after [Resolve]
					# DNS=127.0.0.1
					# Domains=~${CLUSTERDOMAIN}
					#to /etc/systemd/resolved.conf
					echo
					echo "ATTENTION: This system is using systemd-resolved. YAKKO needs to add a DNS stub in /etc/systemd/resolved.conf"

					#sed -i.EXT is used to edit file in place while creating a backup with extension EXT - we use yakko here
					cat /etc/systemd/resolved.conf | grep "Domains=~${CLUSTERDOMAIN}" > /dev/null 2>&1
					[ $? -ne 0 ] && sed -i.${YAKKONAME} "/\[Resolve\]/ a Domains=~${CLUSTERDOMAIN}" /etc/systemd/resolved.conf

					cat /etc/systemd/resolved.conf | grep "DNS=127.0.0.1" > /dev/null 2>&1
					[ $? -ne 0 ] && sed -i.${YAKKONAME} "/\[Resolve\]/ a DNS=127.0.0.1" /etc/systemd/resolved.conf

					systemctl restart systemd-resolved.service
					sleep 3 # This sometimes takes a bit to revive
				fi
			fi

			echo
			echo "DNS test - from Virtual Network ${BASENETWORK}.0:"

			host api-int.${CLUSTERFQDN} ${CLUSTERPROXY} | grep "has address"
			check-for-error-and-exit $? "Could not resolve api-int.${CLUSTERFQDN} on ${BASENETWORK}"

			host etcd-0.${CLUSTERFQDN} ${CLUSTERPROXY} | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-0.${CLUSTERFQDN} on ${BASENETWORK}"

			host etcd-1.${CLUSTERFQDN} ${CLUSTERPROXY} | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-1.${CLUSTERFQDN} on ${BASENETWORK}"

			host etcd-2.${CLUSTERFQDN} ${CLUSTERPROXY} | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-2.${CLUSTERFQDN} on ${BASENETWORK}"

			host -t srv _etcd-server-ssl._tcp.${CLUSTERFQDN} ${CLUSTERPROXY}
			check-for-error-and-exit $? "Could not resolve etcd-server-ssl.${CLUSTERFQDN} on ${BASENETWORK}"
				
			echo
			echo "DNS test - from the host:"

			# Note - before Fedora 33 these tests were run with 127.0.0.1
			# Then came systemd.resolved.conf and things needed to be "updated"
			# So now, we need to add to /etc/systemd/resolvd.conf the following
			#	DNS=127.0.0.1
			#	Domains=~${CLUSTERDOMAIN}
			# and... still trying to fix it
 
			host api.${CLUSTERFQDN} 127.0.0.1 | grep "has address"
			check-for-error-and-exit $? "Could not resolve api-int on 127.0.0.1"

			host etcd-0.${CLUSTERFQDN} 127.0.0.1 | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-0 on 127.0.0.1"

			host etcd-1.${CLUSTERFQDN} 127.0.0.1 | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-1 on 127.0.0.1"

			host etcd-2.${CLUSTERFQDN} 127.0.0.1 | grep "has address"
			check-for-error-and-exit $? "Could not resolve etcd-2 on 127.0.0.1"

			host testing.apps.${CLUSTERFQDN} 127.0.0.1
			check-for-error-and-exit $? "Could not resolve testing.apps on 127.0.0.1"
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting DNS configuration and restarting"
		rm ${DNSMASQCONFIGFILE} > /dev/null 2>&1
		# mv /etc/systemd/resolved.conf.${YAKKONAME} /etc/systemd/resolved.conf >/dev/null 2>&1
		echo
		echo "Not rolling back resolved.conf changes. Inspect /etc/systemd/resolved.conf if you want to revert."
		echo "(This in prep to avoid clash with any other running clusters in the box.)"
	}
}

	
process-stage-loadbalancer() {

	[ $1 == "progress" ] && {

        	advance-stage-progression "Configure Load Balancer "  && return

		ask-user "Configure Load Balancer (HA Proxy) for cluster bootstrap and operation" "Y" && {

			install-package-if-missing haproxy
	
			cat /etc/httpd/conf/httpd.conf | grep "^Listen 80" >/dev/null 2>&1
			[ $? -eq 0 ] && {
				echo "ATTENTION: HAPROXY needs to run on port 80. Currently, port 80 is marked for listening by httpd."
				ask-user "Disable port 80 on httpd" "Y" noauto
				if [ $? -eq 0 ]
				then		
					# CHANGE TO END USER SYSTEM HERE
					sed -i "/^Listen 80/c\# Listen 80" /etc/httpd/conf/httpd.conf  2>/dev/null
				else
					echo
					echo "ERROR: Cannot continue until PORT 80 is freed up for HAPROXY. Fix and come back! Exiting..."
					echo
					exit
				fi
			}
	
			#We'll put config files for HAPROXY in here
			mkdir /etc/haproxy/${YAKKONAME} > /dev/null 2>&1

			#HAPROXY still wants to find a config file in the default place
			touch /etc/haproxy/haproxy.cfg

			#but, we can add others, and we do! As a directory, this will make haproxy load any configs in there...
			echo "OPTIONS=\"-f /etc/haproxy/${YAKKONAME}\"" > /etc/sysconfig/haproxy

			echo Creating the HA Proxy Config...
			echo
			
			{
				# SET UP THE PROXY ON THE VIRTUAL NETWORK - FOR THE HOST

				echo "listen ${CLUSTERNAME}-api-server-6443"
				echo "    bind ${CLUSTERPROXY}:6443"
				echo "    mode tcp"
				echo "    balance source"
				echo "    server master-0.${CLUSTERFQDN} ${MASTER0IP}:6443 check inter 1s"
				[ ${MASTERNODECOUNT} -gt 1 ] && {
					echo "    server master-1.${CLUSTERFQDN} ${MASTER1IP}:6443 check inter 1s"
					echo "    server master-2.${CLUSTERFQDN} ${MASTER2IP}:6443 check inter 1s"
				}
				echo "    server bootstrap.${CLUSTERFQDN} ${BOOTSTRAPIP}:6443 check inter 1s"

				echo 
				echo "listen ${CLUSTERNAME}-machine-config-server-22623"
				echo "    bind ${CLUSTERPROXY}:22623"
				echo "    mode tcp"
				echo "    balance source"
				echo "    server master-0.${CLUSTERFQDN} ${MASTER0IP}:22623 check inter 1s"
				[ ${MASTERNODECOUNT} -gt 1 ] && {
					echo "    server master-1.${CLUSTERFQDN} ${MASTER1IP}:22623 check inter 1s"
					echo "    server master-2.${CLUSTERFQDN} ${MASTER2IP}:22623 check inter 1s"
				}
				echo "    server bootstrap.${CLUSTERFQDN} ${BOOTSTRAPIP}:22623 check inter 1s"
				echo 

				echo "listen ${CLUSTERNAME}-ingress-router-80"
				echo "    bind ${CLUSTERPROXY}:80"
				echo "    mode tcp"
				echo "    balance source"
				echo "    server master-0.${CLUSTERFQDN} ${MASTER0IP}:80 check inter 1s"
				[ ${MASTERNODECOUNT} -gt 1 ] && {
					echo "    server master-1.${CLUSTERFQDN} ${MASTER1IP}:80 check inter 1s"
					echo "    server master-2.${CLUSTERFQDN} ${MASTER2IP}:80 check inter 1s"
				}
				echo "    # addingressrouternode80"

				echo 
				echo "listen ${CLUSTERNAME}-ingress-router-443"
				echo "    bind ${CLUSTERPROXY}:443"
				echo "    mode tcp"
				echo "    balance source"
				echo "    server master-0.${CLUSTERFQDN} ${MASTER0IP}:443 check inter 1s"
				echo "    server master-1.${CLUSTERFQDN} ${MASTER1IP}:443 check inter 1s"
				echo "    server master-2.${CLUSTERFQDN} ${MASTER2IP}:443 check inter 1s"
				echo "    # addingressrouternode443"
			} > ${HAPROXYCONFIGFILE}

			setsebool -P haproxy_connect_any 1
			systemctl --now enable haproxy
			check-for-error-and-exit $? "Could not restart haproxy/loadbalancer"
			systemctl status haproxy --no-pager
		
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting and stopping Load Balancer service"
		systemctl stop haproxy
		# We don't want to do this any more - should there be more than one cluster
		# but we are leaving behind the /etc/haproxy/yakko dir...
		# instead, we delete the individual haproxy config for the cluster at hand
		# rm /etc/haproxy/haproxy.cfg > /dev/null 2>&1
		rm ${HAPROXYCONFIGFILE} 2>/dev/null
	}
}


process-stage-downloadocpbinaries() {

	# Too bad. You are running multiple clusters? Download multiple times...

	install-package-if-missing wget

	[ $1 == "progress" ] && {

        	advance-stage-progression "Obtain OCP binaries (Installer and RHCOS)"  && return

		# This is the directory that the web server will run from
		[ ! -d $IMAGEREPO ] && mkdir -p $IMAGEREPO > /dev/null 2>&1
		cd $IMAGEREPO

		if [ ! -d "$OCPGETCLIENTVERSION"  ]
		then
			# Note that this script bundles your client and RHCOS dependencies under the client version number
			# we treat bad errors here differently to try to avoid repeating entire downloads

			mkdir $OCPGETCLIENTVERSION > /dev/null 2>&1
			cd $OCPGETCLIENTVERSION 
			echo "Getting the OCP installer (for version $OCPGETCLIENTVERSION) --> $PWD"

			# DOWNLOAD CLIENT STUFF FIRST (as of 4.6 it is common to all versions)
			wget $OCPDOWNLOADCLIENT/openshift-install-linux.tar.gz -O - | tar xz
			[ $? -ne 0 ] && { "echo Error downloading *openshift-installer*, exiting..."; cd ..; rm -rf ${OCPGETCLIENTVERSION}; exit; } 

			echo "Getting the OCP client -> $PWD"
			wget $OCPDOWNLOADCLIENT/openshift-client-linux.tar.gz -O - | tar xz 
			[ $? -ne 0 ] && { "echo Error downloading *openshift-client*, exiting..."; cd ..; rm -rf ${OCPGETCLIENTVERSION}; exit; } 
		
			echo "Getting RHCOS installer files... -> $PWD"

			if [ $(echo ${OCPGETCLIENTVERSION} | cut -c3) -ge 6 ]
			then
		
				##### KERNEL
				wget $OCPDOWNLOADIMAGE/rhcos-live-kernel-x86_64
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-initramfs*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; exit; } 
			
				##### INITRAMFS
				wget $OCPDOWNLOADIMAGE/rhcos-live-initramfs.x86_64.img
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-initramfs*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; exit; } 
		
				##### ROOTFS
				wget $OCPDOWNLOADIMAGE/rhcos-live-rootfs.x86_64.img
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-initramfs*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; exit; } 
		
				##### METAL
				wget $OCPDOWNLOADIMAGE/rhcos-metal.x86_64.raw.gz
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-metal*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; exit; } 
				
			else # Version 4.5 or earlier
		
				##### KERNEL
				wget $OCPDOWNLOADIMAGE/rhcos-installer-kernel-x86_64
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-kernel*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; exit; } 
			
				### INITRAMFS
				wget $OCPDOWNLOADIMAGE/rhcos-installer-initramfs.x86_64.img
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-initramfs*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; exit; } 
		
				##### METAL
				wget $OCPDOWNLOADIMAGE/rhcos-metal.x86_64.raw.gz
				[ $? -ne 0 ] && { echo 'Error downloading *rhcos-metal*, exiting...'; cd ..; rm -rf ${OCPGETCLIENTVERSION}; exit; } 
			fi
		else
			echo "Using OCP Version $OCPGETCLIENTVERSION already downloaded..."
		fi
	
		cd ${YAKKOSETUPDIR}

		# We remove the CLIENT word to make it less confusing if someone reads the ${CLUSTERCONFIGFILE} file
		OCPINSTALLVERSION=$OCPGETCLIENTVERSION
		echo OCPINSTALLVERSION=${OCPGETCLIENTVERSION} >> ${CLUSTERCONFIGFILE}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Downloaded binaries will remain in place"
	}
}


process-stage-httpserver() {

	HTTPDCONFIGFILE=/etc/httpd/conf.d/httpd-${YAKKONAME}-build-${CLUSTERNAME}.conf

	[ $1 == "progress" ] && {

        	advance-stage-progression "Configure HTTP server for installation of all cluster components"  && return

		ask-user "Configure and enable HTTP Server (port 8080 in virtual network) for install on this host" "Y" && {

			# Now that we know what we are running up, we can set the directory to provide the sources
			# From the below dir, things will get cookin'
			OCPINSTALLSOURCE=$IMAGEREPO/$OCPINSTALLVERSION
			echo "OCP will be made available by HTTP server from directory $OCPINSTALLSOURCE"
			echo
	
			install-package-if-missing httpd

			echo "<BR>"
			echo "<H1>The YAKKO web server is working!</H1>" > $IMAGEREPO/index.html # to have a test file there...
			echo "<H1>It is serving files for cluster builds with OCP Version<A HREF=${OCPINSTALLVERSION}>${OCPINSTALLVERSION}</A></H1>" >> $IMAGEREPO/index.html # to have a test file there...
		
			{
				echo "Listen ${WEBSERVERIP}:${WEBSERVERPORT}"
				echo "<VirtualHost ${WEBSERVERIP}:${WEBSERVERPORT}>"
				echo "	DocumentRoot ${IMAGEREPO}"
	   	 		echo "	<Directory ${IMAGEREPO}>"
	   	    		echo "		Options Indexes FollowSymLinks"
	   	    		echo "		Require all granted"
	   	    		echo "		AllowOverride None"
	   	 		echo "	</Directory>"
				echo "</VirtualHost>"
		
			} > ${HTTPDCONFIGFILE}
		
			# Figure out which of these are required
			# and needed to survive a reboot...
			chcon  --user system_u --type httpd_sys_content_t -Rv $IMAGEREPO
			semanage fcontext -a -t httpd_sys_content_t "$IMAGEREPO(/.*)?"
			restorecon -Rv $IMAGEREPO

			# We disable port 80 since we know it should not be served via httpd
			sed -i "/^Listen 80/c\# Listen 80" /etc/httpd/conf/httpd.conf  2>/dev/null
	
			systemctl restart httpd
			check-for-error-and-exit $? "Could not start HTTPD server"
			systemctl enable httpd

			echo "OCPINSTALLSOURCE=$OCPINSTALLSOURCE" >> $CLUSTERCONFIGFILE
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Unconfiguring installation webserver - content will remain in place."
		rm ${HTTPDCONFIGFILE}  2>/dev/null
		rm $IMAGEREPO/index.html  2>/dev/null
		systemctl restart httpd
	}
}


process-stage-changefirewall() {

	#If using a firewall on host, don't forget to allow connections to these ports on IP ${CLUSTERPROXY}: 6443, 22623, 80 and 443.

	[ $1 == "progress" ] && {

        	advance-stage-progression "Configure Firewall" && return

		firewall-cmd --state >/dev/null 2>&1
		if [ $? -eq 252 ]
		then
			echo "Firewall is not running. Configuration is not required."
		else
			ask-user "Change Firewall rules" "Y" && { 

				echo "Changing firewall port for HTTP - 80/tcp access"
				firewall-cmd --add-port=80/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=80/tcp --permanent

				echo "Changing firewall port for HTTP - 8080/tcp access"
				firewall-cmd --add-port=8080/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=8080/tcp --permanent

				echo "Changing firewall port for HTTPS 443/tcp access"
				firewall-cmd --add-port=443/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=443/tcp --permanent

				echo "Changing firewall port for COCKPIT - 9090/tcp access" 
				firewall-cmd --add-port=9090/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=9090/tcp --permanent

				echo "Changing firewall port for OCP API - 6443/tcp access"
				firewall-cmd --add-port=6443/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=6443/tcp --permanent

				echo "Changing firewall port for OCP comms - 22623/tcp access"
				firewall-cmd --add-port=22623/tcp --permanent
				firewall-cmd --zone=libvirt --add-port=22623/tcp --permanent

				echo "Changing firewall port for OCP comms - 22623/udp access"
				firewall-cmd --add-port=22623/udp --permanent
				firewall-cmd --zone=libvirt --add-port=22623/udp --permanent

				echo "Changing firewall port "
				firewall-cmd --add-service=dhcp --permanent

				firewall-cmd --reload
		}
		fi	
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Firewall will remain unchanged - ports stay open"
	}
}


process-stage-generateocpinstallerconfig() {

	[ $1 == "progress" ] && {

                advance-stage-progression "OCP Configuration for Installation"  && return

		ask-user "Generate OCP cluster manifests and ignition files required for cluster bootstrap" "Y" && {
	
			echo Writing "ocp-setup-env" script for administration. Run \"source ${YAKKOSETUPDIR}/ocp-setup-env\" to load post-install...
			{
				echo "PATH=\$PATH:${OCPINSTALLSOURCE}" 
				echo export KUBECONFIG=${CLUSTERSETUPDIR}/auth/kubeconfig
			}  > ocp-setup-env
			chmod +x ocp-setup-env

			# And we do this for the config file too, which is for the system
			{
				echo "PATH=\$PATH:${OCPINSTALLSOURCE}" 
				echo export KUBECONFIG=${CLUSTERSETUPDIR}/auth/kubeconfig
			}  >> ${CLUSTERCONFIGFILE}

			#And we set KUBECONFIG from here on too...
                        export KUBECONFIG=${CLUSTERSETUPDIR}/auth/kubeconfig
	
			# We load/reload, in case there was an interrupt to the AUTO setup and these values were released
			SSHPUBKEY=$(cat $OCPSSHKEY.pub)
			PULLSECRET=$(cat ${PULLSECRETFILE})

			# Check if HyperThreading is enabled, just in case
			CORECOUNT=$(less /proc/cpuinfo | grep cores | uniq | awk '{print $4}')
			THREADCOUNT=$(nproc)

			echo "The server has [$CORECOUNT] CPU cores and [$THREADCOUNT] threads"

			if [ ${CORECOUNT} -eq ${THREADCOUNT} ]
			then
				# No HT
				HYPERTHREADING=Disabled
			elif [ $((${CORECOUNT}*2)) -eq ${THREADCOUNT} ]
			then
				# HT is on
				HYPERTHREADING=Enabled
			else
				echo "CANNOT TELL IF HYPER-THREADING IS ENABLED, ASSUMING IT IS NOT"
				HYPERTHREADING=Disabled
			fi

			echo
			echo "Generating INSTALL CONFIG file..."
			
			{
				echo "apiVersion: v1"
				echo "baseDomain: ${CLUSTERDOMAIN}"
				echo "compute:"
				echo "- hyperthreading: ${HYPERTHREADING}"
				echo "  name: worker"
				echo "  replicas: 0"
				echo "controlPlane:"
				echo "  hyperthreading: ${HYPERTHREADING}"
				echo "  name: master"
				echo "  replicas: ${MASTERNODECOUNT}"
				echo "metadata:"
				echo "  name: ${CLUSTERNAME}"
				echo "networking:"
				echo "  clusterNetwork:"
				echo "  - cidr: 10.128.0.0/14 "
				echo "    hostPrefix: 23"
				echo "  networkType: OpenShiftSDN"
				echo "  serviceNetwork:"
				echo "  - 172.30.0.0/16"
				echo "platform:"
				echo "  none: {} "
				echo "fips: false "
				echo "pullSecret: '$PULLSECRET' "
				echo "sshKey: '$SSHPUBKEY'"
		
			} > ${CLUSTERSETUPDIR}/install-config.yaml
	
			# we make a copy for later review as this gets deleted by the create-manifests stage
			cp ${CLUSTERSETUPDIR}/install-config.yaml ${CLUSTERSETUPDIR}/install-config.yaml.original
	
			echo
			echo Creating manifests...
			${OCPINSTALLSOURCE}/openshift-install create manifests --dir=${CLUSTERSETUPDIR}
			check-for-error-and-exit $? "Could not create OCP manifests"

			if [ ${WORKERNODECOUNT} -gt 0 ]
			then
				# There are worker nodes to be built, so masters will become non-schedulable
				sed -i -r 's/(mastersSchedulable: ).*/\1False/' $CLUSTERSETUPDIR/manifests/cluster-scheduler-02-config.yml
			fi
		
			echo
			echo Creating OCP Cluster ignition files required for node configuration
			$OCPINSTALLSOURCE/openshift-install create ignition-configs --dir=$CLUSTERSETUPDIR
			check-for-error-and-exit $? "Could not create OCP ignition files"
			cp $CLUSTERSETUPDIR/*.ign $IMAGEREPO
			chmod 644 $IMAGEREPO/*.ign
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting cluster ignition and configuration files"
		rm ocp-setup-env > /dev/null 2>&1
		rm ${CLUSTERSETUPDIR}/install-config.yaml  > /dev/null 2>&1
		rm ${CLUSTERSETUPDIR}/install-config.yaml.original  > /dev/null 2>&1
		rm $IMAGEREPO/*ign  > /dev/null 2>&1
	}
}


process-stage-configurebootstrapnode() {

	[ $1 == "progress" ] && {

                advance-stage-progression "KVM Bootstrap Host Configuration" && return

		ask-user "Configure OCP bootstrap VM host" "Y" && 
			# Bootstrap node is MAC address is the first to be defined 
			build-ocp-node bootstrap ${BOOTSTRAPMAC} 2 6000 20 bootstrap.ign
			check-for-error-and-exit $? "Could not build VM for node [bootstrap]: virt-install error code [$?], check ~/.cache/virt-manager/virt-install.log"
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting bootstrap node"
		delete-kvm-machine bootstrap.${CLUSTERFQDN}
	}
}


process-stage-configureocpmasternodes() {

	[ $1 == "progress" ] && {

                advance-stage-progression "KVM Master Nodes Configuration"  && return

		ask-user "Configure OCP master VM hosts" "Y" && {

			build-ocp-node master-0 ${MASTER0MAC} ${MASTERVCPUS} ${MASTERRAMSIZE} ${MASTERDISKSIZE} master.ign
			check-for-error-and-exit $? "Could not build VM for node [master-0]"

			[ ${MASTERNODECOUNT} -gt 1 ] && {
				# It's either 1 or 3 nodes, never 2 AFAWK in 2020

				build-ocp-node master-1 ${MASTER1MAC} ${MASTERVCPUS} ${MASTERRAMSIZE} ${MASTERDISKSIZE} master.ign
				check-for-error-and-exit $? "Could not build VM for node [master-1]"

				build-ocp-node master-2 ${MASTER2MAC} ${MASTERVCPUS} ${MASTERRAMSIZE} ${MASTERDISKSIZE} master.ign
				check-for-error-and-exit $? "Could not build VM for node [master-2]"
			}
		}

	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting OCP master nodes"
		for MASTERNODE in $(virsh list --all --name | grep "master-" | grep ${CLUSTERFQDN})
                do
			delete-kvm-machine ${MASTERNODE}
                done
	}
}


process-stage-configureocpworkernodes() {

	[ $1 == "progress" ] && {

                advance-stage-progression "KVM Worker Node Configuration"  && return

		NODESTOBUILD=${WORKERNODECOUNT}

		if [ $NODESTOBUILD -eq 0 ]
		then
			echo "No Worker nodes were requested. Worker nodes can be added later by calling: "
			echo "      yakko infra addnode"
		else
			ask-user "Configure OCP worker VM node(s)" "Y" 
			if [ $? -eq 0 ]
			then
				while [ $NODESTOBUILD -ne 0 ]
				do
					((NODESTOBUILD--))
       	                		((NODECOUNT++))
       	                	 	sed -i "/NODECOUNT=.*/c\NODECOUNT=${NODECOUNT}" ${CLUSTERCONFIGFILE} 2>/dev/null
		
       			               	NEWNODENAME=node-${NODECOUNT}
					NEWNODELIST="${NEWNODELIST} ${NEWNODENAME}"
		
					build-ocp-node ${NEWNODENAME} auto ${WORKERVCPUS} ${WORKERRAMSIZE} ${WORKERDISKSIZE} worker.ign
					check-for-error-and-exit $? "Could not build VM for node [${NEWNODENAME}]"
				done
			fi
		fi
	}     

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Deleting OCP worker nodes"

		# Here's a tricky one since this function can be used during additional node build
		# or during a complete "deletecluster"
		# When it's the latter, we know that the DELETECLUSTERNAME must have the clustername set
		if [ "${DELETECLUSTERNAME}" == "${CLUSTERNAME}" ]
		then
			# Delete ALL worker nodes
			# All other cleanup is done as the cluster gets wiped
                	for NODETODELETE in $(virsh list --all --name | grep "node-" | grep ${CLUSTERFQDN})
                	do
				delete-kvm-machine ${NODETODELETE}
			done
		else
			# Delete nodes just added now with addnode
                	for NODETODELETE in ${NEWNODELIST} 
                	do
				echo "Rollback - deleting node [$NODETODELETE]"
				delete-kvm-machine ${NODETODELETE}
				sed -i "/${NODETODELETE}/d" /root/.ssh/known_hosts >/dev/null 2>&1

				# Update the virtual network
				echo "Restarting virtual network"
				cat ${NETWORKXML} | grep ${NODETODELETE} > /tmp/dhcp-yakko-line.xml #It's way too hard to pass this as an argument below!
				if [ $? -eq 0 ]
				then
					virsh net-update ${NETWORKNAME} delete ip-dhcp-host /tmp/dhcp-yakko-line.xml --live --config
					check-for-error-and-exit $? "Could not restart the virtual network"
					rm /tmp/dhcp-yakko-line.xml
					sed -i "/${NODETODELETE}/d" ${NETWORKXML}
				fi

				#and we update the haproxy
				echo
				echo "Updating and restarting HAproxy"
				sed -i "/${NODETODELETE}/ d" /etc/haproxy/${YAKKONAME}/${CLUSTERNAME}.cfg #> /dev/null 2>&1
				systemctl restart haproxy
				check-for-error-and-exit $? "Could not start HA Proxy, the cluster cannot function without this."
			done
		fi
	}
}


process-stage-startocpbootstrap() {

	[ $1 == "progress" ] && {

                advance-stage-progression "OCP Cluster Bootstrap"  && return

		ask-user "Start/continue OCP Cluster bootstrap" "Y" && {
	
			echo You can observe the output of the bootstrap node at this stage by issuing:
			echo ssh -i $OCPSSHKEY core@bootstrap.${CLUSTERFQDN} "sudo journalctl -b -f -u bootkube.service"
			echo 
	
			while [ 1 ]
			do
				$OCPINSTALLSOURCE/openshift-install --dir=$CLUSTERSETUPDIR wait-for bootstrap-complete
	
				if [ $? -eq 0 ]
				then
					#the wait-for bootstrap-complete was successful
					virsh list | grep bootstrap.${CLUSTERFQDN} > /dev/null 2>&1
					if [ $? -eq 0 ]
					then
						delete-kvm-machine bootstrap.${CLUSTERFQDN}

						# Now we delete the boostrap from the haproxy!!!
						cat ${HAPROXYCONFIGFILE} | grep -v bootstrap > ${HAPROXYCONFIGFILE}.nobootstrap
						rm -f ${HAPROXYCONFIGFILE}
						mv ${HAPROXYCONFIGFILE}.nobootstrap ${HAPROXYCONFIGFILE}
						systemctl restart haproxy
					fi
					break
				else
					echo
					echo "The bootstrap process doesn't appear to have completed successfully. "
					echo "This process downloads a lot of images from quay.io and can take a long time."
					echo
					echo    "Press <ENTER> to re-issue this stage (wait-for bootstrap-complete) and give it some more time, OR... "
					echo -n "Press <CTRL-C> to abort this install and examine then rerun install and return to this point"
					read CONTINUE
					$OCPINSTALLSOURCE/openshift-install --dir=$CLUSTERSETUPDIR wait-for bootstrap-complete
					echo
				fi
			done
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "OCP boostrap stage"
	}
}


process-stage-approvecsrs() {

	[ $1 == "progress" ] && {

                advance-stage-progression "CSR Background Approval"  && return

		ask-user "Approve pending/recurring CSRs" "Y" && {

			CSRAPPROVALPID=0
	
			if [ $CSRAPPROVALPID -eq 0 ]
			then
				# running oc here is a little trickier as this gets forked off, so we test for it before
				[ -x ${OCPINSTALLSOURCE}/oc ] 
				check-for-error-and-exit $? "Cannot process CSRs as this stage cannot execute command ${OCPINSTALLSOURCE}/oc"

				# This runs in the backgound approving certificates as they come...
				{
					trap "echo; echo 'CSR Approvals (oc get csr) stopped...'; exit" SIGQUIT
		
					while [ 1 ] 
					do
						sleep 10
						${OCPINSTALLSOURCE}/oc get csr 2>/dev/null | grep Pending | awk '{ print $1 }' | xargs ${OCPINSTALLSOURCE}/oc adm certificate approve > /dev/null 2>&1
					done
				} &
				CSRAPPROVALPID=$!
			fi
		
			# monitoring the output through the bootstrap requires not deleting it...
			trap 'kill -s SIGQUIT $CSRAPPROVALPID ; sleep 2; echo "Shutting down, please wait..."; sleep 20; exit' SIGINT
		}
	}		

	[ $1 == "rollback" ] && {
		rollback-stage-progression "CSR approvals"
		kill -s SIGKILL $CSRAPPROVALPID > /dev/null 2>&1
	}
}


process-stage-reduceprometheusmemory() {

	[ $1 == "progress" ] && {

                advance-stage-progression "Prometheus Memory Footprint"  && return

		ask-user "Reduce Prometheus pod memory allocation" "${REDUCEPROMETHEUS}" && {

			PROMETHEUSPID=0

			if [ $PROMETHEUSPID -eq 0 ]
			then
				{ 
					echo "prometheusK8s:" 
					echo "  resources:" 
					echo "    requests:"
   		   			echo "      memory: 256Mi"
				} > $CLUSTERSETUPDIR/prometheus-config.yaml
		
				sleep 20 # Seen issues before...
				${OCPINSTALLSOURCE}/oc create configmap cluster-monitoring-config --from-file=config.yaml=${CLUSTERSETUPDIR}/prometheus-config.yaml -n openshift-monitoring
			
				{
					trap "echo; echo 'Prometheus pods not deleted for resizing (oc delete pod prometheus-k8s-* -n openshift-monitoring)'; exit" SIGQUIT
					sleep 30 #This is what the recipe suggested...
		
					while [ 1 ] 
					do
						${OCPINSTALLSOURCE}/oc get pods -n openshift-monitoring 2>/dev/null | grep "prometheus-k8s" > /dev/null 2>&1
						[ $? -eq 0 ] && break

						sleep 15
					done
		
					sleep 10
					echo
					echo "Deleting Prometheus pods for memory reconfiguration"
					${OCPINSTALLSOURCE}/oc delete pod prometheus-k8s-0 -n openshift-monitoring
					${OCPINSTALLSOURCE}/oc delete pod prometheus-k8s-1 -n openshift-monitoring
		
				} &
				PROMETHEUSPID=$!
			fi
		
			# monitoring the output through the bootstrap requires not deleting it...
			trap 'kill -s SIGQUIT $PROMETHEUSPID; sleep 2; echo "Shutting down prometheus memory reduction (NOT DONE), please wait..."; sleep 20; exit' SIGINT
		
		}
	}	

	[ $1 == "rollback" ] && {
		if [ ${REDUCEPROMETHEUS} == "Y" ]
		then
			rollback-stage-progression "Prometheus memory changes"
			kill -s SIGKILL $PROMETHEUSPID > /dev/null 2>&1
			rm $CLUSTERSETUPDIR/prometheus-config.yaml >/dev/null 2>&1
		fi
	}
}


process-stage-waitforocpinstalltocomplete() {

	[ $1 == "progress" ] && {

                advance-stage-progression "OCP - Complete Installation"  && return

		ask-user "Wait for OCP install to complete" "Y" && {

			echo Some useful commands while waiting:
			echo "- tail -f $CLUSTERSETUPDIR/.openshift_install.log"
			echo "- source ocp-setup-env ---->  For access to \"oc\" at the command line"
			echo "- oc get clusteroperators ->  To check operator progression, can also be \"oc get co\""
			echo "- oc get clusterversion --->  On build, it shows you % progression, after that, cluster version" 
			echo "- oc get nodes ------------>  To see nodes and node status"
			echo
		
			$OCPINSTALLSOURCE/openshift-install --dir=$CLUSTERSETUPDIR wait-for install-complete 
			OCPINSTALLCODE=$?
			
			# Stop background "assistants"
			kill -s SIGQUIT $CSRAPPROVALPID $PROMETHEUSPID >  /dev/null 2>&1
			sleep 15

			echo
			echo ${SEPARATIONLINE}
			echo
			print-in-green  FINISHED OCP INSTALLATION - $(date)
			print-time-elapsed
			
		
			if [ $OCPINSTALLCODE -ne 0 ]
			then
				echo 
				echo The OCP Installer exited with code [ $OCPINSTALLCODE ]
				echo Cluster has $(${OCPINSTALLSOURCE}/oc get nodes | egrep "worker|master" | wc -l) nodes and $(${OCPINSTALLSOURCE}/oc get co | awk '{ print $3 }' | grep True | wc -l) operators up 
			else
				echo
				print-in-green "IMPORTANT:"
				print-in-green " - you DO NOT have a registry -> yakko ops localregistry"
				print-in-green " - you cannot access the cluster from another computer -> yakko infra openaccess"
				print-in-green " - you have no user DB-> yakko ops htpasswd administrator &  yakko ops useradd <user>"
				print-in-green ${SEPARATIONLINE}
				
				# We build the 'last successful config' file for further auto
				if [ ! -e ${LASTBUILDCONFIG} -o -w ${LASTBUILDCONFIG} ]
				then
					{
						echo "CLUSTERNAME=${CLUSTERNAME}"
						echo "CLUSTERDOMAIN=${CLUSTERDOMAIN}"
						echo "CLUSTERFQDN=${CLUSTERFQDN}"
						echo "BASENETWORK=${BASENETWORK}"
						echo "OCPVMDISKDIR=${OCPVMDISKDIR}"
						echo "MASTERNODECOUNT=${MASTERNODECOUNT}"
						echo "WORKERNODECOUNT=${WORKERNODECOUNT}"
						echo "MASTERRAMSIZE=${MASTERRAMSIZE}"
						echo "WORKERRAMSIZE=${WORKERRAMSIZE}"
						echo "OCPGETCLIENTVERSION=${OCPGETCLIENTVERSION}"
	
					} > ${LASTBUILDCONFIG}
				fi
			fi

			# We write the first time we believe the cluster was up, for reference
			# It also let's us know that there is no further building possible

			# This is my tab keeper, starting on 24/11/2020
			# to keep track of how many clusters I've built on my big box
			YAKKOHOSTNAME=$(hostname) 
			if [ "${YAKKOHOSTNAME}" == "terminus" -o "${YAKKOHOSTNAME}" == "trantor"  ]
			then
				echo "Cluster [${CLUSTERNAME}] built on [$(date)] - Masters: ${MASTERNODECOUNT} Workers: ${WORKERNODECOUNT}" >> /YAKKO-TALLY-${YAKKOHOSTNAME}
			fi
			echo

			# This will print the date like 15-06-2021@10:45:46
			echo CLUSTERCOMPLETE=\"exitcode ${OCPINSTALLCODE} date $(date +"%d-%b-%Y@%T")\" >> ${CLUSTERCONFIGFILE}

			check-cluster-state 1
		}
	}

	[ $1 == "rollback" ] && {
		rollback-stage-progression "installation of OCP cluster ${CLUSTERNAME}"	
	}
}


process-stage-continue-clusterconfiguration() {

	[ $1 == "progress" ] && {

        	advance-stage-progression "Continue Cluster Configuration"

		if [ ! -z "${CLUSTERCOMPLETE}" ]
		then	
			#if there was an install code registered in ${CLUSTERCONFIGFILE} file then the installer did all it could.
			check-cluster-state 1
			exit
		fi

		echo
		ask-user "Attempt AUTOMATIC configuration of cluster from this point" "Y" noauto
		if [ $? -eq 0 ]
		then 
			AUTOSETUP=1
		else
			echo
			ask-user "MANUAL CONFIGURATION: Resume where you left off (\"y\") or Start from the begining (\"n\")" "Y" noauto
			if [ $? -ne 0 ]
			then
				YAKKOSTAGE=0
			fi
		fi
	}	

	# NOTE: THIS STAGE MUST PRECEDE execute-yakko-stages
	# 	SEE MAIN AT BOTTOM

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Cluster configuration"
	}
}


process-stage-gatherclusterconfiguration() {

	[ $1 == "progress" ] && {

        	advance-stage-progression "Gather Cluster Configuration information"

		# A cluster config does not exist - this should be the first run
		
		# Some of these are more "global" in nature so we store them in ${YAKKODEFAULTS}
		# (which was separate functionality in earlier versions)


		if [ "${YAKKOREBUILD}" -eq 1 ]
		then
			# If ${LASTBUILDCONFING} exists, we created a successful cluster before
			# This can only be called with 'yakko rebuildcluster' with no cluster configured
			# And for this to happen we get here with YAKKOREBUILD == 1

			source ${LASTBUILDCONFIG}
		else
			# THIS SECTION IS ALL ABOUT QUESTIONS 

			echo "NOTE: Default options are in [brackets] - just press enter to accept them!"
			echo


			### QUESTION: Cluster name  ## Not stored in YAKKO defaults
			# identifying 'this' host - this can be tricky as we are looking for the interface with the cable (hopefully!)
			# we cycle through the physical ports and compare them to those that are up until we nail one
			for PHYSICALNWPORT in $(ls -l /sys/class/net/ | grep -v virtual | awk '{print $9}')
			do
				for CONNECTEDNWPORT in $(ip -br -4 addr show | grep UP |awk '{print$1}')
				do
					if [ $PHYSICALNWPORT == $CONNECTEDNWPORT ]
					then 
						YAKKOMAINHOSTPORT=$CONNECTEDNWPORT
						break
					fi
				done
				if [ ! -z "$YAKKOMAINHOSTPORT" ]
				then
					break
				fi
			done

			YAKKOHOSTIP=$(ip -br -4 addr show | grep ${YAKKOMAINHOSTPORT}| awk '{print $3}' | cut -f1 -d/)

			while [ 1 ]
			do
				echo "It is recommended that this host have a fixed IP address and a resolvable hostname."
				echo -n  "Enter the IP address of this host on your network [\"${YAKKOHOSTIP}\"]: "
				read RESPONSE
	
				if [ ! -z "${RESPONSE}" ]
				then
					if [[ $RESPONSE =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]
					then
						ping -c 1 $RESPONSE > /dev/null 2>&1
						if [ $? -eq 1 ]
						then
							echo "Could not identify this host IP address via PING. Check your IP address!"
							exit
						fi
						YAKOHOSTIP=$RESPONSE
					else
 						echo "That's not a valid IP address!"
						continue
					fi

					YAKKOHOSTIP=$RESPONSE
					break
				else
					break
				fi
			done
			echo


			### QUESTION: Cluster name  ## Not stored in YAKKO defaults
			while [ 1 ]
			do
				if [ ! -z "${CLUSTERNAME}" ]
				then
					echo -n "Enter the name of the OpenShift cluster to create [\"${CLUSTERNAME}\"]: "
				else
					echo -n "Enter the name of the OpenShift cluster to create: "
				fi
				read RESPONSE
	
				if [ -z "${RESPONSE}" -a ! -z "${CLUSTERNAME}" ]
				then
					echo "Cluster [${CLUSTERNAME}] will be created"
					break
				fi
		
				if [ -z "${RESPONSE}" ]
				then
					echo "Invalid cluster name."
					continue
				fi
		
				if [[ ${RESPONSE} =~ ^[a-z0-9]*$ ]]
				then
					CLUSTERNAME=${RESPONSE}
					break
				else
					echo "Invalid cluster name. Please use lower-case characters and numbers only."
				fi
			done
	
	
			### QUESTION: domain name ## Stored in YAKKO defaults
	       		echo
			echo -n "Enter the DOMAIN name to setup your cluster under [\"${CLUSTERDOMAIN}\"]: "
	       	 	read RESPONSE
			[ ! -z "$RESPONSE" ] && CLUSTERDOMAIN=$RESPONSE
	
	
	       		### QUESTION: basenetwork ## Stored in YAKKO defaults
	       		echo
	       		echo -n "Enter the SUBNET (/24) inside KVM that you want cluster under [\"${BASENETWORK}\"]: "
	       		read RESPONSE
	       		[ ! -z "$RESPONSE" ] && BASENETWORK=$(echo $RESPONSE | cut -f1-3 -d.)
	
	
			### QUESTION: Get repository for VMs ## Stored in YAKKO defaults
			echo
			VMDIRSUCCESS=0

			while [ 1 ]
			do
				while [ 1 ]
				do
					echo -n "Enter the directory where you wish to place the OCP VM disks [\"${OCPVMDISKDIR}\"]: "
					read RESPONSE
					[ -z "$RESPONSE" ] && RESPONSE=${OCPVMDISKDIR} 
					break
		        	done

				OCPVMDISKDIR="$RESPONSE"
				mkdir -p "${OCPVMDISKDIR}" > /dev/null 2>&1
				ERROR=$?
				if [ $ERROR -ne 0 ]
				then
					echo "ERROR: Could not create/access directory [${OCPVMDISKDIR}] (mkdir error #$ERROR)"
					echo "       specify another directory or CTRL-C to inspect your system."
					echo
					continue
				else

					# The following was discovered by Wayne Boxall, adequate check
					# https://docs.fedoraproject.org/en-US/Fedora/13/html/Virtualization_Guide/sect-Virtualization-Security_for_virtualization-SELinux_and_virtualization.html
					semanage fcontext -a -t virt_image_t "${OCPVMDISKDIR}(/.*)?" 2>/dev/null
					ERROR=$?
					if [ $ERROR -ne 0 -a $ERROR -ne 1 ]
					then
						echo "ERROR: Could not set virt_image_t context on directory [${OCPVMDISKDIR}] (fcontext error #$ERROR)"
						echo "       specify another directory or CTRL-C to inspect your system."
						echo
						continue
					fi

					restorecon -R -v "${OCPVMDISKDIR}"
					ERROR=$?
					if [ $ERROR -ne 0 ]
					then
						echo "ERROR: Could not set virt_image_t restorecon context on directory [${OCPVMDISKDIR}] (restorecon error #$ERROR)"
						echo "       specify another directory or CTRL-C to inspect your system."
						echo
						continue
					fi
				fi

				echo "Changing permissions for [${OCPVMDISKDIR}] and all paths above."
			       	echo "All members of the tree need to have read/exec access so that user 'qemu' can run VMs in the destination."

				cd "${OCPVMDISKDIR}"

				# we now add a r+x touch to the directory hierarchy where the VMs reside
				# This really should be in a separate process-stage now
				while [ 1 ] 
				do
					chmod o+rx . > /dev/null 2>&1
					ERROR=$?
					if [ $ERROR -ne 0 ]
					then
						echo "ERROR: Could not change access to directory [${PWD}] (chmod error #$ERROR)"
						echo "       specify another directory or CTRL-C to inspect your system."
						echo
						continue
					fi


					cd .. # This may not be elegant, but it works, we crawl the directory structure to the top
					if [ "$PWD" == "/" ]
					then
						VMDIRSUCCESS=1
						break
					fi
				done

				cd ${YAKKOSETUPDIR} # One day I'll clean this up....

				if [ ${VMDIRSUCCESS} -eq 1 ]
				then
					# All checks on the directory are complete
					break
				fi
			done
			echo
			
	
			### QUESTION: Cluster version
	
			# Now we get on with downloading the OCP binaries

			# NOTE: There can be discrepancies between the installer version (OCPGETCLIENTVERSION) and 
			# the RHCOS images version (OCPGETIMAGEVERSION)
			# We will download the lot under OCPGETCLIENTVERSION to keep a single point reference. This seems to make sense 
			# based on what the OCP mirror offers.
			# HOWEVER, outside of the DOWNLOAD section of the script, the version will be known as OCPINSTALLVERSION

			# regular releases are at:
			# INSTALLER: https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/latest
			# IMAGES: https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos/latest/latest

			# pre-release are at:
			# INSTALLER: https://mirror.openshift.com/pub/openshift-v4/clients/ocp-dev-preview/latest

			# Latest candidates:
			# INSTALLER: https://mirror.openshift.com/pub/openshift-v4/clients/ocp/candidate/

			# IMAGES: https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos/pre-release/latest/
		
			# Get the OCP installer specifically for x86_64. One day this may be useful for IBM ... Power ;)
			OCPPLATFORM=x86_64
			OCPROOT=https://mirror.openshift.com/pub/openshift-v4/$OCPPLATFORM
		
			# This would get you the number for the latest version
			OCPDOWNLOADCLIENT="$OCPROOT/clients/ocp/latest"
			OCPDOWNLOADIMAGE="$OCPROOT/dependencies/rhcos/latest/latest"
	
			wget -O $OCPWGETTMP $OCPDOWNLOADCLIENT/release.txt > /dev/null 2>&1
			check-for-error-and-exit $? "Failed to download version file for latest OCP" 
				
		        OCPGETCLIENTVERSION=$(cat $OCPWGETTMP | grep Version: | awk '{ print $2 }')

			OCPIMAGESONFILE=$(ls -d images/[0-9]* 2>/dev/null | cut -f2 -d/)

			SINGLEMASTERALLOWED=0 # This is 1 only if we confirm you are on OCP 4.8 or later (forget 4.3, too old)

			while [ 1 ]
			do
				echo "What release version do you want to install:"
				echo "    1) Latest release available ($OCPGETCLIENTVERSION)"
				echo "    2) Releases on disk"
				for AVAILIMAGE in $OCPIMAGESONFILE
				do
					echo "        - $AVAILIMAGE"
				done
				echo "    3) Older releases (hard! you will need to pick image version and installer version) "
				echo "    4) Latest release candidate (good luck!)"
				echo "    5) Latest pre-release nightly (unknown territory...)"
				echo -n "Pick option number from above (1-5) [1]: "
				read RESPONSE
	
				if [ "$RESPONSE" == "" -o "$RESPONSE" == 1 ]
				then
					RESPONSE=1
					break
				elif [ "$RESPONSE" == "2" ]
				then
					while [ 1 ]
					do
						echo -n "Select image version from above list of on-disk images (copy/paste from above): "
						read OCPGETCLIENTVERSION
						if [ -d images/${OCPGETCLIENTVERSION} ]
						then
							break
						else
							echo "Image [${OCPGETCLIENTVERSION}] is not a valid/existing image, choose another."
						fi
					done
					break
				elif [ "$RESPONSE" == "3" ]
				then
					# Query what client is desired
					while [ 1 ]
					do
						echo -n  'Enter OCP INSTALLER CLIENT version you require, e.g. "4.5.6" (may not work btw...): ' 
						read OCPGETCLIENTVERSION
						OCPDOWNLOADCLIENT="$OCPROOT/clients/ocp/$OCPGETCLIENTVERSION"
				
						wget -O $OCPWGETTMP $OCPDOWNLOADCLIENT/sha256sum.txt >/dev/null 2>&1
						if [ $? -ne 0 ]
						then
							echo "Invalid version $OCPGETCLIENTVERSION, no content available"
						else
							break
						fi
					done
		
					# Query what RHCOS is desired
					while [ 1 ]
					do
						echo "Please refer to https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos/${OCPGETCLIENTVERSION:0:3})"
						echo -n  'Enter OCP RHCOS version you require, e.g. "4.5.6" (may also not work btw...): ' 
						 # this is harder because of how the mirror is laid out
						read OCPGETIMAGEVERSION
						VERSIONMAJOR=$(echo $OCPGETIMAGEVERSION | cut -f1 -d.)
						VERSIONMINOR=$(echo $OCPGETIMAGEVERSION | cut -f2 -d.)
						VERSIONMICRO=$(echo $OCPGETIMAGEVERSION | cut -f3 -d.)
						OCPDOWNLOADIMAGE="$OCPROOT/dependencies/rhcos/$VERSIONMAJOR.$VERSIONMINOR/$OCPGETIMAGEVERSION"
		
						wget -O $OCPWGETTMP $OCPDOWNLOADIMAGE/sha256sum.txt >/dev/null 2>&1
						if [ $? -ne 0 ]
						then
							echo "Invalid version $OCPGETIMAGEVERSION, no content available"
						else
							break 2  # We break out of 2 loops at once
						fi
					done
				elif [ "$RESPONSE" == "4" ]
				then
					# This is the preview of the upcoming release - typically a RC or release candidate
					OCPDOWNLOADCLIENT=https://mirror.openshift.com/pub/openshift-v4/clients/ocp/candidate/
					OCPDOWNLOADIMAGE=https://mirror.openshift.com/pub/openshift-v4/dependencies/rhcos/pre-release/latest
					wget -O $OCPWGETTMP $OCPDOWNLOADCLIENT/release.txt > /dev/null 2>&1
					check-for-error-and-exit $? "Failed to download version file for latest pre-buildOCP"
					#OCPGETCLIENTVERSION=$(curl -s ${OCPDOWNLOADIMAGE}/sha256sum.txt | awk '{print $2}' | grep live-kernel-x86_64 | grep fc | cut -f2,3 -d"-")
					check-for-error-and-exit $? "Failed to download version file for latest OCP" 

		        		OCPGETCLIENTVERSION=$(cat $OCPWGETTMP | grep Version: | awk '{ print $2 }')
					echo "OCP pre-release version [$OCPGETCLIENTVERSION] will be downloaded to ${YAKKOSETUPDIR}/images"

					SINGLEMASTERALLOWED=1

					break
				elif [ "$RESPONSE" == "5" ]
				then
					# This is the preview of the release after next - the latest is a nightly
					OCPDOWNLOADCLIENT=https://mirror.openshift.com/pub/openshift-v4/clients/ocp-dev-preview/latest
					OCPDOWNLOADIMAGE=https://mirror.openshift.com/pub/openshift-v4/dependencies/rhcos/pre-release/latest
					wget -O $OCPWGETTMP $OCPDOWNLOADCLIENT/release.txt > /dev/null 2>&1
					check-for-error-and-exit $? "Failed to download version file for latest pre-buildOCP"
					#OCPGETCLIENTVERSION=$(curl -s ${OCPDOWNLOADIMAGE}/sha256sum.txt | awk '{print $2}' | grep live-kernel-x86_64 | grep fc | cut -f2,3 -d"-")
					check-for-error-and-exit $? "Failed to download version file for latest OCP" 

		        		OCPGETCLIENTVERSION=$(cat $OCPWGETTMP | grep Version: | awk '{ print $2 }')
					echo "OCP nightly version [$OCPGETCLIENTVERSION] will be downloaded to ${YAKKOSETUPDIR}/images"

					SINGLEMASTERALLOWED=1

					break
				else
					echo
					echo "Invalid selection, try again!"
					echo
				fi
			done


			# Experimental I said!
			if [ "$SINGLEMASTERALLOWED" == 1 ]
			then
				### QUESTION: Master node count ## EXPERIMENTAL until 4.8 release
				echo
				echo "Clusters with a single master node is experimental with 4.8 and above"
				while [ 1 ]
				do
					# The default comes from .yakkodefaults but is version dependent
					echo -n "How many MASTER nodes do you want to configure (1 or 3) [${MASTERNODECOUNT}]: "
	
					read RESPONSE
	
					if [ -z "${RESPONSE}" ]
					then 
						RESPONSE=${MASTERNODECOUNT}
						break
					else
						if [ $RESPONSE == 1 -o $RESPONSE == 3 ]
						then
							MASTERNODECOUNT=$RESPONSE
							break
						else
							echo "Invalid master node count, choose 1 or 3."
						fi
					fi
				done
			else	
				MASTERNODECOUNT=3
			fi

			
			### QUESTION: RAM size confirmation (MASTERS)  ##
			echo
			while [ 1 ]
	                do
				if [ ${MASTERNODECOUNT} -eq 1 ]
				then
					MASTERRAMSIZE=16000
				fi
	                	echo -n "How much RAM (MiB) should be allocated to MASTER nodes [${MASTERRAMSIZE}]: "
				read VALUE
				if [ ! -z "$VALUE" ]
				then
					NUMBERRE='^[0-9]+$'
					if ! [[ $VALUE =~ $NUMBERRE ]] ; then
						echo "Error: Not a number. Try again..."
						continue
					else
						MASTERRAMSIZE=$VALUE
					fi
				fi
				break
			done
			echo
	

			### QUESTION: Add worker nodes at build ##
			while [ 1 ]
	                do
				echo "Worker nodes can be built at cluster creation or later."
				echo "To build a cluster with 3 schedulable MASTER nodes, type '0'"
				echo -n "How many worker nodes do you want to configure at cluster build time [0]: "
				read VALUE
				if [ ! -z "$VALUE" ]
				then
					NUMBERRE='^[0-9]+$'
					if ! [[ $VALUE =~ $NUMBERRE ]] ; then
						echo "Error: Not a number. Try again..."
						continue
					elif [ ${VALUE} -gt ${MAXWORKERNODES} ]
					then
						echo "You need to specify a number of workers up to ${MAXWORKERNODES} ]"
						continue
					else
						WORKERNODECOUNT=${VALUE}
						break
					fi
				else
					WORKERNODECOUNT=0
					echo "No worker nodes were requested. You can add nodes later with YAKKO."
					break
				fi
			done
			echo

			### QUESTION: RAM size confirmation (WORKERS)  ##
			if [ ${WORKERNODECOUNT} -gt 0 ]
			then 
			 	while [ 1 ]
	                 	do
	                 		echo -n "How much RAM (MiB) should be allocated to WORKER nodes [${WORKERRAMSIZE}]: "
			 		read VALUE
			 		if [ ! -z "$VALUE" ]
			 		then
			 			NUMBERRE='^[0-9]+$'
			 			if ! [[ $VALUE =~ $NUMBERRE ]] ; then
			 				echo "Error: Not a number. Try again..."
			 				continue
			 			else
			 				WORKERRAMSIZE=$VALUE
			 			fi
			 		fi
			 		break
			 	done
			 	echo
			fi
	
		fi

		# We write a bunch of stuff for later retrieval in $YAKKODEFAULTS
		CLUSTERSETUPDIR=${YAKKOSETUPDIR}/install-${CLUSTERNAME}
		mkdir $CLUSTERSETUPDIR > /dev/null 2>&1

		NETWORKNAME=net-${YAKKONAME}-${CLUSTERNAME}
		NETWORKXML=$CLUSTERSETUPDIR/${NETWORKNAME}.xml
		CLUSTERFQDN=${CLUSTERNAME}.${CLUSTERDOMAIN}
		CLUSTERWEBURL="https://console-openshift-console.apps.${CLUSTERFQDN}"
		CLUSTERAPIURL="https://api.${CLUSTERFQDN}:6443"
		CLUSTERPROXY="${BASENETWORK}.${PROXYADDRESS}"
                WEBSERVERIP=${CLUSTERPROXY}
                WEBSERVERPORT=8080
		OCPSSHKEY=~/.ssh/id_rsa_ocp.${CLUSTERNAME}
		DNSMASQCONFIGFILE=/etc/NetworkManager/dnsmasq.d/dnsmasq-${YAKKONAME}-${CLUSTERNAME}.conf
		HAPROXYCONFIGFILE=/etc/haproxy/${YAKKONAME}/${CLUSTERNAME}.cfg

		# We calculate the BASEMACADDRESS last digit here...
		# This in case there is more than one cluster defined!
		BASEMACADDRESS=${COREMACADDRESS}:$(echo ${BASENETWORK} | cut -f3 -d. | xargs printf '%x')

		populate-yakkodefaults
		populate-clusterconfigfile

		### QUESTION (last): Run auto setup
 
		# We reload the defaults...
		source ${YAKKODEFAULTS} > /dev/null 2>&1

		if [ ${YAKKOREBUILD} == 1 ]
		then
			AUTOSETUP=1
		else
			ask-user "Attempt AUTOMATIC creation of cluster \"${CLUSTERNAME}\"" "Y" noauto  && AUTOSETUP=1
		fi
	}
	# NOTE: THIS STAGE MUST PRECEDE execute-yakko-stages
	# 	SEE MAIN AT BOTTOM

	[ $1 == "rollback" ] && {
		rollback-stage-progression "Cluster configuration gather"
		rm ${CLUSTERCONFIGFILE} > /dev/null 2>&1
		rm -rf $CLUSTERSETUPDIR > /dev/null 2>&1
	}
}


execute-yakko-stages() {

	ACTION=$1 # progress or rollback

	if [ "${ACTION}" == "rollback" ]
	then
		echo
		ask-user "*** CONFIRM *** - Deleting cluster [${CLUSTERNAME}]" "N" noauto
		[ $? -ne 0 ] && { echo; echo "ATTENTION: No action taken. Exiting."; exit; }
		
		# User wants the cluster gone!
		AUTOSETUP=0
	fi
	
	process-stage-pullsecret ${ACTION}
	process-stage-downloadocpbinaries ${ACTION}
	process-stage-libvirt ${ACTION}
	process-stage-sshclient ${ACTION}
	process-stage-virtualnetwork ${ACTION}
	process-stage-dns ${ACTION}
	process-stage-httpserver ${ACTION}
	process-stage-loadbalancer ${ACTION}
	process-stage-changefirewall ${ACTION}
	process-stage-generateocpinstallerconfig ${ACTION}
	process-stage-configurebootstrapnode ${ACTION}
	process-stage-configureocpmasternodes ${ACTION}
	process-stage-configureocpworkernodes ${ACTION}
	process-stage-startocpbootstrap ${ACTION}
	process-stage-approvecsrs ${ACTION}
	process-stage-reduceprometheusmemory ${ACTION}
	process-stage-waitforocpinstalltocomplete ${ACTION}

	if [ "${ACTION}" == "rollback" ]
	then
		#This last one actually deletes the clusterconfig file
		#And when this happens, yakko no longer believes that a cluster exists
		#So this must be done AFTER all stages are cleared
		process-stage-gatherclusterconfiguration rollback
		echo
		echo "Cluster [${CLUSTERNAME}] and all associated configuration have been deleted."
		echo
		exit
	fi
}
						

######################################################################################################
##########  If this were a different programming language, you would call this a "main()".... ########
######################################################################################################

if [ "$1" == "backup" ]
then
	# This is action 0, the developer wants to make a backup
	# There will be no cluster built, nothing
	yakko-backup $*
fi

clear -x
print-in-green ${SEPARATIONLINE}
echo
print-in-green ' YAKKO: Yet Another KVM Konfigurator for Openshift'
print-in-green ${SEPARATIONLINE}
echo

if [ $(whoami) != 'root' ]
then 
	echo "ATTENTION: You must be user <root> to run ${YAKKONAME}"
	echo
	exit
fi

CALLINGDIRECTORY=$(dirname $(realpath $0))

if [ ! -e "${CALLINGDIRECTORY}/.yakkohome" ]
then
	while [ 1 ]
	do
		# This is not even installed!
		echo
		echo "${YAKKONAME} is not installed in [${CALLINGDIRECTORY}]."
		echo -n "Enter the directory where you want to install ${YAKKONAME} [/YAKKO]: "
		read RESPONSE

		if [ -z "${RESPONSE}" ]
		then
			RESPONSE=/YAKKO
		fi

		mkdir ${RESPONSE} > /dev/null 2>&1
		RESULT=$?

		[ $RESULT -ne 0 ] && {

			if [ $RESULT -eq 1 ] 
			then
				# The directory already exists
				if [ $(ls -la ${RESPONSE} | wc -l) -gt 3  ] 
				then
					# And - it has files in it.
					echo
					echo  "Directory [$RESPONSE] already exists and contains files. "
					ask-user "Continue installing ${YAKKONAME} in this directory" "N" noauto
					[ $? -eq 1 ] && continue || break
				else
					# It's empty so we can continue
					break
				fi
			fi

			echo "Could not create directory [${RESPONSE}]. Try again."
			echo
			continue
		}

		break
	done

	cp $0 ${RESPONSE}
	check-for-error-and-exit $? "Could not copy ${YAKKONAME} to ${RESPONSE}"
	chmod +x ${RESPONSE}/${YAKKONAME}
	touch ${RESPONSE}/.yakkohome
	check-for-error-and-exit $? "Could not create installer stub in ${RESPONSE}"

	echo
	echo "${YAKKONAME} is now installed. Run again from directory [${RESPONSE}] to continue!"
	echo
	exit
fi

# We define a set of key config variables and files now that we know where we are running from
YAKKOSETUPDIR=${CALLINGDIRECTORY}
IMAGEREPO=${YAKKOSETUPDIR}/images # The webserver will serve from here. oc and openshift-install are here already
CLUSTERCONFIGFILE=${YAKKOSETUPDIR}/.clusterconfig # Filename where all defaults for the cluster you are building are kept
PULLSECRETFILE=${YAKKOSETUPDIR}/.pullsecret
LASTBUILDCONFIG=${YAKKOSETUPDIR}/.lastyakkobuild
YAKKODEFAULTS=${YAKKOSETUPDIR}/.yakkodefaults # Filename where all defaults for YAKKO are kept

cd ${YAKKOSETUPDIR} >/dev/null 2>&1 # Just change to the directory of action from hereon

# We load YAKKO defaults whether they exist... or not.
source ${YAKKODEFAULTS} > /dev/null 2>&1

# HERE IT ALL BEGINS
# This is the last code group - a cluster config file exists or it doesn't

# if the user passed a parameter, let's capture it here... it could be "infra" or "ops"
YAKKOCALLOPTION=$1


if [ ! -r ${CLUSTERCONFIGFILE} ]
then
	if [ ! -z "${YAKKOCALLOPTION}" ] 
	then
		# There is no cluster, the only $1 option is to rebuild
		if [ "${YAKKOCALLOPTION}" == "rebuildcluster" ] 
		then
			if [ -f "${LASTBUILDCONFIG}" ]
			then
				YAKKOREBUILD=1
			else
				echo
				echo "You can't rebuild a prior cluster config since there is no known configuration stored"
				echo
				exit
			fi
		else
			echo
			echo "No cluster is configured. To begin, just run \"${YAKKONAME}\"." 
			echo
			exit
		fi

	fi

	process-stage-gatherclusterconfiguration progress
	execute-yakko-stages progress

else
	source ${CLUSTERCONFIGFILE} # Load config variables that this script accumulates

	# OK - the user wants to complete back out
	if [ "${YAKKOCALLOPTION}" == infra -a "$2" == deletecluster ]
	then
		yakko-infra-operations deletecluster $3
	fi

	if [ ! -z "${CLUSTERCOMPLETE}" ] 
	then

		# We first check to see if the cluster is powered up - and void hassle
		check-cluster-state 0 power
		if [ $? -eq 4 ]
		then

			# When the cluster is shutdown, you can start it or DELETE it!

			if [ "${YAKKOCALLOPTION}" == infra -a "$2" == startcluster ]
			then	
				yakko-infra-operations startcluster
			fi

			echo
			echo "The cluster is shutdown. Call 'yakko infra startcluster' to start it up!"
			echo
			exit
		fi	

		if [ $# -eq 0 ] # parameters go here when there is a cluster - see above and (backup: for developers)
		then
			check-cluster-state 1  # yakko is called on an existing cluster - check it!
		fi

		if [ $YAKKOCALLOPTION == "infra" ]
		then
			shift # we get rid of "infra"
			yakko-infra-operations $* # always exits
			check-cluster-state 1  # yakko is called on an existing cluster - check it! 1 makes it exit
		fi

		if [ $YAKKOCALLOPTION == "ops" ]
		then
			shift # we get rid of "ops"
			yakko-cluster-operations $* # always exits
		fi

		echo "ERROR: Invalid argument passed [$YAKKOCALLOPTION]. "
		echo
		echo "USAGE: $YAKKONAME [ops <OPTION> [params] | infra <OPTION> [params]]"
		echo 
	else
		# This cluster is NOT OPERATIONAL - it's not technically a cluster at this point

		echo "There is no fully configured/operational OpenShift cluster"
		echo

		ask-user "Continue configuring cluster [${CLUSTERNAME}]" "Y" noauto
		if [ $? -eq 0 ]
		then
			process-stage-continue-clusterconfiguration progress
			execute-yakko-stages progress
		else
			# Since there is no cluster, offer to delete
			ask-user "Delete existing configuration progress for [${CLUSTERNAME}]" "Y" noauto
			if [ $? -eq 0 ]
			then
				# In case there is any doubt, this clears, it - all must go!
				DELETECLUSTERNAME=${CLUSTERNAME}
				execute-yakko-stages rollback
			fi
		fi
	fi
fi

####################################################################################
#####################                 YAKKO END!             #######################
####################################################################################
